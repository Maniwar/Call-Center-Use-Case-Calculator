<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Contact Center ROI Calculator - Advanced Edition</title>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
    
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        // Register Chart.js components
        if (window.Chart && Chart.controllers && Chart.elements && Chart.plugins && Chart.scales) {
            try {
                Chart.register(
                    ...Object.values(Chart.controllers),
                    ...Object.values(Chart.elements),
                    ...Object.values(Chart.plugins),
                    ...Object.values(Chart.scales)
                );
            } catch (e) {
                console.log('Chart registration handled by Chart.js automatically');
            }
        }
    </script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 100px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Print styles */
        @media print {
            .no-print {
                display: none !important;
            }
            body {
                background: white !important;
            }
        }
        
        /* Chart container styles */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        
        /* Icon styles */
        .icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 350px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -175px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Tab styles */
        .tab-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .tab-inactive {
            background-color: #E5E7EB;
            color: #374151;
        }
        
        .tab-inactive:hover {
            background-color: #D1D5DB;
        }
        
        /* Table styles */
        .analytics-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analytics-table th {
            background-color: #F3F4F6;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #E5E7EB;
        }
        
        .analytics-table td {
            padding: 8px;
            border-bottom: 1px solid #E5E7EB;
        }
        
        .analytics-table tr:hover {
            background-color: #F9FAFB;
        }
        
        /* Filter button styles */
        .filter-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .filter-btn-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .filter-btn-inactive {
            background-color: white;
            color: #374151;
            border: 1px solid #D1D5DB;
        }
        
        .filter-btn-inactive:hover {
            background-color: #F3F4F6;
        }
        
        /* Guidance section styles */
        .guidance-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #3B82F6;
        }
        
        .guidance-title {
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .guidance-content {
            color: #4B5563;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .example-box {
            background: #F3F4F6;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
        }
        
        .metric-guide {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }
        
        .metric-item {
            background: #F9FAFB;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #E5E7EB;
        }
        
        .metric-label {
            font-weight: 600;
            color: #374151;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .metric-value {
            color: #059669;
            font-weight: 500;
            font-size: 14px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 24px;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            cursor: pointer;
            background: #F3F4F6;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #E5E7EB;
        }
        
        /* Settings panel styles */
        .settings-section {
            background: #F9FAFB;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }
        
        .settings-item {
            display: flex;
            flex-direction: column;
        }
        
        .settings-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }
        
        .settings-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .settings-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Month selector styles */
        .month-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #F3F4F6;
            border-radius: 6px;
        }
        
        .month-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: white;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .month-remove {
            cursor: pointer;
            color: #EF4444;
            font-weight: bold;
        }
        
        .month-remove:hover {
            color: #DC2626;
        }
        
        /* Date range picker styles */
        .date-range-picker {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .date-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
        }
        
        .date-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Cost type toggle */
        .cost-type-toggle {
            display: inline-flex;
            background: #E5E7EB;
            border-radius: 6px;
            padding: 2px;
        }
        
        .cost-type-btn {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cost-type-btn-active {
            background: white;
            color: #1F2937;
            font-weight: 600;
        }
        
        .cost-type-btn-inactive {
            background: transparent;
            color: #6B7280;
        }
        
        .cost-type-btn-inactive:hover {
            color: #374151;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="spinner"></div>
        <p style="text-align: center; margin-top: 20px; color: white;">Loading AI ROI Calculator...</p>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // SINGLE SOURCE OF TRUTH FOR ALL CHANNELS
        const ALL_CHANNELS = [
            { id: 'phone', label: 'Phone', defaultCost: 6.00 },
            { id: 'chat', label: 'Chat', defaultCost: 2.50 },
            { id: 'email', label: 'Email', defaultCost: 4.00 },
            { id: 'sms', label: 'SMS', defaultCost: 1.50 },
            { id: 'social', label: 'Social', defaultCost: 3.00 },
            { id: 'bot', label: 'Bot', defaultCost: 0.50 }
        ];
        
        // Simple SVG icons as components
        const Icons = {
            Download: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                </svg>
            ),
            Upload: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
            ),
            Plus: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
            ),
            Trash: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            ),
            Settings: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            ),
            Chart: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
            ),
            Save: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V2" />
                </svg>
            ),
            Users: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            ),
            Clock: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Dollar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Calendar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            ),
            Clear: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Help: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            FileText: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
            ),
            Info: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Close: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ),
            Calendar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            ),
            Dollar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Clock: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            )
        };

        // Input Guidance Data
        const InputGuidance = {
            "Deflection Rate (%)": {
                baseline: {
                    description: "Current % of contacts that are already being deflected by existing automation (if any)",
                    typical: "0-10%",
                    example: "If you already have a basic FAQ bot handling 5% of queries, enter 5"
                },
                volume: {
                    description: "Number of simple, repetitive contacts that AI could potentially handle",
                    calculation: "Total contacts × % that are simple/repetitive",
                    example: "10,000 monthly chats × 40% simple = 4,000 volume"
                },
                improvement: {
                    description: "Expected % of the volume that AI will successfully handle without agent",
                    typical: "60-80%",
                    example: "If AI can handle 70% of the 4,000 simple queries, enter 70"
                },
                industryBenchmarks: {
                    "Password Resets": "85-95%",
                    "Order Status": "75-85%",
                    "FAQs": "70-80%",
                    "Account Balance": "80-90%"
                }
            },
            "AHT Reduction (min)": {
                baseline: {
                    description: "Minutes already saved by current tools/processes (if any)",
                    typical: "0-1 min",
                    example: "If current tools save 0.5 minutes, enter 0.5"
                },
                volume: {
                    description: "Number of agent-handled contacts where AI co-pilot will assist",
                    calculation: "Total agent contacts that need assistance",
                    example: "5,000 complex calls requiring agent assistance"
                },
                improvement: {
                    description: "Minutes saved per contact through AI assistance",
                    typical: "1.5-3 min",
                    example: "AI helps save 2 minutes per call, enter 2"
                },
                industryBenchmarks: {
                    "Knowledge Suggestions": "1-2 min",
                    "Auto-fill Forms": "2-3 min",
                    "Sentiment Analysis": "0.5-1 min",
                    "Next Best Action": "1.5-2.5 min"
                }
            },
            "Automation Rate (%)": {
                baseline: {
                    description: "Current % of processes that are already automated",
                    typical: "10-20%",
                    example: "If 15% of orders are processed automatically, enter 15"
                },
                volume: {
                    description: "Number of routine tasks that could be automated",
                    calculation: "Total routine/repetitive tasks",
                    example: "8,000 order status checks per month"
                },
                improvement: {
                    description: "Expected % that will be fully automated by AI",
                    typical: "50-70%",
                    example: "AI can automate 65% of routine tasks, enter 65"
                },
                industryBenchmarks: {
                    "Order Processing": "60-75%",
                    "Returns/Refunds": "50-65%",
                    "Appointment Scheduling": "70-85%",
                    "Document Processing": "55-70%"
                }
            },
            "Self-Service Resolution (%)": {
                baseline: {
                    description: "Current % resolved through existing self-service",
                    typical: "10-25%",
                    example: "If current portal resolves 20%, enter 20"
                },
                volume: {
                    description: "Number of contacts attempting self-service",
                    calculation: "Contacts that try self-service first",
                    example: "3,000 customers trying to self-serve"
                },
                improvement: {
                    description: "Expected % that AI will help resolve without agent",
                    typical: "40-60%",
                    example: "AI improves resolution to 55%, enter 55"
                },
                industryBenchmarks: {
                    "Product Comparisons": "45-60%",
                    "Troubleshooting": "40-55%",
                    "Account Management": "50-65%",
                    "Policy Information": "60-75%"
                }
            },
            "Transfer Rate Reduction (%)": {
                baseline: {
                    description: "Current transfer rate between agents/departments",
                    typical: "25-35%",
                    example: "If 30% of calls are transferred, enter 30"
                },
                volume: {
                    description: "Number of contacts that currently get transferred",
                    calculation: "Total contacts × current transfer rate",
                    example: "10,000 calls × 30% transfer rate = 3,000"
                },
                improvement: {
                    description: "Expected reduction in transfer rate",
                    typical: "30-50%",
                    example: "Reduce transfers by 40%, enter 40"
                },
                industryBenchmarks: {
                    "Smart Routing": "35-45%",
                    "Intent Detection": "40-50%",
                    "Skill-based Routing": "30-40%",
                    "Context Preservation": "45-55%"
                }
            }
        };

        const AIValueCalculator = () => {
            // Initialize with reasonable defaults
            const generateMonthsFromRange = (startDate, endDate) => {
                const months = [];
                const current = new Date(startDate);
                const end = new Date(endDate);
                
                while (current <= end) {
                    months.push({
                        id: `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`,
                        year: current.getFullYear(),
                        month: current.toLocaleString('default', { month: 'short' })
                    });
                    current.setMonth(current.getMonth() + 1);
                }
                return months;
            };

            // Load saved data or use defaults
            const loadFromStorage = () => {
                try {
                    const savedData = localStorage.getItem('aiValueCalculatorData');
                    if (savedData) {
                        const parsed = JSON.parse(savedData);
                        return {
                            channelCosts: parsed.channelCosts || ALL_CHANNELS.reduce((acc, ch) => {
                                acc[ch.id] = ch.defaultCost;
                                return acc;
                            }, {}),
                            // Add AHT minutes support; if missing in stored data, UI will fall back to defaultAHT
                            categoryCosts: parsed.categoryCosts || {
                                'Pre-Sales': { 
                                    _default: { costType: 'perContact', value: 5.00, ahtMinutes: 10 },
                                    phone: {
                                        _default: { costType: 'perContact', value: 6.00, ahtMinutes: 12 },
                                        _specialGroups: {
                                            'Senior Sales': { costType: 'perContact', value: 8.00, ahtMinutes: 10 }
                                        }
                                    },
                                    chat: {
                                        _default: { costType: 'perContact', value: 4.50, ahtMinutes: 8 }
                                    }
                                },
                                'Order Support': { 
                                    _default: { costType: 'perContact', value: 6.00, ahtMinutes: 10 },
                                    phone: {
                                        _default: { costType: 'perContact', value: 7.00, ahtMinutes: 12 },
                                        _specialGroups: {
                                            'Tier 1': { costType: 'perContact', value: 5.50, ahtMinutes: 14 }
                                        }
                                    }
                                },
                                'Technical Support': { 
                                    _default: { costType: 'hourly', value: 35.00, ahtMinutes: 10 },
                                    phone: {
                                        _default: { costType: 'hourly', value: 40.00, ahtMinutes: 15 },
                                        _specialGroups: {
                                            'Specialists': { costType: 'hourly', value: 50.00, ahtMinutes: 20 },
                                            'Tier 1': { costType: 'hourly', value: 30.00, ahtMinutes: 12 }
                                        }
                                    },
                                    chat: {
                                        _default: { costType: 'hourly', value: 30.00, ahtMinutes: 8 },
                                        _specialGroups: {
                                            'Specialists': { costType: 'hourly', value: 45.00, ahtMinutes: 12 }
                                        }
                                    }
                                },
                                'Customer Service': { 
                                    _default: { costType: 'perContact', value: 4.50, ahtMinutes: 10 },
                                    phone: {
                                        _default: { costType: 'perContact', value: 5.00, ahtMinutes: 12 },
                                        _specialGroups: {
                                            'Offshore': { costType: 'perContact', value: 2.50, ahtMinutes: 15 },
                                            'Tier 2': { costType: 'hourly', value: 25.00, ahtMinutes: 10 }
                                        }
                                    }
                                }
                            },
                            useCases: parsed.useCases || [],
                            defaultAHT: parsed.defaultAHT || 10,
                            dateRange: parsed.dateRange || {
                                start: new Date().toISOString().slice(0, 7),
                                end: new Date(new Date().setMonth(new Date().getMonth() + 11)).toISOString().slice(0, 7)
                            }
                        };
                    }
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
                
                const currentDate = new Date();
                const defaultStart = currentDate.toISOString().slice(0, 7);
                const defaultEnd = new Date(currentDate.setMonth(currentDate.getMonth() + 11)).toISOString().slice(0, 7);
                
                // Return sensible defaults with example data
                return {
                    channelCosts: ALL_CHANNELS.reduce((acc, ch) => {
                        acc[ch.id] = ch.defaultCost;
                        return acc;
                    }, {}),
                    categoryCosts: {
                        'Pre-Sales': { 
                            _default: { costType: 'perContact', value: 5.00, ahtMinutes: 10 },
                            phone: {
                                _default: { costType: 'perContact', value: 6.00, ahtMinutes: 12 },
                                _specialGroups: {
                                    'Senior Sales': { costType: 'perContact', value: 8.00, ahtMinutes: 10 }
                                }
                            },
                            chat: {
                                _default: { costType: 'perContact', value: 4.50, ahtMinutes: 8 }
                            }
                        },
                        'Order Support': { 
                            _default: { costType: 'perContact', value: 6.00, ahtMinutes: 10 },
                            phone: {
                                _default: { costType: 'perContact', value: 7.00, ahtMinutes: 12 },
                                _specialGroups: {
                                    'Tier 1': { costType: 'perContact', value: 5.50, ahtMinutes: 14 }
                                }
                            }
                        },
                        'Technical Support': { 
                            _default: { costType: 'hourly', value: 35.00, ahtMinutes: 10 },
                            phone: {
                                _default: { costType: 'hourly', value: 40.00, ahtMinutes: 15 },
                                _specialGroups: {
                                    'Specialists': { costType: 'hourly', value: 50.00, ahtMinutes: 20 },
                                    'Tier 1': { costType: 'hourly', value: 30.00, ahtMinutes: 12 }
                                }
                            },
                            chat: {
                                _default: { costType: 'hourly', value: 30.00, ahtMinutes: 8 },
                                _specialGroups: {
                                    'Specialists': { costType: 'hourly', value: 45.00, ahtMinutes: 12 }
                                }
                            }
                        },
                        'Customer Service': { 
                            _default: { costType: 'perContact', value: 4.50, ahtMinutes: 10 },
                            phone: {
                                _default: { costType: 'perContact', value: 5.00, ahtMinutes: 12 },
                                _specialGroups: {
                                    'Offshore': { costType: 'perContact', value: 2.50, ahtMinutes: 15 },
                                    'Tier 2': { costType: 'hourly', value: 25.00, ahtMinutes: 10 }
                                }
                            }
                        }
                    },
                    useCases: [
                        {
                            id: 'uc1',
                            category: 'Pre-Sales',
                            name: 'Answer Bot - General Q&A',
                            channel: 'chat',
                            metric: 'Deflection Rate (%)',
                            baselineValue: 0,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc2',
                            category: 'Pre-Sales',
                            name: 'Product Comparison Bot',
                            channel: 'chat',
                            metric: 'Self-Service Resolution (%)',
                            baselineValue: 10,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc3',
                            category: 'Pre-Sales',
                            name: 'Sales Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 1 Agents',
                            data: {}
                        },
                        {
                            id: 'uc4',
                            category: 'Order Support',
                            name: 'Order Status Automation',
                            channel: 'email',
                            metric: 'Automation Rate (%)',
                            baselineValue: 20,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc5',
                            category: 'Order Support',
                            name: 'Returns Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 2 Agents',
                            data: {}
                        }
                    ],
                    dateRange: {
                        start: defaultStart,
                        end: defaultEnd
                    },
                    defaultAHT: 10
                };
            };

            const initialData = loadFromStorage();
            
            // State management
            const [channelCosts, setChannelCosts] = useState(initialData.channelCosts);
            const [categoryCosts, setCategoryCosts] = useState(initialData.categoryCosts);
            const [useCases, setUseCases] = useState(initialData.useCases);
            const [dateRange, setDateRange] = useState(initialData.dateRange);
            const [months, setMonths] = useState(generateMonthsFromRange(initialData.dateRange.start, initialData.dateRange.end));
            const [activeTab, setActiveTab] = useState('data');
            const [analyticsView, setAnalyticsView] = useState('overall');
            const [analyticsDateRange, setAnalyticsDateRange] = useState({ ...initialData.dateRange });
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [selectedChannel, setSelectedChannel] = useState('all');
            const [selectedSpecialGroup, setSelectedSpecialGroup] = useState(null);
            const [selectedMetric, setSelectedMetric] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showAddUseCase, setShowAddUseCase] = useState(false);
            const [showGuidanceModal, setShowGuidanceModal] = useState(false);
            const [selectedMetricGuide, setSelectedMetricGuide] = useState(null);
            const [lastSaved, setLastSaved] = useState(new Date());
            const [showSaveIndicator, setShowSaveIndicator] = useState(false);
            const [defaultAHT, setDefaultAHT] = useState(initialData.defaultAHT || 10);
            const [agentUtilization, setAgentUtilization] = useState(initialData.agentUtilization || 75); // Default 75% utilization
            
            const fileInputRef = useRef(null);
            const chartRefs = {
                monthly: useRef(null),
                cumulative: useRef(null),
                category: useRef(null),
                channel: useRef(null),
                categoryTrend: useRef(null),
                categoryBreakdown: useRef(null),
                channelTrend: useRef(null),
                channelBreakdown: useRef(null),
                usecaseTrend: useRef(null),
                usecaseBreakdown: useRef(null),
                specialgroupTrend: useRef(null),
                specialgroupBreakdown: useRef(null)
            };
            const chartInstances = useRef({});

            const [newUseCase, setNewUseCase] = useState({
                category: 'Pre-Sales',
                name: '',
                channel: 'phone',
                metric: 'Deflection Rate (%)',
                baselineValue: 0,
                specialGroup: null
            });

            const [newSpecialGroup, setNewSpecialGroup] = useState({
                name: '',
                costType: 'hourly',
                value: 30.00,
                ahtMinutes: defaultAHT
            });

            // Update months when date range changes
            useEffect(() => {
                setMonths(generateMonthsFromRange(dateRange.start, dateRange.end));
            }, [dateRange]);

            // Auto-save functionality
            useEffect(() => {
                const saveTimeout = setTimeout(() => {
                    try {
                        const dataToSave = {
                            channelCosts,
                            categoryCosts,
                            useCases,
                            dateRange,
                            defaultAHT,
                            agentUtilization,
                            savedAt: new Date().toISOString()
                        };
                        localStorage.setItem('aiValueCalculatorData', JSON.stringify(dataToSave));
                        setLastSaved(new Date());
                        setShowSaveIndicator(true);
                        setTimeout(() => setShowSaveIndicator(false), 2000);
                    } catch (error) {
                        console.error('Save error:', error);
                    }
                }, 1000);

                return () => clearTimeout(saveTimeout);
            }, [channelCosts, categoryCosts, useCases, dateRange, defaultAHT, agentUtilization]);

            // Calculate cost based on category-channel hierarchy and special group
            const getEffectiveCost = (useCase, channel) => {
                // Priority: Category-Channel-SpecialGroup > Category-Channel > Category Default > Channel Default
                
                // Get category data
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // 1. Check for special group within category-channel (highest priority)
                    if (useCase.specialGroup && categoryData[channel] && categoryData[channel]._specialGroups && categoryData[channel]._specialGroups[useCase.specialGroup]) {
                        const specialGroupCost = categoryData[channel]._specialGroups[useCase.specialGroup];
                        if (specialGroupCost.costType === 'perContact') {
                            return specialGroupCost.value;
                        }
                        // For hourly, convert to per-contact using special group AHT
                        // Use the special group's AHT if it exists and is valid, otherwise fall back to defaults
                        let aht = specialGroupCost.ahtMinutes;
                        if (!aht || aht <= 0) {
                            // Fall back to channel AHT, then category AHT, then global default
                            const channelData = categoryData[channel];
                            if (channelData && channelData._default && channelData._default.ahtMinutes > 0) {
                                aht = channelData._default.ahtMinutes;
                            } else if (categoryData._default && categoryData._default.ahtMinutes > 0) {
                                aht = categoryData._default.ahtMinutes;
                            } else {
                                aht = defaultAHT;
                            }
                        }
                        // Adjust for agent utilization (e.g., if 75% utilized, true cost is higher)
                        const utilizationFactor = agentUtilization > 0 ? (100 / agentUtilization) : 1;
                        return specialGroupCost.value * aht / 60 * utilizationFactor;
                    }
                    
                    // 2. Category-Channel specific cost
                    if (categoryData[channel] && typeof categoryData[channel] === 'object') {
                        const channelSpecificCost = categoryData[channel]._default || categoryData[channel];
                        if (channelSpecificCost && channelSpecificCost.costType) {
                            if (channelSpecificCost.costType === 'perContact') {
                                return channelSpecificCost.value;
                            }
                            // For hourly, convert to per-contact using channel-specific AHT
                            const aht = channelSpecificCost.ahtMinutes || getApplicableAHT(useCase);
                            const utilizationFactor = agentUtilization > 0 ? (100 / agentUtilization) : 1;
                            return channelSpecificCost.value * aht / 60 * utilizationFactor;
                        }
                    }
                    
                    // 3. Category default (new structure _default or old structure fallback)
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        if (defaultCost.costType === 'perContact') {
                            return defaultCost.value;
                        }
                        // For hourly, convert to per-contact using AHT
                        const aht = defaultCost.ahtMinutes || getApplicableAHT(useCase);
                        const utilizationFactor = agentUtilization > 0 ? (100 / agentUtilization) : 1;
                        return defaultCost.value * aht / 60 * utilizationFactor;
                    }
                }
                
                // 4. Channel default (lowest priority)
                return channelCosts[channel] || 0;
            };
            
            // Get the cost source description for transparency
            const getCostSourceDescription = (useCase, channel) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // Check for special group within category-channel
                    if (useCase.specialGroup && categoryData[channel] && categoryData[channel]._specialGroups && categoryData[channel]._specialGroups[useCase.specialGroup]) {
                        return `Category-Channel-SpecialGroup: ${useCase.category} (${channel}) - ${useCase.specialGroup}`;
                    }
                    
                    // Check for channel-specific cost
                    if (categoryData[channel] && typeof categoryData[channel] === 'object') {
                        return `Category-Channel: ${useCase.category} (${channel})`;
                    }
                    
                    // Category default
                    if (categoryData._default || categoryData.costType) {
                        return `Category Default: ${useCase.category}`;
                    }
                }
                
                return `Channel Default: ${channel}`;
            };

            // Helper to get channel configuration (using top-level ALL_CHANNELS)
            const getChannelConfig = (channelId) => {
                return ALL_CHANNELS.find(ch => ch.id === channelId) || { id: channelId, label: channelId, defaultCost: 0 };
            };
            
            // Helper to ensure all channels exist in channelCosts
            const ensureAllChannelsExist = () => {
                const missingChannels = {};
                ALL_CHANNELS.forEach(channel => {
                    if (!channelCosts.hasOwnProperty(channel.id)) {
                        missingChannels[channel.id] = channel.defaultCost;
                    }
                });
                
                if (Object.keys(missingChannels).length > 0) {
                    setChannelCosts(prev => ({ ...prev, ...missingChannels }));
                    return true; // Channels were added
                }
                return false; // No missing channels
            };
            
            // Get applicable AHT minutes for a use case (SpecialGroup > Category-Channel > Category Default > Global Default)
            const getApplicableAHT = (useCase) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // 1. Special Group AHT (highest priority)
                    if (useCase.specialGroup && categoryData[useCase.channel] && categoryData[useCase.channel]._specialGroups && categoryData[useCase.channel]._specialGroups[useCase.specialGroup]) {
                        const specialGroupData = categoryData[useCase.channel]._specialGroups[useCase.specialGroup];
                        if (specialGroupData && typeof specialGroupData.ahtMinutes === 'number' && specialGroupData.ahtMinutes > 0) {
                            return specialGroupData.ahtMinutes;
                        }
                    }
                    
                    // 2. Category-Channel specific AHT
                    if (categoryData[useCase.channel] && typeof categoryData[useCase.channel] === 'object') {
                        const channelSpecific = categoryData[useCase.channel]._default || categoryData[useCase.channel];
                        if (channelSpecific && typeof channelSpecific.ahtMinutes === 'number' && channelSpecific.ahtMinutes > 0) {
                            return channelSpecific.ahtMinutes;
                        }
                    }
                    
                    // 3. Category default AHT
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && typeof defaultCost.ahtMinutes === 'number' && defaultCost.ahtMinutes > 0) {
                        return defaultCost.ahtMinutes;
                    }
                }
                
                // 4. Global default
                return defaultAHT > 0 ? defaultAHT : 10;
            };
            
            // Helper function to get available special groups for a category-channel combination
            const getAvailableSpecialGroups = (category, channel) => {
                if (!categoryCosts[category] || !categoryCosts[category][channel] || !categoryCosts[category][channel]._specialGroups) {
                    return [];
                }
                return Object.keys(categoryCosts[category][channel]._specialGroups);
            };
            
            // Helper function to get all special groups across all category-channel combinations
            const getAllSpecialGroups = () => {
                const allGroups = new Set();
                Object.values(categoryCosts).forEach(categoryData => {
                    Object.values(categoryData).forEach(channelData => {
                        if (channelData && channelData._specialGroups) {
                            Object.keys(channelData._specialGroups).forEach(group => {
                                allGroups.add(group);
                            });
                        }
                    });
                });
                return Array.from(allGroups);
            };
            
            // Migration function to convert old category structure to new category-channel structure
            const migrateCategoryCosts = () => {
                const newCategoryCosts = {};
                let migrationApplied = false;
                
                Object.entries(categoryCosts).forEach(([category, data]) => {
                    // Check if it's already in new format (has channel keys or _default)
                    if (data._default || Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))) {
                        // Already in new format, keep as is
                        newCategoryCosts[category] = data;
                    } else {
                        // Old format, migrate to new format
                        newCategoryCosts[category] = {
                            _default: {
                                costType: data.costType,
                                value: data.value,
                                ahtMinutes: data.ahtMinutes
                            }
                        };
                        migrationApplied = true;
                    }
                });
                
                if (migrationApplied) {
                    setCategoryCosts(newCategoryCosts);
                    alert(`Migration completed! ${Object.keys(categoryCosts).length} categories converted to new category-channel structure. You can now set different costs per channel for each category.`);
                } else {
                    alert('No migration needed - your data is already in the new category-channel format.');
                }
            };
            
            // Check if migration is needed
            const needsMigration = () => {
                return Object.values(categoryCosts).some(data => 
                    data.costType && !data._default && !Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))
                );
            };
            
            // Helper function to get all available channels (from single source of truth)
            const getUniqueChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };
            
            // Helper function to add a new channel-specific cost for a category
            const addChannelCostToCategory = (category, channel, costData) => {
                setCategoryCosts(prev => ({
                    ...prev,
                    [category]: {
                        ...prev[category],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a category
            const removeChannelCostFromCategory = (category, channel) => {
                setCategoryCosts(prev => {
                    const newCategoryData = { ...prev[category] };
                    delete newCategoryData[channel];
                    return {
                        ...prev,
                        [category]: newCategoryData
                    };
                });
            };
            
            // Helper function to add a new channel-specific cost for a special group
            const addChannelCostToSpecialGroup = (group, channel, costData) => {
                setSpecialGroups(prev => ({
                    ...prev,
                    [group]: {
                        ...prev[group],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a special group
            const removeChannelCostFromSpecialGroup = (group, channel) => {
                setSpecialGroups(prev => {
                    const newGroupData = { ...prev[group] };
                    delete newGroupData[channel];
                    return {
                        ...prev,
                        [group]: newGroupData
                    };
                });
            };
            

            // Calculate savings with proper formulas
            const calculateSavings = (useCase, monthId) => {
                const monthData = useCase.data[monthId] || {};
                const volume = parseFloat(monthData.volume) || 0;
                const improvement = parseFloat(monthData.improvement) || 0;
                const baseline = parseFloat(useCase.baselineValue) || 0;
                
                // Calculate net improvement (improvement - baseline)
                let netImprovement = Math.max(0, improvement - baseline);
                
                // Get the effective cost (already converted to per-contact)
                let effectiveCost = getEffectiveCost(useCase, useCase.channel);
                const aht = Math.max(0.01, parseFloat(getApplicableAHT(useCase)) || 10); // minutes per contact
                
                // Different calculation based on metric type
                if (useCase.metric.includes('AHT Reduction')) {
                    // For AHT Reduction, compute cost per minute
                    // effectiveCost is already per-contact, so divide by AHT to get per-minute
                    const costPerMinute = effectiveCost / aht;
                    // Cap minutes saved to not exceed AHT
                    const cappedMinutes = Math.min(netImprovement, aht);
                    return volume * cappedMinutes * costPerMinute;
                } else if (useCase.metric.includes('Deflection') || useCase.metric.includes('Automation')) {
                    // For deflection/automation, use per-contact cost (already converted)
                    // Clamp percent between 0-100
                    const pct = Math.max(0, Math.min(100, netImprovement));
                    return volume * (pct / 100) * effectiveCost;
                } else if (useCase.metric.includes('Resolution') || useCase.metric.includes('Transfer')) {
                    // For resolution/transfer, use per-contact cost (already converted)
                    // Clamp percent between 0-100
                    const pct = Math.max(0, Math.min(100, netImprovement));
                    return volume * (pct / 100) * effectiveCost
                }
                return 0;
            };

            const calculateTotalSavings = () => {
                let total = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    filteredMonths.forEach(month => {
                        total += calculateSavings(uc, month.id);
                    });
                });
                return total;
            };

            // Get filtered months for analytics
            const getFilteredMonths = () => {
                if (activeTab === 'analytics' && analyticsDateRange) {
                    return generateMonthsFromRange(analyticsDateRange.start, analyticsDateRange.end);
                }
                return months;
            };

            // Get filtered use cases based on current view
            const getFilteredUseCases = () => {
                let filtered = useCases;
                
                // Category filter
                if (selectedCategory !== 'all') {
                    filtered = filtered.filter(uc => uc.category === selectedCategory);
                }
                
                // Channel filter
                if (selectedChannel !== 'all') {
                    filtered = filtered.filter(uc => uc.channel === selectedChannel);
                }
                
                // Special Group filter
                if (selectedSpecialGroup !== null) {
                    if (selectedSpecialGroup === 'none') {
                        filtered = filtered.filter(uc => !uc.specialGroup);
                    } else {
                        filtered = filtered.filter(uc => uc.specialGroup === selectedSpecialGroup);
                    }
                }
                
                // Metric filter
                if (selectedMetric !== null) {
                    filtered = filtered.filter(uc => uc.metric === selectedMetric);
                }
                
                return filtered;
            };

            // Get unique categories
            const getCategories = () => {
                const categories = new Set(useCases.map(uc => uc.category));
                return Array.from(categories);
            };

            // Get unique channels for analytics (all channels always available)
            const getChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };

            // Chart data preparation
            const getMonthlyTrendData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(monthTotal)
                    };
                });
            };

            const getCumulativeData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                let cumulative = 0;
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    cumulative += monthTotal;
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(cumulative)
                    };
                });
            };

            const getCategoryBreakdown = () => {
                const categories = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!categories[uc.category]) {
                        categories[uc.category] = 0;
                    }
                    filteredMonths.forEach(month => {
                        categories[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(categories).map(([name, value]) => ({
                    label: name,
                    value: Math.round(value)
                }));
            };

            const getChannelBreakdown = () => {
                const channels = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!channels[uc.channel]) {
                        channels[uc.channel] = 0;
                    }
                    filteredMonths.forEach(month => {
                        channels[uc.channel] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(channels).map(([name, value]) => ({
                    label: name.charAt(0).toUpperCase() + name.slice(1),
                    value: Math.round(value)
                }));
            };

            // Get data for specific analytics views
            const getCategoryTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const categories = [...new Set(useCases.map(uc => uc.category))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: categories.map((cat, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.category === cat).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];
                        return {
                            label: cat,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getChannelTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const channels = [...new Set(useCases.map(uc => uc.channel))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: channels.map((ch, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.channel === ch).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444'];
                        return {
                            label: ch.charAt(0).toUpperCase() + ch.slice(1),
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getUseCaseTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const topUseCases = useCases
                    .map(uc => ({
                        ...uc,
                        total: filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0)
                    }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 5); // Top 5 use cases
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: topUseCases.map((uc, index) => {
                        const data = filteredMonths.map(month => calculateSavings(uc, month.id));
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        return {
                            label: uc.name,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getSpecialGroupTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const groups = [...new Set(useCases.map(uc => uc.specialGroup).filter(Boolean))];
                groups.push('No Special Group');
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: groups.map((group, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => (uc.specialGroup || 'No Special Group') === group).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        return {
                            label: group,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            // Initialize charts
            useEffect(() => {
                if (activeTab === 'analytics' && window.Chart) {
                    // Destroy existing charts
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                    chartInstances.current = {};

                    if (analyticsView === 'overall') {
                        // Monthly Trend Chart
                        if (chartRefs.monthly.current) {
                            const monthlyData = getMonthlyTrendData();
                            const ctx = chartRefs.monthly.current.getContext('2d');
                            chartInstances.current.monthly = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: monthlyData.map(d => d.label),
                                    datasets: [{
                                        label: 'Monthly Savings',
                                        data: monthlyData.map(d => d.value),
                                        borderColor: '#3B82F6',
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Cumulative Chart
                        if (chartRefs.cumulative.current) {
                            const cumulativeData = getCumulativeData();
                            const ctx = chartRefs.cumulative.current.getContext('2d');
                            chartInstances.current.cumulative = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: cumulativeData.map(d => d.label),
                                    datasets: [{
                                        label: 'Cumulative Savings',
                                        data: cumulativeData.map(d => d.value),
                                        borderColor: '#10B981',
                                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Total: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Pie Chart
                        if (chartRefs.category.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.category.current.getContext('2d');
                                chartInstances.current.category = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: [
                                                '#3B82F6',
                                                '#10B981',
                                                '#F59E0B',
                                                '#EF4444',
                                                '#8B5CF6'
                                            ]
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Channel Bar Chart
                        if (chartRefs.channel.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channel.current.getContext('2d');
                                chartInstances.current.channel = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: '#8B5CF6'
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'category') {
                        // Category Trend Chart
                        if (chartRefs.categoryTrend.current) {
                            const trendData = getCategoryTrendData();
                            const ctx = chartRefs.categoryTrend.current.getContext('2d');
                            chartInstances.current.categoryTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Breakdown Chart
                        if (chartRefs.categoryBreakdown.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.categoryBreakdown.current.getContext('2d');
                                chartInstances.current.categoryBreakdown = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'channel') {
                        // Channel Trend Chart
                        if (chartRefs.channelTrend.current) {
                            const trendData = getChannelTrendData();
                            const ctx = chartRefs.channelTrend.current.getContext('2d');
                            chartInstances.current.channelTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Channel Breakdown Chart
                        if (chartRefs.channelBreakdown.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channelBreakdown.current.getContext('2d');
                                chartInstances.current.channelBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'usecase') {
                        // Use Case Trend Chart (Top 5)
                        if (chartRefs.usecaseTrend.current) {
                            const trendData = getUseCaseTrendData();
                            const ctx = chartRefs.usecaseTrend.current.getContext('2d');
                            chartInstances.current.usecaseTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Use Case Performance Bar Chart
                        if (chartRefs.usecaseBreakdown.current) {
                            const filteredMonths = getFilteredMonths();
                            const useCaseData = useCases.map(uc => {
                                const total = filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0);
                                return { name: uc.name, value: total };
                            }).sort((a, b) => b.value - a.value).slice(0, 10);

                            if (useCaseData.length > 0) {
                                const ctx = chartRefs.usecaseBreakdown.current.getContext('2d');
                                chartInstances.current.usecaseBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: useCaseData.map(d => d.name),
                                        datasets: [{
                                            label: 'Use Case Savings',
                                            data: useCaseData.map(d => d.value),
                                            backgroundColor: '#3B82F6'
                                        }]
                                    },
                                    options: {
                                        indexAxis: 'y',
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            x: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.x.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'specialgroup') {
                        // Special Group Trend Chart
                        if (chartRefs.specialgroupTrend.current) {
                            const trendData = getSpecialGroupTrendData();
                            const ctx = chartRefs.specialgroupTrend.current.getContext('2d');
                            chartInstances.current.specialgroupTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Special Group Breakdown Chart
                        if (chartRefs.specialgroupBreakdown.current) {
                            const groupData = {};
                            const filteredMonths = getFilteredMonths();
                            getAllSpecialGroups().forEach(group => {
                                groupData[group] = 0;
                            });
                            groupData['No Special Group'] = 0;

                            useCases.forEach(uc => {
                                const key = uc.specialGroup || 'No Special Group';
                                filteredMonths.forEach(month => {
                                    groupData[key] += calculateSavings(uc, month.id);
                                });
                            });

                            const chartData = Object.entries(groupData)
                                .filter(([, value]) => value > 0)
                                .map(([name, value]) => ({ label: name, value }));

                            if (chartData.length > 0) {
                                const ctx = chartRefs.specialgroupBreakdown.current.getContext('2d');
                                chartInstances.current.specialgroupBreakdown = new Chart(ctx, {
                                    type: 'pie',
                                    data: {
                                        labels: chartData.map(d => d.label),
                                        datasets: [{
                                            data: chartData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                return () => {
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [activeTab, analyticsView, useCases, months, channelCosts, categoryCosts, selectedCategory, selectedChannel, selectedSpecialGroup, selectedMetric, analyticsDateRange]);
            
            // Ensure all channels exist in channelCosts (for users with existing data)
            useEffect(() => {
                if (ensureAllChannelsExist()) {
                    console.log('Added missing channels to channelCosts configuration');
                }
            }, [channelCosts]); // Only run when channelCosts changes

            // CRUD Operations
            const addUseCase = () => {
                if (newUseCase.name) {
                    setUseCases([...useCases, {
                        id: `uc${Date.now()}`,
                        ...newUseCase,
                        data: {}
                    }]);
                    setNewUseCase({
                        category: 'Pre-Sales',
                        name: '',
                        channel: 'phone',
                        metric: 'Deflection Rate (%)',
                        baselineValue: 0,
                        specialGroup: null
                    });
                    setShowAddUseCase(false);
                }
            };

            const removeUseCase = (id) => {
                setUseCases(useCases.filter(uc => uc.id !== id));
            };

            const updateUseCaseData = (useCaseId, monthId, field, value) => {
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        return {
                            ...uc,
                            data: {
                                ...uc.data,
                                [monthId]: {
                                    ...uc.data[monthId],
                                    [field]: value
                                }
                            }
                        };
                    }
                    return uc;
                }));
            };

            // Special group functions are now handled within the category-channel structure
            // Functions removed as they're no longer needed with nested structure

            // Import/Export functionality
            const exportToCSV = () => {
                let csv = '=== AI ROI CALCULATOR FULL EXPORT ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${dateRange.start} to ${dateRange.end}\n`;
                csv += `Total Months: ${months.length}\n`;
                csv += `Total Use Cases: ${useCases.length}\n`;
                
                // Add filter information if on analytics tab
                if (activeTab === 'analytics') {
                    csv += `\n=== CURRENT ANALYTICS FILTERS ===\n`;
                    csv += `View: ${analyticsView}\n`;
                    csv += `Analytics Period: ${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                    csv += `Category Filter: ${selectedCategory}\n`;
                    csv += `Channel Filter: ${selectedChannel}\n`;
                    csv += `Special Group Filter: ${selectedSpecialGroup || 'all'}\n`;
                    csv += `Metric Filter: ${selectedMetric || 'all'}\n`;
                    csv += `Filtered Results: ${getFilteredUseCases().length} of ${useCases.length} use cases\n`;
                }
                csv += '\n';
                
                // SECTION 1: DETAILED USE CASE DATA
                csv += '=== SECTION 1: USE CASE SAVINGS CALCULATIONS ===\n';
                csv += 'Category,Use Case,Channel,Metric,Special Group,Baseline,Effective Cost,Cost Type,AHT Used (min)';
                
                months.forEach(month => {
                    csv += `,${month.year}-${month.month} Volume,${month.year}-${month.month} Improvement,${month.year}-${month.month} Net Improvement,${month.year}-${month.month} Savings`;
                });
                csv += ',Total Savings\n';
                
                useCases.forEach(uc => {
                    // Determine effective cost and type
                    let effectiveCost = getEffectiveCost(uc, uc.channel);
                    let costSource = 'Channel Default';
                    let costType = 'Per Contact';
                    
                    costSource = getCostSourceDescription(uc, uc.channel);
                    if (uc.specialGroup && categoryCosts[uc.category] && categoryCosts[uc.category][uc.channel] && categoryCosts[uc.category][uc.channel]._specialGroups && categoryCosts[uc.category][uc.channel]._specialGroups[uc.specialGroup]) {
                        costType = categoryCosts[uc.category][uc.channel]._specialGroups[uc.specialGroup].costType === 'hourly' ? 'Hourly' : 'Per Contact';
                    } else if (categoryCosts[uc.category]) {
                        const categoryData = categoryCosts[uc.category];
                        const channelSpecific = categoryData[uc.channel];
                        const defaultCost = categoryData._default || categoryData;
                        const activeCost = channelSpecific || defaultCost;
                        costType = activeCost && activeCost.costType === 'hourly' ? 'Hourly' : 'Per Contact';
                    }
                    
                    const ahtUsed = getApplicableAHT(uc);
                    csv += `${uc.category},${uc.name},${uc.channel},${uc.metric},${uc.specialGroup || 'None'},${uc.baselineValue},${effectiveCost},${costType},${ahtUsed}`;
                    
                    let totalSavings = 0;
                    
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        const improvement = monthData.improvement || 0;
                        const netImprovement = Math.max(0, improvement - uc.baselineValue);
                        const savings = calculateSavings(uc, month.id);
                        totalSavings += savings;
                        csv += `,${monthData.volume || 0},${improvement},${netImprovement},${savings.toFixed(2)}`;
                    });
                    csv += `,${totalSavings.toFixed(2)}\n`;
                });
                
                // SECTION 2: INPUT PARAMETERS
                csv += '\n\n=== SECTION 2: ALL INPUT PARAMETERS ===\n';
                csv += 'Use Case,Month,Metric,Unit,Volume (contacts),Improvement Input,Baseline,Net Improvement Used\n';
                
                useCases.forEach(uc => {
                    const unit = uc.metric.includes('AHT Reduction') ? 'minutes' : '%';
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        const improvement = monthData.improvement || 0;
                        const netImprovement = Math.max(0, improvement - uc.baselineValue);
                        csv += `${uc.name},${month.month} ${month.year},${uc.metric},${unit},${monthData.volume || 0},${improvement},${uc.baselineValue},${netImprovement}\n`;
                    });
                });
                
                // SECTION 3: COST SETTINGS
                csv += '\n\n=== SECTION 3: COST CONFIGURATION ===\n';
                csv += 'Cost Tier,Type,Name,Cost Type,Value,AHT (min),Priority\n';
                
                // Channel costs (Priority 3)
                Object.entries(channelCosts).forEach(([channel, cost]) => {
                    csv += `Channel Default,Channel,${channel},Per Contact,${cost},${defaultAHT},Priority 3 (Lowest)\n`;
                });
                
                // Category costs (Priority 3)
                Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                    // Category default
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        const aht = typeof defaultCost.ahtMinutes === 'number' ? defaultCost.ahtMinutes : defaultAHT;
                        csv += `Category Default,Category,${category},${defaultCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${defaultCost.value},${aht},Priority 3\n`;
                    }
                    
                    // Category-Channel costs (Priority 2)
                    Object.entries(categoryData).forEach(([channel, channelData]) => {
                        if (channel !== '_default' && channelData && channelData._default) {
                            const channelCost = channelData._default;
                            const aht = typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : defaultAHT;
                            csv += `Category-Channel,Category-Channel,"${category} (${channel})",${channelCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${channelCost.value},${aht},Priority 2\n`;
                            
                            // Special groups within category-channel (Priority 1)
                            if (channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = typeof groupData.ahtMinutes === 'number' ? groupData.ahtMinutes : defaultAHT;
                                    csv += `Special Group,Category-Channel-SpecialGroup,"${category} (${channel}) - ${group}",${groupData.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${groupData.value},${aht},Priority 1 (Highest)\n`;
                                });
                            }
                        }
                    });
                });
                
                // SECTION 4: CALCULATION FORMULAS
                csv += '\n\n=== SECTION 4: CALCULATION FORMULAS USED ===\n';
                csv += 'Metric Type,Formula,Example\n';
                csv += 'Note,Effective Cost/Contact = (Hourly × AHT/60) if Hourly; otherwise PerContact,Example: $30 × (8/60) = $4.00 per contact when AHT = 8\n';
                csv += 'Note,Cost/Minute = (Hourly/60) if Hourly; otherwise (PerContact/AHT),Example: $2.50 / 8 = $0.3125 per minute when AHT = 8\n';
                csv += 'Deflection Rate (%),Volume × (Improvement% - Baseline%) × Cost per Contact,"1000 × (70% - 10%) × $2.50 = $1,500"\n';
                csv += 'AHT Reduction (min),Volume × (Minutes - Baseline) / 60 × Hourly Rate,"500 × (3 - 0.5) / 60 × $30 = $625"\n';
                csv += 'Automation Rate (%),Volume × (Improvement% - Baseline%) × Cost per Contact,"2000 × (60% - 20%) × $4 = $3,200"\n';
                csv += 'Self-Service Resolution (%),Volume × (Improvement% - Baseline%) × Cost per Contact,"1500 × (50% - 15%) × $3 = $1,575"\n';
                csv += 'Transfer Rate Reduction (%),Volume × (Reduction% - Baseline%) × Cost per Contact,"3000 × (40% - 30%) × $6 = $1,800"\n';
                
                // Additional AHT example using per-contact pricing
                csv += 'AHT Reduction (min) [Per-Contact Example],Volume × (Minutes - Baseline) × (PerContact/AHT),"500 × (3 - 0.5) × ($2.50/8) = $390.63"\n';

                // SECTION 5: MONTHLY SUMMARY
                csv += '\n\n=== SECTION 5: MONTHLY SAVINGS SUMMARY ===\n';
                csv += 'Month,Total Volume,Total Savings,Cumulative Savings\n';
                
                let cumulative = 0;
                months.forEach(month => {
                    let monthVolume = 0;
                    let monthSavings = 0;
                    useCases.forEach(uc => {
                        const monthData = uc.data[month.id] || {};
                        monthVolume += parseFloat(monthData.volume) || 0;
                        monthSavings += calculateSavings(uc, month.id);
                    });
                    cumulative += monthSavings;
                    csv += `${month.month} ${month.year},${monthVolume},${monthSavings.toFixed(2)},${cumulative.toFixed(2)}\n`;
                });
                
                // SECTION 6: CATEGORY BREAKDOWN
                csv += '\n\n=== SECTION 6: SAVINGS BY CATEGORY ===\n';
                csv += 'Category,Total Volume,Total Savings,% of Total\n';
                
                const categoryTotals = {};
                const categoryVolumes = {};
                useCases.forEach(uc => {
                    if (!categoryTotals[uc.category]) {
                        categoryTotals[uc.category] = 0;
                        categoryVolumes[uc.category] = 0;
                    }
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        categoryVolumes[uc.category] += parseFloat(monthData.volume) || 0;
                        categoryTotals[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                
                const totalSavingsAll = calculateTotalSavings();
                Object.entries(categoryTotals).forEach(([category, savings]) => {
                    const percentage = totalSavingsAll > 0 ? (savings / totalSavingsAll * 100).toFixed(1) : 0;
                    csv += `${category},${categoryVolumes[category]},${savings.toFixed(2)},${percentage}%\n`;
                });
                
                // SECTION 7: CHANNEL BREAKDOWN
                csv += '\n\n=== SECTION 7: SAVINGS BY CHANNEL ===\n';
                csv += 'Channel,Total Volume,Total Savings,Default Cost,% of Total\n';
                
                const channelTotals = {};
                const channelVolumes = {};
                useCases.forEach(uc => {
                    if (!channelTotals[uc.channel]) {
                        channelTotals[uc.channel] = 0;
                        channelVolumes[uc.channel] = 0;
                    }
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        channelVolumes[uc.channel] += parseFloat(monthData.volume) || 0;
                        channelTotals[uc.channel] += calculateSavings(uc, month.id);
                    });
                });
                
                Object.entries(channelTotals).forEach(([channel, savings]) => {
                    const percentage = totalSavingsAll > 0 ? (savings / totalSavingsAll * 100).toFixed(1) : 0;
                    csv += `${channel},${channelVolumes[channel]},${savings.toFixed(2)},${channelCosts[channel]},${percentage}%\n`;
                });
                
                // SECTION 8: EXECUTIVE SUMMARY
                csv += '\n\n=== SECTION 8: EXECUTIVE SUMMARY ===\n';
                csv += 'Metric,Value\n';
                csv += `Total Projected Savings,$${calculateTotalSavings().toFixed(2)}\n`;
                csv += `Average Monthly Savings,$${(calculateTotalSavings() / months.length).toFixed(2)}\n`;
                csv += `Total Use Cases,${useCases.length}\n`;
                csv += `Analysis Period,"${dateRange.start} to ${dateRange.end}"\n`;
                csv += `Number of Months,${months.length}\n`;
                csv += `Total Volume Processed,${Object.values(channelVolumes).reduce((a, b) => a + b, 0)}\n`;
                csv += `Average Cost per Contact Saved,$${totalSavingsAll > 0 ? (totalSavingsAll / Object.values(channelVolumes).reduce((a, b) => a + b, 0) || 1).toFixed(2) : 0}\n`;

                // SECTION 9: SAVINGS BY USE CASE (COMPACT)
                csv += '\n\n=== SECTION 9: SAVINGS BY USE CASE ===\n';
                csv += 'Category,Use Case,Channel,Metric,Cost Type,AHT Used (min),Total Savings,Average Monthly Savings\n';
                useCases.forEach(uc => {
                    // Determine cost type using the new nested structure
                    let costType = 'Per Contact';
                    if (categoryCosts[uc.category]) {
                        const categoryData = categoryCosts[uc.category];
                        
                        // Check special group first
                        if (uc.specialGroup && categoryData[uc.channel] && categoryData[uc.channel]._specialGroups && categoryData[uc.channel]._specialGroups[uc.specialGroup]) {
                            costType = categoryData[uc.channel]._specialGroups[uc.specialGroup].costType === 'hourly' ? 'Hourly' : 'Per Contact';
                        } 
                        // Then category-channel
                        else if (categoryData[uc.channel] && categoryData[uc.channel]._default) {
                            costType = categoryData[uc.channel]._default.costType === 'hourly' ? 'Hourly' : 'Per Contact';
                        } 
                        // Then category default
                        else {
                            const defaultCost = categoryData._default || categoryData;
                            if (defaultCost.costType) {
                                costType = defaultCost.costType === 'hourly' ? 'Hourly' : 'Per Contact';
                            }
                        }
                    }
                    const ahtUsed = getApplicableAHT(uc);
                    let total = 0;
                    months.forEach(month => { total += calculateSavings(uc, month.id); });
                    const avg = months.length > 0 ? (total / months.length) : 0;
                    csv += `${uc.category},${uc.name},${uc.channel},${uc.metric},${costType},${ahtUsed},${total.toFixed(2)},${avg.toFixed(2)}\n`;
                });

                // SECTION 10: MONTHLY SAVINGS BY USE CASE MATRIX
                csv += '\n\n=== SECTION 10: MONTHLY SAVINGS BY USE CASE ===\n';
                csv += 'Use Case,Category,Channel,Metric';
                months.forEach(month => {
                    csv += `,${month.year}-${month.month} Savings`;
                });
                csv += ',Total\n';
                
                useCases.forEach(uc => {
                    let total = 0;
                    let row = `${uc.name},${uc.category},${uc.channel},${uc.metric}`;
                    months.forEach(month => {
                        const s = calculateSavings(uc, month.id);
                        total += s;
                        row += `,${s.toFixed(2)}`;
                    });
                    row += `,${total.toFixed(2)}\n`;
                    csv += row;
                });
                
                // Add a totals row across all use cases per month
                let totalsRow = 'TOTAL,,,';
                let grandTotal = 0;
                months.forEach(month => {
                    let mTotal = 0;
                    useCases.forEach(uc => { mTotal += calculateSavings(uc, month.id); });
                    grandTotal += mTotal;
                    totalsRow += `${mTotal.toFixed(2)},`;
                });
                // Replace trailing comma with comma + grand total
                totalsRow = totalsRow.replace(/,$/, `,${grandTotal.toFixed(2)}\n`);
                csv += totalsRow;

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_analysis_complete_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            // Export current analytics view to CSV
            const exportAnalyticsCSV = () => {
                let csv = `=== ANALYTICS EXPORT (${analyticsView.toUpperCase()}) ===\n`;
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                csv += `Months: ${getFilteredMonths().length}\n`;
                
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                csv += `Filtered Use Cases: ${filteredUseCases.length} of ${useCases.length}\n`;
                csv += `Category Filter: ${selectedCategory}\n`;
                csv += `Channel Filter: ${selectedChannel}\n`;
                csv += `Special Group Filter: ${selectedSpecialGroup || 'all'}\n`;
                csv += `Metric Filter: ${selectedMetric || 'all'}\n\n`;
                
                // Add active filters summary
                let activeFilters = [];
                if (selectedCategory !== 'all') activeFilters.push(`Category: ${selectedCategory}`);
                if (selectedChannel !== 'all') activeFilters.push(`Channel: ${selectedChannel}`);
                if (selectedSpecialGroup) activeFilters.push(`Special Group: ${selectedSpecialGroup === 'none' ? 'No Special Group' : selectedSpecialGroup}`);
                if (selectedMetric) activeFilters.push(`Metric: ${selectedMetric}`);
                
                if (activeFilters.length > 0) {
                    csv += `Active Filters Applied: ${activeFilters.join(', ')}\n`;
                } else {
                    csv += `Active Filters Applied: None (showing all data)\n`;
                }
                csv += '\n';

                if (analyticsView === 'overall') {
                    // Monthly trend data
                    csv += '=== MONTHLY TREND DATA ===\n';
                    csv += 'Note: All savings in USD\n';
                    csv += 'Formula: Savings = Volume × (Improvement - Baseline) × Effective Cost per Contact\n';
                    csv += 'Month,Monthly Savings ($),Cumulative Savings ($)\n';
                    const monthly = getMonthlyTrendData();
                    const cumulative = getCumulativeData();
                    monthly.forEach((d, i) => {
                        csv += `${d.label},${d.value},${cumulative[i]?.value || 0}\n`;
                    });
                    
                    csv += '\n=== BREAKDOWN BY CATEGORY ===\n';
                    csv += 'Category,Total Savings ($),Percentage of Total\n';
                    const byCategory = getCategoryBreakdown();
                    const totalCat = byCategory.reduce((s, c) => s + c.value, 0);
                    byCategory.forEach(d => {
                        const pct = totalCat > 0 ? ((d.value / totalCat) * 100).toFixed(1) : 0;
                        csv += `${d.label},${d.value},${pct}%\n`;
                    });
                    
                    // Add calculation formulas section
                    csv += '\n\n=== CALCULATION FORMULAS USED ===\n';
                    csv += 'Metric Type,Formula,Notes\n';
                    csv += 'Deflection Rate (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Prevents contacts from reaching agents"\n';
                    csv += 'AHT Reduction (min),"Volume × (Minutes - Baseline) × (Cost/AHT)","For hourly rates: × (Rate/60); for per-contact: × (Rate/AHT)"\n';
                    csv += 'Automation Rate (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Fully automated interactions"\n';
                    csv += 'Self-Service Resolution (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Resolved without agent involvement"\n';
                    csv += 'Transfer Rate Reduction (%),"Volume × (Reduction% - Baseline%) × Cost/Contact","Reduced agent-to-agent transfers"\n';
                    
                    csv += '\n=== BREAKDOWN BY CHANNEL ===\n';
                    csv += 'Channel,Total Savings ($),Percentage of Total\n';
                    const byChannel = getChannelBreakdown();
                    const totalCh = byChannel.reduce((s, c) => s + c.value, 0);
                    byChannel.forEach(d => {
                        const pct = totalCh > 0 ? ((d.value / totalCh) * 100).toFixed(1) : 0;
                        csv += `${d.label},${d.value},${pct}%\n`;
                    });
                    
                } else if (analyticsView === 'category') {
                    csv += '=== CATEGORY PERFORMANCE ANALYSIS ===\n';
                    csv += 'Note: Costs determined by hierarchy - Special Groups > Category Overrides > Channel Defaults\n';
                    csv += 'Category,Use Cases (count),Total Volume (contacts),Total Savings ($),Avg Savings per Contact ($/contact),% of Total Savings,Use Case Names\n';
                    const categoryStats = {};
                    filteredUseCases.forEach(uc => {
                        if (!categoryStats[uc.category]) {
                            categoryStats[uc.category] = { useCases: [], volume: 0, savings: 0 };
                        }
                        categoryStats[uc.category].useCases.push(uc.name);
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            categoryStats[uc.category].volume += parseFloat(md.volume) || 0;
                            categoryStats[uc.category].savings += calculateSavings(uc, month.id);
                        });
                    });
                    const totalSavingsAll = Object.values(categoryStats).reduce((s, v) => s + v.savings, 0);
                    Object.entries(categoryStats).forEach(([cat, stats]) => {
                        const pct = totalSavingsAll > 0 ? (stats.savings / totalSavingsAll * 100).toFixed(1) : 0;
                        const avg = stats.volume > 0 ? (stats.savings / stats.volume).toFixed(2) : '0.00';
                        const useCaseNames = stats.useCases.join('; ');
                        csv += `${cat},${stats.useCases.length},${Math.round(stats.volume)},${Math.round(stats.savings)},${avg},${pct}%,"${useCaseNames}"\n`;
                    });
                    
                    csv += '\n=== ENHANCED COST HIERARCHY EXPLANATION ===\n';
                    csv += 'Priority Level,Source,Description,Example\n';
                    csv += '1 (Highest),Special Group,"Override all other costs for specific agent groups","Tier 1 Agents: $25/hr"\n';
                    csv += '2 (High),Category-Channel,"Category-specific cost for specific channel","Pre-Sales Phone: $35/hr"\n';
                    csv += '3 (Medium),Category Default,"Category fallback cost for unspecified channels","Pre-Sales: $30/hr (default)"\n';
                    csv += '4 (Lowest),Channel Default,"Base costs per communication channel","Phone: $6/contact"\n';
                    
                } else if (analyticsView === 'channel') {
                    csv += '=== CHANNEL PERFORMANCE ANALYSIS ===\n';
                    csv += 'Note: Default costs can be overridden by category or special group settings\n';
                    csv += 'Channel,Use Cases (count),Total Volume (contacts),Total Savings ($),Default Cost ($/contact),Avg Improvement (% or min),% of Total Savings,Use Case Names\n';
                    const channelStats = {};
                    filteredUseCases.forEach(uc => {
                        if (!channelStats[uc.channel]) {
                            channelStats[uc.channel] = { useCases: [], volume: 0, savings: 0, improvements: [] };
                        }
                        channelStats[uc.channel].useCases.push(uc.name);
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            channelStats[uc.channel].volume += parseFloat(md.volume) || 0;
                            channelStats[uc.channel].savings += calculateSavings(uc, month.id);
                            if (md.improvement != null && !isNaN(parseFloat(md.improvement))) {
                                channelStats[uc.channel].improvements.push(parseFloat(md.improvement));
                            }
                        });
                    });
                    const totalSavingsAll = Object.values(channelStats).reduce((s, v) => s + v.savings, 0);
                    Object.entries(channelStats).forEach(([ch, stats]) => {
                        const avgImp = stats.improvements.length ? (stats.improvements.reduce((a,b)=>a+b,0)/stats.improvements.length).toFixed(1) : '0.0';
                        const pct = totalSavingsAll > 0 ? (stats.savings / totalSavingsAll * 100).toFixed(1) : 0;
                        const useCaseNames = stats.useCases.join('; ');
                        csv += `${ch},${stats.useCases.length},${Math.round(stats.volume)},${Math.round(stats.savings)},${channelCosts[ch] || 0},${avgImp}%,${pct}%,"${useCaseNames}"\n`;
                    });
                    
                    csv += '\n=== COST OVERRIDE INFORMATION ===\n';
                    csv += 'Channel,Default Cost ($/contact),Category Overrides,Special Group Overrides\n';
                    Object.keys(channelCosts).forEach(ch => {
                        const categoryOverrides = Object.keys(categoryCosts).filter(cat => 
                            filteredUseCases.some(uc => uc.channel === ch && uc.category === cat)).join('; ') || 'None';
                        const specialOverrides = getAllSpecialGroups().filter(sg => 
                            filteredUseCases.some(uc => uc.channel === ch && uc.specialGroup === sg)).join('; ') || 'None';
                        csv += `${ch},${channelCosts[ch]},"${categoryOverrides}","${specialOverrides}"\n`;
                    });
                    
                } else if (analyticsView === 'usecase') {
                    csv += '=== INDIVIDUAL USE CASE ANALYSIS ===\n';
                    csv += 'Note: Improvements are net of baseline values. AHT metrics converted to cost savings.\n\n';
                    
                    // Add monthly trends for each use case
                    csv += '=== MONTHLY SAVINGS TRENDS BY USE CASE ===\n';
                    csv += 'Month';
                    filteredUseCases.forEach(uc => {
                        csv += `,${uc.name} ($)`;
                    });
                    csv += ',Total ($)\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotal = 0;
                        
                        filteredUseCases.forEach(uc => {
                            const savings = calculateSavings(uc, month.id);
                            csv += `,${savings.toFixed(2)}`;
                            monthTotal += savings;
                        });
                        
                        csv += `,${monthTotal.toFixed(2)}\n`;
                    });
                    
                    csv += '\n=== MONTHLY VOLUME TRENDS BY USE CASE ===\n';
                    csv += 'Month';
                    filteredUseCases.forEach(uc => {
                        csv += `,${uc.name} (contacts)`;
                    });
                    csv += ',Total Contacts\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotalVolume = 0;
                        
                        filteredUseCases.forEach(uc => {
                            const md = uc.data[month.id] || {};
                            const volume = parseFloat(md.volume) || 0;
                            csv += `,${volume}`;
                            monthTotalVolume += volume;
                        });
                        
                        csv += `,${monthTotalVolume}\n`;
                    });
                    
                    csv += '\n=== MONTHLY IMPROVEMENT TRENDS BY USE CASE ===\n';
                    csv += 'Month';
                    filteredUseCases.forEach(uc => {
                        const unit = uc.metric.includes('min') ? '(min)' : '(%)';
                        csv += `,${uc.name} ${unit}`;
                    });
                    csv += '\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        
                        filteredUseCases.forEach(uc => {
                            const md = uc.data[month.id] || {};
                            const improvement = parseFloat(md.improvement) || 0;
                            csv += `,${improvement.toFixed(1)}`;
                        });
                        
                        csv += '\n';
                    });
                    
                    csv += '\n=== USE CASE PERFORMANCE SUMMARY ===\n';
                    csv += 'Use Case,Category,Channel,Metric,Special Group,Total Volume (contacts),Avg Improvement (% or min),Total Savings ($),% of Total Savings,Cost Source,Effective Cost ($/contact),AHT Used (minutes)\n';
                    const totalSavingsAll = calculateTotalSavings(filteredUseCases, filteredMonths);
                    filteredUseCases.forEach(uc => {
                        let totalVolume = 0, totalSavings = 0; 
                        const improvements = [];
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            totalVolume += parseFloat(md.volume) || 0;
                            totalSavings += calculateSavings(uc, month.id);
                            if (md.improvement != null && !isNaN(parseFloat(md.improvement))) {
                                improvements.push(parseFloat(md.improvement));
                            }
                        });
                        const avgImprovement = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                        const avgImpFormatted = uc.metric.includes('min') ? `${avgImprovement.toFixed(1)} min` : `${avgImprovement.toFixed(1)}%`;
                        const pct = totalSavingsAll > 0 ? (totalSavings / totalSavingsAll * 100).toFixed(1) : 0;
                        
                        // Determine cost source using new hierarchy
                        const costSource = getCostSourceDescription(uc, uc.channel);
                        let effectiveCost = getEffectiveCost(uc, uc.channel);
                        const ahtUsed = getApplicableAHT(uc);
                        
                        csv += `${uc.name},${uc.category},${uc.channel},${uc.metric},${uc.specialGroup || '-'},${Math.round(totalVolume)},${avgImpFormatted},${Math.round(totalSavings)},${pct}%,${costSource},$${effectiveCost},${ahtUsed} min\n`;
                    });
                    
                    csv += '\n=== DETAILED MONTHLY BREAKDOWN BY USE CASE ===\n';
                    csv += 'Use Case,Month,Volume,Improvement Input,Baseline,Net Improvement,Effective Cost,Calculation,Savings\n';
                    filteredUseCases.forEach(uc => {
                        const unit = uc.metric.includes('min') ? 'min' : '%';
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        const ahtUsed = getApplicableAHT(uc);
                        
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            const volume = parseFloat(md.volume) || 0;
                            const improvement = parseFloat(md.improvement) || 0;
                            const netImprovement = Math.max(0, improvement - uc.baselineValue);
                            const savings = calculateSavings(uc, month.id);
                            
                            let calculation = '';
                            if (uc.metric.includes('AHT')) {
                                const costPerMinute = effectiveCost / ahtUsed;
                                calculation = `${volume} × ${netImprovement.toFixed(1)}min × $${costPerMinute.toFixed(3)}/min`;
                            } else {
                                calculation = `${volume} × ${netImprovement.toFixed(1)}% × $${effectiveCost}`;
                            }
                            
                            csv += `${uc.name},${month.month} ${month.year},${volume},${improvement.toFixed(1)} ${unit},${uc.baselineValue} ${unit},${netImprovement.toFixed(1)} ${unit},$${effectiveCost},"${calculation}",$${savings.toFixed(2)}\n`;
                        });
                    });
                    
                    csv += '\n=== USE CASE CONFIGURATION & BASELINE EXPLANATION ===\n';
                    csv += 'Use Case,Metric Type,Baseline Value,Unit,Baseline Interpretation,Cost Source Details,Formula Used\n';
                    filteredUseCases.forEach(uc => {
                        const unit = uc.metric.includes('min') ? 'minutes' : '%';
                        let interpretation = '';
                        if (uc.metric.includes('Deflection')) interpretation = 'Current deflection rate without AI';
                        else if (uc.metric.includes('AHT')) interpretation = 'Current time savings without AI';
                        else if (uc.metric.includes('Automation')) interpretation = 'Current automation rate without AI';
                        else if (uc.metric.includes('Self-Service')) interpretation = 'Current self-service success rate';
                        else if (uc.metric.includes('Transfer')) interpretation = 'Current transfer reduction without AI';
                        
                        let costSourceDetails = '';
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        const ahtUsed = getApplicableAHT(uc);
                        
                        if (categoryCosts[uc.category]) {
                            const categoryData = categoryCosts[uc.category];
                            
                            // Check for special group within category-channel (highest priority)
                            if (uc.specialGroup && categoryData[uc.channel] && categoryData[uc.channel]._specialGroups && categoryData[uc.channel]._specialGroups[uc.specialGroup]) {
                                const sgData = categoryData[uc.channel]._specialGroups[uc.specialGroup];
                                if (sgData.costType === 'hourly') {
                                    costSourceDetails = `Special Group (${uc.category}-${uc.channel}): $${sgData.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact`;
                                } else {
                                    costSourceDetails = `Special Group (${uc.category}-${uc.channel}): $${sgData.value}/contact`;
                                }
                            }
                            // Category-Channel specific cost
                            else if (categoryData[uc.channel] && categoryData[uc.channel]._default) {
                                const channelCost = categoryData[uc.channel]._default;
                                if (channelCost.costType === 'hourly') {
                                    costSourceDetails = `Category-Channel: $${channelCost.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact (${uc.category}-${uc.channel})`;
                                } else {
                                    costSourceDetails = `Category-Channel: $${channelCost.value}/contact (${uc.category}-${uc.channel})`;
                                }
                            }
                            // Category default cost
                            else {
                                const defaultCost = categoryData._default || categoryData;
                                if (defaultCost && defaultCost.costType) {
                                    if (defaultCost.costType === 'hourly') {
                                        costSourceDetails = `Category Default: $${defaultCost.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact (${uc.category})`;
                                    } else {
                                        costSourceDetails = `Category Default: $${defaultCost.value}/contact (${uc.category})`;
                                    }
                                }
                            }
                        } else {
                            costSourceDetails = `Channel Default: $${channelCosts[uc.channel]}/contact`;
                        }
                        
                        let formula = '';
                        if (uc.metric.includes('AHT')) {
                            formula = 'Volume × (Improvement - Baseline) minutes × (Cost ÷ AHT) per minute';
                        } else {
                            formula = 'Volume × (Improvement - Baseline) % × Cost per contact';
                        }
                        
                        csv += `${uc.name},${uc.metric},${uc.baselineValue},${unit},"${interpretation}","${costSourceDetails}","${formula}"\n`;
                    });
                    
                } else if (analyticsView === 'specialgroup') {
                    csv += '=== SPECIAL GROUP ANALYSIS ===\n';
                    csv += 'Note: Special groups have highest priority in cost hierarchy. Use cases without special groups use category or channel defaults.\n\n';
                    
                    // Add monthly trends first
                    csv += '=== MONTHLY SAVINGS TRENDS BY GROUP ===\n';
                    csv += 'Month';
                    const allGroups = [...getAllSpecialGroups(), 'No Special Group'];
                    allGroups.forEach(group => csv += `,${group} ($)`);
                    csv += ',Total ($)\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotal = 0;
                        
                        allGroups.forEach(group => {
                            let groupSavings = 0;
                            const groupUseCases = group === 'No Special Group' 
                                ? filteredUseCases.filter(uc => !uc.specialGroup)
                                : filteredUseCases.filter(uc => uc.specialGroup === group);
                                
                            groupUseCases.forEach(uc => {
                                groupSavings += calculateSavings(uc, month.id);
                            });
                            
                            csv += `,${groupSavings.toFixed(2)}`;
                            monthTotal += groupSavings;
                        });
                        
                        csv += `,${monthTotal.toFixed(2)}\n`;
                    });
                    
                    csv += '\n=== GROUP PERFORMANCE SUMMARY ===\n';
                    csv += 'Group,Primary Cost Type,Effective Rate,Use Cases,Total Volume,Total Savings,% of Total,Use Case Names\n';
                    
                    const groupStats = {};
                    
                    // Initialize all special groups from the nested structure
                    getAllSpecialGroups().forEach(g => {
                        groupStats[g] = { costType: 'Varies by Category-Channel', value: 'See details', useCases: [], volume: 0, savings: 0 };
                    });
                    
                    // Initialize "No Special Group"
                    groupStats['No Special Group'] = { 
                        costType: 'Mixed (Category/Channel defaults)', 
                        value: 'See breakdown below', 
                        useCases: [], 
                        volume: 0, 
                        savings: 0 
                    };
                    
                    // Populate stats from use cases
                    filteredUseCases.forEach(uc => {
                        const key = uc.specialGroup || 'No Special Group';
                        if (!groupStats[key]) {
                            groupStats[key] = { costType: 'Unknown', value: '-', useCases: [], volume: 0, savings: 0 };
                        }
                        groupStats[key].useCases.push(uc.name);
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            groupStats[key].volume += parseFloat(md.volume) || 0;
                            groupStats[key].savings += calculateSavings(uc, month.id);
                        });
                    });
                    
                    const totalSavingsAll = Object.values(groupStats).reduce((s, v) => s + v.savings, 0);
                    Object.entries(groupStats).forEach(([g, stats]) => {
                        if (stats.useCases.length > 0) {
                            const pct = totalSavingsAll > 0 ? (stats.savings / totalSavingsAll * 100).toFixed(1) : 0;
                            const rate = stats.value;
                            const useCaseNames = stats.useCases.join('; ');
                            csv += `${g},${stats.costType},${rate},${stats.useCases.length},${Math.round(stats.volume)},${Math.round(stats.savings)},${pct}%,"${useCaseNames}"\n`;
                        }
                    });
                    
                    csv += '\n=== SPECIAL GROUP COST DETAILS ===\n';
                    csv += 'Special Group,Category,Channel,Cost Type,Rate,AHT (min),Converted Cost per Contact\n';
                    
                    // Extract all special group cost details from the nested structure
                    Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([channel, channelData]) => {
                            if (channel !== '_default' && channelData && channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = groupData.ahtMinutes || defaultAHT;
                                    const convertedCost = groupData.costType === 'hourly' ? (groupData.value * aht / 60).toFixed(2) : groupData.value;
                                    csv += `${group},${category},${channel},${groupData.costType},$${groupData.value},${aht},$${convertedCost}\n`;
                                });
                            }
                        });
                    });
                    
                    csv += '\n=== DETAILED BREAKDOWN: USE CASES WITHOUT SPECIAL GROUPS ===\n';
                    csv += 'Use Case,Category,Channel,Metric,Cost Source,Effective Cost ($/contact),AHT (min),Baseline,Avg Improvement,Total Volume,Total Savings,Calculation Method\n';
                    const noSpecialGroupUseCases = filteredUseCases.filter(uc => !uc.specialGroup);
                    noSpecialGroupUseCases.forEach(uc => {
                        let totalVolume = 0, totalSavings = 0;
                        const improvements = [];
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            totalVolume += parseFloat(md.volume) || 0;
                            totalSavings += calculateSavings(uc, month.id);
                            if (md.improvement != null) improvements.push(parseFloat(md.improvement) || 0);
                        });
                        
                        const costSource = getCostSourceDescription(uc, uc.channel);
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        let costDetail = `$${channelCosts[uc.channel]}/contact`;
                        
                        if (categoryCosts[uc.category]) {
                            const categoryData = categoryCosts[uc.category];
                            
                            // Check for special group first
                            if (uc.specialGroup && categoryData[uc.channel] && categoryData[uc.channel]._specialGroups && categoryData[uc.channel]._specialGroups[uc.specialGroup]) {
                                const sgData = categoryData[uc.channel]._specialGroups[uc.specialGroup];
                                const sgAht = sgData.ahtMinutes || getApplicableAHT(uc);
                                if (sgData.costType === 'hourly') {
                                    costDetail = `$${sgData.value}/hr (${sgAht}min AHT) = $${effectiveCost}/contact`;
                                } else {
                                    costDetail = `$${sgData.value}/contact`;
                                }
                            }
                            // Then category-channel
                            else if (categoryData[uc.channel] && categoryData[uc.channel]._default) {
                                const channelCost = categoryData[uc.channel]._default;
                                const costAht = channelCost.ahtMinutes || getApplicableAHT(uc);
                                if (channelCost.costType === 'hourly') {
                                    costDetail = `$${channelCost.value}/hr (${costAht}min AHT) = $${effectiveCost}/contact`;
                                } else {
                                    costDetail = `$${channelCost.value}/contact`;
                                }
                            }
                            // Then category default
                            else {
                                const defaultCost = categoryData._default || categoryData;
                                if (defaultCost && defaultCost.costType) {
                                    const costAht = defaultCost.ahtMinutes || getApplicableAHT(uc);
                                    if (defaultCost.costType === 'hourly') {
                                        costDetail = `$${defaultCost.value}/hr (${costAht}min AHT) = $${effectiveCost}/contact`;
                                    } else {
                                        costDetail = `$${defaultCost.value}/contact`;
                                    }
                                }
                            }
                        }
                        
                        const ahtUsed = getApplicableAHT(uc);
                        const avgImprovement = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                        const avgImpFormatted = uc.metric.includes('min') ? `${avgImprovement.toFixed(1)} min` : `${avgImprovement.toFixed(1)}%`;
                        
                        let calculationMethod = '';
                        if (uc.metric.includes('Deflection')) {
                            calculationMethod = `Volume × (${avgImprovement.toFixed(1)}% - ${uc.baselineValue}%) × $${effectiveCost}`;
                        } else if (uc.metric.includes('AHT')) {
                            calculationMethod = `Volume × (${avgImprovement.toFixed(1)} - ${uc.baselineValue}) min × $${(effectiveCost/ahtUsed).toFixed(3)}/min`;
                        } else {
                            calculationMethod = `Volume × (${avgImprovement.toFixed(1)}% - ${uc.baselineValue}%) × $${effectiveCost}`;
                        }
                        
                        csv += `${uc.name},${uc.category},${uc.channel},${uc.metric},${costSource},"${costDetail}",${ahtUsed},${uc.baselineValue},${avgImpFormatted},${Math.round(totalVolume)},$${Math.round(totalSavings)},"${calculationMethod}"\n`;
                    });
                    
                    csv += '\n=== CATEGORY COST CONFIGURATIONS & USAGE ===\n';
                    csv += 'Category,Cost Type,Rate,AHT (min),Converted Cost per Contact,Use Cases Using This,Total Volume,Total Savings\n';
                    Object.entries(categoryCosts).forEach(([category, data]) => {
                        const aht = data.ahtMinutes || defaultAHT;
                        const convertedCost = data.costType === 'hourly' ? (data.value * aht / 60).toFixed(2) : data.value;
                        const useCasesUsingThis = filteredUseCases.filter(uc => uc.category === category && !uc.specialGroup);
                        const useCaseNames = useCasesUsingThis.map(uc => uc.name).join('; ') || 'None';
                        
                        let totalCatVolume = 0, totalCatSavings = 0;
                        useCasesUsingThis.forEach(uc => {
                            filteredMonths.forEach(month => {
                                const md = uc.data[month.id] || {};
                                totalCatVolume += parseFloat(md.volume) || 0;
                                totalCatSavings += calculateSavings(uc, month.id);
                            });
                        });
                        
                        csv += `${category},${data.costType},$${data.value},${aht},$${convertedCost},"${useCaseNames}",${Math.round(totalCatVolume)},$${Math.round(totalCatSavings)}\n`;
                    });
                    
                    csv += '\n=== CHANNEL DEFAULT COSTS (Fallback) ===\n';
                    csv += 'Channel,Default Cost ($/contact),AHT (min),Use Cases Using Default,Volume,Savings\n';
                    Object.entries(channelCosts).forEach(([channel, cost]) => {
                        const useCasesUsingDefault = filteredUseCases.filter(uc => 
                            uc.channel === channel && !uc.specialGroup && !categoryCosts[uc.category]
                        );
                        const useCaseNames = useCasesUsingDefault.map(uc => uc.name).join('; ') || 'None';
                        
                        let channelVolume = 0, channelSavings = 0;
                        useCasesUsingDefault.forEach(uc => {
                            filteredMonths.forEach(month => {
                                const md = uc.data[month.id] || {};
                                channelVolume += parseFloat(md.volume) || 0;
                                channelSavings += calculateSavings(uc, month.id);
                            });
                        });
                        
                        csv += `${channel},$${cost},${defaultAHT},"${useCaseNames}",${Math.round(channelVolume)},$${Math.round(channelSavings)}\n`;
                    });
                    
                    csv += '\n=== ENHANCED CALCULATION METHODOLOGY ===\n';
                    csv += 'Priority,Cost Source,Description,When Applied,Example\n';
                    csv += '1,Special Groups,"Override ALL other costs for specific agent groups","When use case has specialGroup assigned","Tier 1 Agents override everything"\n';
                    csv += '2,Category-Channel,"Category-specific cost for specific channel","When category has channel-specific cost AND no special group","Pre-Sales Phone has specific rate"\n';
                    csv += '3,Category Default,"Category fallback for unspecified channels","When category has default cost AND no special group or channel-specific","Pre-Sales default applies to email"\n';
                    csv += '4,Channel Default,"Base cost per communication channel","When no special group or category configuration exists","Generic phone cost applies"\n';
                    csv += '\nFormula Examples:\n';
                    csv += 'Metric Type,Formula,Example\n';
                    csv += 'Deflection Rate,"Volume × (Improvement% - Baseline%) × Cost/Contact","1000 contacts × (60% - 10%) × $4.50 = $2,250"\n';
                    csv += 'AHT Reduction,"Volume × (Minutes - Baseline) × Cost/Minute","500 contacts × (2.5 - 0.5) min × $0.75/min = $750"\n';
                    csv += 'Other Metrics,"Volume × (Improvement% - Baseline%) × Cost/Contact","2000 contacts × (40% - 15%) × $3.00 = $1,500"\n';
                }

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `analytics_${analyticsView}_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const exportToJSON = () => {
                const dataToExport = {
                    channelCosts,
                    categoryCosts,
                    useCases,
                    dateRange,
                    defaultAHT,
                    exportDate: new Date().toISOString(),
                    version: '3.0'
                };
                
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const importJSON = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            // Validate and import data
                            if (importedData.channelCosts) setChannelCosts(importedData.channelCosts);
                            if (importedData.categoryCosts) setCategoryCosts(importedData.categoryCosts);
                            // specialGroups are now nested within categoryCosts, no separate import needed
                            if (importedData.useCases) setUseCases(importedData.useCases);
                            if (importedData.dateRange) {
                                setDateRange(importedData.dateRange);
                                setMonths(generateMonthsFromRange(importedData.dateRange.start, importedData.dateRange.end));
                            }
                            if (typeof importedData.defaultAHT === 'number') {
                                setDefaultAHT(importedData.defaultAHT);
                            }
                            
                            alert('Data imported successfully!');
                        } catch (error) {
                            alert('Error importing file. Please ensure it\'s a valid JSON backup file.');
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
                // Reset the file input
                event.target.value = '';
            };

            const clearAllData = () => {
                if (window.confirm('Clear all data? This cannot be undone.')) {
                    localStorage.removeItem('aiValueCalculatorData');
                    window.location.reload();
                }
            };

            // Guidance Modal Component
            const GuidanceModal = () => {
                if (!showGuidanceModal || !selectedMetricGuide) return null;
                
                const guide = InputGuidance[selectedMetricGuide];
                if (!guide) return null;
                
                return (
                    <div className="modal-overlay" onClick={() => setShowGuidanceModal(false)}>
                        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                            <div className="modal-close" onClick={() => setShowGuidanceModal(false)}>
                                <Icons.Close />
                            </div>
                            
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">
                                Input Guide: {selectedMetricGuide}
                            </h2>
                            
                            <div className="space-y-4">
                                <div className="guidance-card">
                                    <div className="guidance-title">📊 Baseline Value</div>
                                    <div className="guidance-content">
                                        <p>{guide.baseline.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.baseline.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.baseline.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">📈 Volume Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.volume.description}</p>
                                        <div className="example-box">
                                            <strong>Calculation:</strong> {guide.volume.calculation}
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.volume.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">✅ Improvement Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.improvement.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.improvement.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.improvement.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">🏆 Industry Benchmarks</div>
                                    <div className="guidance-content">
                                        <div className="grid grid-cols-2 gap-3">
                                            {Object.entries(guide.industryBenchmarks).map(([useCase, benchmark]) => (
                                                <div key={useCase} className="metric-item">
                                                    <div className="metric-label">{useCase}</div>
                                                    <div className="metric-value">{benchmark}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
                    <div className="max-w-7xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex justify-between items-center mb-4">
                                <div>
                                    <h1 className="text-3xl font-bold text-gray-800">AI Contact Center ROI Calculator</h1>
                                    <p className="text-gray-600 mt-2">Advanced cost modeling with category and group pricing</p>
                                    {showSaveIndicator && (
                                        <p className="text-green-600 text-sm mt-1 flex items-center gap-1">
                                            <Icons.Save /> Auto-saved
                                        </p>
                                    )}
                                </div>
                                <div className="flex gap-3 no-print">
                                    <button
                                        onClick={() => setShowSettings(!showSettings)}
                                        className="flex items-center gap-2 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700"
                                    >
                                        <Icons.Settings /> Cost Settings
                                    </button>
                                    <button
                                        onClick={clearAllData}
                                        className="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700"
                                    >
                                        <Icons.Clear /> Clear All
                                    </button>
                                </div>
                            </div>
                            
                            {/* Tabs */}
                            <div className="flex gap-2 mb-4">
                                <button
                                    onClick={() => setActiveTab('data')}
                                    className={`px-4 py-2 rounded-lg ${activeTab === 'data' ? 'tab-active' : 'tab-inactive'}`}
                                >
                                    Data Entry
                                </button>
                                <button
                                    onClick={() => setActiveTab('analytics')}
                                    className={`px-4 py-2 rounded-lg ${activeTab === 'analytics' ? 'tab-active' : 'tab-inactive'}`}
                                >
                                    Analytics & Reports
                                </button>
                                <button
                                    onClick={() => setActiveTab('guidance')}
                                    className={`px-4 py-2 rounded-lg ${activeTab === 'guidance' ? 'tab-active' : 'tab-inactive'}`}
                                >
                                    Input Guidance
                                </button>
                            </div>
                            
                            {/* Action Buttons */}
                            {activeTab === 'data' && (
                                <div className="flex gap-3">
                                    <button
                                        onClick={exportToCSV}
                                        className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                                    >
                                        <Icons.Download /> Export CSV
                                    </button>
                                    <button
                                        onClick={exportToJSON}
                                        className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                    >
                                        <Icons.FileText /> Backup JSON
                                    </button>
                                    <button
                                        onClick={() => fileInputRef.current.click()}
                                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                    >
                                        <Icons.Upload /> Import JSON
                                    </button>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept=".json"
                                        onChange={importJSON}
                                        style={{ display: 'none' }}
                                    />
                                </div>
                            )}
                            
                            {/* Summary Cards */}
                            <div className="grid grid-cols-4 gap-4 mt-4">
                                <div className="bg-blue-50 rounded-lg p-4">
                                    <p className="text-blue-600 text-sm">Use Cases</p>
                                    <p className="text-2xl font-bold">{useCases.length}</p>
                                </div>
                                <div className="bg-green-50 rounded-lg p-4">
                                    <p className="text-green-600 text-sm">Months</p>
                                    <p className="text-2xl font-bold">{months.length}</p>
                                </div>
                                <div className="bg-purple-50 rounded-lg p-4">
                                    <p className="text-purple-600 text-sm">Monthly Avg</p>
                                    <p className="text-2xl font-bold">
                                        ${months.length > 0 ? Math.round(calculateTotalSavings() / months.length).toLocaleString() : 0}
                                    </p>
                                </div>
                                <div className="bg-yellow-50 rounded-lg p-4">
                                    <p className="text-yellow-600 text-sm">Total Savings</p>
                                    <p className="text-2xl font-bold">
                                        ${Math.round(calculateTotalSavings()).toLocaleString()}
                                    </p>
                                </div>
                            </div>
                        </div>

                        {/* Advanced Settings Panel */}
                        {showSettings && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Advanced Cost Settings</h2>
                                {/* Global Default AHT */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Clock /> Call Center Default AHT (minutes)
                                    </h3>
                                    <div className="settings-grid">
                                        <div className="settings-item">
                                            <label className="settings-label">Default AHT (min)</label>
                                            <input
                                                type="number"
                                                value={defaultAHT}
                                                onChange={(e) => setDefaultAHT(Math.max(0, parseFloat(e.target.value) || 0))}
                                                className="settings-input w-28"
                                                step="0.1"
                                            />
                                        </div>
                                    </div>
                                    <p className="text-sm text-gray-500 mt-2">Used when a Category or Special Group does not specify its own AHT.</p>
                                </div>
                                
                                {/* Agent Utilization */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Chart /> Agent Utilization
                                    </h3>
                                    <div className="settings-grid">
                                        <div className="settings-item">
                                            <label className="settings-label">Utilization Rate (%)</label>
                                            <input
                                                type="number"
                                                value={agentUtilization}
                                                onChange={(e) => setAgentUtilization(Math.max(0, Math.min(100, parseFloat(e.target.value) || 75)))}
                                                className="settings-input w-28"
                                                step="1"
                                                min="0"
                                                max="100"
                                            />
                                            <span className="text-sm text-gray-600 ml-2">{agentUtilization}%</span>
                                        </div>
                                    </div>
                                    <p className="text-sm text-gray-500 mt-2">
                                        Accounts for breaks, training, idle time, etc. Typical range: 60-85%. 
                                        Lower utilization = higher true cost per contact.
                                        {agentUtilization < 100 && (
                                            <span className="block mt-1 text-blue-600">
                                                ℹ️ Hourly costs will be adjusted by {(100/agentUtilization).toFixed(2)}x to account for non-productive time
                                            </span>
                                        )}
                                    </p>
                                </div>
                                
                                {/* Channel Costs */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Dollar /> Channel Default Costs ($ per contact)
                                    </h3>
                                    <div className="settings-grid">
                                        {ALL_CHANNELS.map((channelConfig) => {
                                            const cost = channelCosts[channelConfig.id] || channelConfig.defaultCost;
                                            return (
                                                <div key={channelConfig.id} className="settings-item">
                                                    <label className="settings-label">{channelConfig.label}</label>
                                                    <input
                                                        type="number"
                                                        value={cost}
                                                        onChange={(e) => setChannelCosts({
                                                            ...channelCosts,
                                                            [channelConfig.id]: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="settings-input"
                                                        step="0.01"
                                                        placeholder={`Default: $${channelConfig.defaultCost}`}
                                                    />
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                
                                {/* Category-Channel Cost Matrix */}
                                <div className="settings-section">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Category-Channel Cost Matrix (overrides channel defaults)
                                        </h3>
                                        {needsMigration() && (
                                            <button
                                                onClick={migrateCategoryCosts}
                                                className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                                            >
                                                Migrate to New Structure
                                            </button>
                                        )}
                                    </div>
                                    
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>💡 New Feature:</strong> Set different costs for each category-channel combination. 
                                        All channels (Phone, Chat, Email, SMS, Social, Bot) are available for cost configuration. 
                                        Default costs apply when no channel-specific cost is set.
                                    </div>
                                    
                                    {Object.keys(categoryCosts).length === 0 ? (
                                        <div className="text-gray-500 italic">No categories configured. Add use cases to see category cost options.</div>
                                    ) : (
                                        <div className="space-y-6">
                                            {Object.entries(categoryCosts).map(([category, categoryData]) => {
                                                const isNewFormat = categoryData._default || Object.keys(categoryData).some(key => !['costType', 'value', 'ahtMinutes'].includes(key));
                                                const defaultCost = isNewFormat ? (categoryData._default || {}) : categoryData;
                                                const channels = getUniqueChannels();
                                                
                                                return (
                                                    <div key={category} className="border rounded-lg p-4 bg-gray-50">
                                                        <h4 className="font-semibold text-lg mb-3">{category}</h4>
                                                        
                                                        {/* Default Cost Row */}
                                                        <div className="mb-4 p-3 bg-white rounded border">
                                                            <div className="flex items-center gap-3 mb-2">
                                                                <span className="font-medium text-sm text-gray-600">Default Cost (fallback):</span>
                                                            </div>
                                                            <div className="flex items-center gap-3">
                                                                <div className="cost-type-toggle">
                                                                    <button
                                                                        onClick={() => {
                                                                            const newDefault = { ...defaultCost, costType: 'perContact' };
                                                                            setCategoryCosts({
                                                                                ...categoryCosts,
                                                                                [category]: isNewFormat ? { ...categoryData, _default: newDefault } : newDefault
                                                                            });
                                                                        }}
                                                                        className={`cost-type-btn ${defaultCost.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                    >
                                                                        Per Contact
                                                                    </button>
                                                                    <button
                                                                        onClick={() => {
                                                                            const newDefault = { ...defaultCost, costType: 'hourly' };
                                                                            setCategoryCosts({
                                                                                ...categoryCosts,
                                                                                [category]: isNewFormat ? { ...categoryData, _default: newDefault } : newDefault
                                                                            });
                                                                        }}
                                                                        className={`cost-type-btn ${defaultCost.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                    >
                                                                        Hourly
                                                                    </button>
                                                                </div>
                                                                <div className="flex items-center gap-2">
                                                                    <label className="settings-label text-xs font-medium text-blue-600">💰 Cost Value:</label>
                                                                    <input
                                                                        type="number"
                                                                        value={defaultCost.value || 0}
                                                                        onChange={(e) => {
                                                                            const newDefault = { ...defaultCost, value: parseFloat(e.target.value) || 0 };
                                                                            setCategoryCosts({
                                                                                ...categoryCosts,
                                                                                [category]: isNewFormat ? { ...categoryData, _default: newDefault } : newDefault
                                                                            });
                                                                        }}
                                                                        className="settings-input w-24"
                                                                        step="0.01"
                                                                        placeholder="0.00"
                                                                    />
                                                                </div>
                                                                <div className="flex items-center gap-2">
                                                                    <label className="settings-label text-xs font-medium text-green-600">⏱️ AHT (min):</label>
                                                                    <input
                                                                        type="number"
                                                                        value={typeof defaultCost.ahtMinutes === 'number' ? defaultCost.ahtMinutes : defaultAHT}
                                                                        onChange={(e) => {
                                                                            const newDefault = { ...defaultCost, ahtMinutes: Math.max(0, parseFloat(e.target.value) || 0) };
                                                                            setCategoryCosts({
                                                                                ...categoryCosts,
                                                                                [category]: isNewFormat ? { ...categoryData, _default: newDefault } : newDefault
                                                                            });
                                                                        }}
                                                                        className="settings-input w-20"
                                                                        step="0.1"
                                                                        placeholder="0.0"
                                                                    />
                                                                </div>
                                                                <span className="text-sm text-gray-500">
                                                                    ${defaultCost.value || 0} {defaultCost.costType === 'hourly' ? '/hr' : '/contact'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Channel-Specific Costs */}
                                                        <div className="space-y-2">
                                                            <h5 className="font-medium text-sm text-gray-700">Channel-Specific Overrides:</h5>
                                                            {channels.map(channel => {
                                                                const channelCost = isNewFormat ? categoryData[channel] : null;
                                                                const hasChannelCost = channelCost && typeof channelCost === 'object';
                                                                const hasUseCases = useCases.some(uc => uc.channel === channel && uc.category === category);
                                                                
                                                                return (
                                                                    <div key={channel} className="flex items-center gap-3 p-2 bg-white rounded border">
                                                                        <span className={`w-20 text-sm font-medium ${hasUseCases ? 'text-blue-600' : 'text-gray-500'}`}>
                                                                            {getChannelConfig(channel).label}{hasUseCases ? ' ✓' : ''}:
                                                                        </span>
                                                                        
                                                                        {hasChannelCost ? (
                                                                            <>
                                                                                <div className="cost-type-toggle">
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'perContact' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/contact
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'hourly' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/hr
                                                                                    </button>
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-blue-600 font-medium">💰</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={channelCost.value || 0}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, value: parseFloat(e.target.value) || 0 } }
                                                                                        })}
                                                                                        className="settings-input w-20 text-sm"
                                                                                        step="0.01"
                                                                                        placeholder="Cost"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-green-600 font-medium">⏱️</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : defaultCost.ahtMinutes || defaultAHT}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, ahtMinutes: Math.max(0, parseFloat(e.target.value) || 0) } }
                                                                                        })}
                                                                                        className="settings-input w-16 text-sm"
                                                                                        step="0.1"
                                                                                        placeholder="AHT min"
                                                                                    />
                                                                                </div>
                                                                                <span className="text-xs text-gray-500">
                                                                                    ${channelCost.value} {channelCost.costType === 'hourly' ? '/hr' : '/contact'}
                                                                                </span>
                                                                                <button
                                                                                    onClick={() => removeChannelCostFromCategory(category, channel)}
                                                                                    className="px-2 py-1 text-xs bg-red-100 text-red-600 rounded hover:bg-red-200"
                                                                                >
                                                                                    Remove
                                                                                </button>
                                                                                
                                                                                {/* Special Groups for this Category-Channel */}
                                                                                <div className="mt-3 pl-4 border-l-2 border-blue-200">
                                                                                    <div className="text-xs font-medium text-gray-600 mb-2">Special Groups:</div>
                                                                                    {channelCost._specialGroups && Object.entries(channelCost._specialGroups).map(([groupName, groupData]) => (
                                                                                        <div key={groupName} className="mb-2 bg-gray-50 p-2 rounded">
                                                                                            <div className="flex items-center gap-2 mb-1">
                                                                                                <span className="text-xs font-medium">{groupName}:</span>
                                                                                                <button
                                                                                                    onClick={() => {
                                                                                                        const newSpecialGroups = { ...channelCost._specialGroups };
                                                                                                        delete newSpecialGroups[groupName];
                                                                                                        setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: newSpecialGroups
                                                                                                                }
                                                                                                            }
                                                                                                        });
                                                                                                    }}
                                                                                                    className="text-xs text-red-600 hover:text-red-800 ml-auto"
                                                                                                >
                                                                                                    ✕
                                                                                                </button>
                                                                                            </div>
                                                                                            <div className="flex items-center gap-2">
                                                                                                <div className="cost-type-toggle">
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'perContact' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/contact
                                                                                                    </button>
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'hourly' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/hr
                                                                                                    </button>
                                                                                                </div>
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <span className="text-xs text-blue-600 font-medium" title="Cost Value">💰</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.value || 0}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, value: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-16 text-xs"
                                                                                                        step="0.01"
                                                                                                        placeholder="Cost"
                                                                                                        title="Cost Value"
                                                                                                    />
                                                                                                </div>
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <span className="text-xs text-green-600 font-medium" title="AHT (minutes)">⏱️</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.ahtMinutes || defaultAHT}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, ahtMinutes: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-14 text-xs"
                                                                                                        step="0.1"
                                                                                                        placeholder="AHT"
                                                                                                        title="Average Handle Time (minutes)"
                                                                                                    />
                                                                                                    <span className="text-xs text-gray-500">min</span>
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    ))}
                                                                                    <div className="flex items-center gap-2">
                                                                                        <input
                                                                                            type="text"
                                                                                            placeholder="Group name"
                                                                                            className="settings-input w-24 text-xs"
                                                                                            id={`newGroup-${category}-${channel}`}
                                                                                        />
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                const input = document.getElementById(`newGroup-${category}-${channel}`);
                                                                                                const groupName = input.value.trim();
                                                                                                if (groupName) {
                                                                                                    setCategoryCosts({
                                                                                                        ...categoryCosts,
                                                                                                        [category]: {
                                                                                                            ...categoryData,
                                                                                                            [channel]: {
                                                                                                                ...channelCost,
                                                                                                                _specialGroups: {
                                                                                                                    ...(channelCost._specialGroups || {}),
                                                                                                                    [groupName]: {
                                                                                                                        costType: channelCost.costType || 'perContact',
                                                                                                                        value: channelCost.value || 0,
                                                                                                                        ahtMinutes: channelCost.ahtMinutes || defaultAHT
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    });
                                                                                                    input.value = '';
                                                                                                }
                                                                                            }}
                                                                                            className="px-2 py-1 text-xs bg-blue-100 text-blue-600 rounded hover:bg-blue-200"
                                                                                        >
                                                                                            + Add Group
                                                                                        </button>
                                                                                    </div>
                                                                                </div>
                                                                            </>
                                                                        ) : (
                                                                            <>
                                                                                <span className="text-sm text-gray-500 italic">Uses default cost</span>
                                                                                <button
                                                                                    onClick={() => addChannelCostToCategory(category, channel, {
                                                                                        costType: 'perContact',
                                                                                        value: defaultCost.value || 0,
                                                                                        ahtMinutes: defaultCost.ahtMinutes || defaultAHT
                                                                                    })}
                                                                                    className="px-2 py-1 text-xs bg-green-100 text-green-600 rounded hover:bg-green-200"
                                                                                >
                                                                                    Add Override
                                                                                </button>
                                                                            </>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                        
                        {/* Data Entry Tab */}
                        {activeTab === 'data' && (
                            <>
                                {/* Date Range Selector */}
                                <div className="bg-white rounded-lg shadow-lg p-4 mb-6">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Calendar /> Date Range for Analysis
                                    </h3>
                                    <div className="date-range-picker">
                                        <div className="date-input-group">
                                            <label className="date-label">Start Month</label>
                                            <input
                                                type="month"
                                                value={dateRange.start}
                                                onChange={(e) => setDateRange({ ...dateRange, start: e.target.value })}
                                                className="date-input"
                                            />
                                        </div>
                                        <div className="date-input-group">
                                            <label className="date-label">End Month</label>
                                            <input
                                                type="month"
                                                value={dateRange.end}
                                                onChange={(e) => setDateRange({ ...dateRange, end: e.target.value })}
                                                className="date-input"
                                            />
                                        </div>
                                        <div className="flex items-end">
                                            <div className="px-4 py-2 bg-blue-100 text-blue-700 rounded">
                                                {months.length} months selected
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg overflow-hidden">
                                    <div className="overflow-x-auto">
                                        <table className="w-full">
                                            <thead className="bg-gradient-to-r from-blue-600 to-indigo-600 text-white">
                                                <tr>
                                                    <th className="px-4 py-3 text-left">Category</th>
                                                    <th className="px-4 py-3 text-left">Use Case</th>
                                                    <th className="px-4 py-3 text-left">Channel</th>
                                                    <th className="px-4 py-3 text-left">Special Group</th>
                                                    <th className="px-4 py-3 text-left">Metric</th>
                                                    <th className="px-4 py-3 text-left">Baseline</th>
                                                    {months.map(month => (
                                                        <th key={month.id} className="px-4 py-3 text-center min-w-[140px]">
                                                            {month.month} {month.year}
                                                        </th>
                                                    ))}
                                                    <th className="px-4 py-3 text-center">Total</th>
                                                    <th className="px-4 py-3 text-center">Action</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {useCases.map((useCase, index) => {
                                                    const totalSavings = months.reduce((sum, month) => 
                                                        sum + calculateSavings(useCase, month.id), 0
                                                    );
                                                    
                                                    return (
                                                        <tr key={useCase.id} className={index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}>
                                                            <td className="px-4 py-3">{useCase.category}</td>
                                                            <td className="px-4 py-3">{useCase.name}</td>
                                                            <td className="px-4 py-3 capitalize">{useCase.channel}</td>
                                                            <td className="px-4 py-3">
                                                                <select
                                                                    value={useCase.specialGroup || ''}
                                                                    onChange={(e) => {
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, specialGroup: e.target.value || null}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="text-xs border rounded px-1 py-0.5"
                                                                >
                                                                    <option value="">None</option>
                                                                    {getAvailableSpecialGroups(useCase.category, useCase.channel).map(group => (
                                                                        <option key={group} value={group}>{group}</option>
                                                                    ))}
                                                                </select>
                                                            </td>
                                                            <td className="px-4 py-3">{useCase.metric}</td>
                                                            <td className="px-4 py-3">
                                                                <input
                                                                    type="number"
                                                                    value={useCase.baselineValue}
                                                                    onChange={(e) => {
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, baselineValue: parseFloat(e.target.value) || 0}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="w-16 px-2 py-1 border rounded"
                                                                />
                                                            </td>
                                                            {months.map(month => {
                                                                const monthData = useCase.data[month.id] || {};
                                                                const savings = calculateSavings(useCase, month.id);
                                                                
                                                                return (
                                                                    <td key={month.id} className="px-2 py-2">
                                                                        <div className="space-y-1">
                                                                            <input
                                                                                type="number"
                                                                                placeholder="Volume"
                                                                                value={monthData.volume || ''}
                                                                                onChange={(e) => updateUseCaseData(useCase.id, month.id, 'volume', e.target.value)}
                                                                                className="w-full px-2 py-1 text-xs border rounded"
                                                                            />
                                                                            <input
                                                                                type="number"
                                                                                placeholder={useCase.metric.includes('min') ? 'Minutes' : '%'}
                                                                                value={monthData.improvement || ''}
                                                                                onChange={(e) => updateUseCaseData(useCase.id, month.id, 'improvement', e.target.value)}
                                                                                className="w-full px-2 py-1 text-xs border rounded"
                                                                            />
                                                                            <div className="text-xs font-bold text-green-600">
                                                                                ${Math.round(savings).toLocaleString()}
                                                                            </div>
                                                                        </div>
                                                                    </td>
                                                                );
                                                            })}
                                                            <td className="px-4 py-3 font-bold text-green-600">
                                                                ${Math.round(totalSavings).toLocaleString()}
                                                            </td>
                                                            <td className="px-4 py-3">
                                                                <button
                                                                    onClick={() => removeUseCase(useCase.id)}
                                                                    className="text-red-600 hover:text-red-800"
                                                                >
                                                                    <Icons.Trash />
                                                                </button>
                                                            </td>
                                                        </tr>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>
                                    
                                    {/* Add Controls */}
                                    <div className="bg-gray-100 px-6 py-4">
                                        <button
                                            onClick={() => setShowAddUseCase(!showAddUseCase)}
                                            className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        >
                                            <Icons.Plus /> Add Use Case
                                        </button>
                                    </div>
                                    
                                    {/* Add Use Case Form */}
                                    {showAddUseCase && (
                                        <div className="bg-blue-50 px-6 py-4">
                                            <div className="grid grid-cols-6 gap-3">
                                                <select
                                                    value={newUseCase.category}
                                                    onChange={(e) => setNewUseCase({...newUseCase, category: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    <option value="Pre-Sales">Pre-Sales</option>
                                                    <option value="Order Support">Order Support</option>
                                                    <option value="Technical Support">Technical Support</option>
                                                    <option value="Customer Service">Customer Service</option>
                                                </select>
                                                <input
                                                    type="text"
                                                    placeholder="Use Case Name"
                                                    value={newUseCase.name}
                                                    onChange={(e) => setNewUseCase({...newUseCase, name: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                />
                                                <select
                                                    value={newUseCase.channel}
                                                    onChange={(e) => setNewUseCase({...newUseCase, channel: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    {ALL_CHANNELS.map(channel => (
                                                        <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                    ))}
                                                </select>
                                                <select
                                                    value={newUseCase.specialGroup || ''}
                                                    onChange={(e) => setNewUseCase({...newUseCase, specialGroup: e.target.value || null})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    <option value="">No Special Group</option>
                                                    {getAvailableSpecialGroups(newUseCase.category, newUseCase.channel).map(group => (
                                                        <option key={group} value={group}>{group}</option>
                                                    ))}
                                                </select>
                                                <select
                                                    value={newUseCase.metric}
                                                    onChange={(e) => setNewUseCase({...newUseCase, metric: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    <option value="Deflection Rate (%)">Deflection Rate (%)</option>
                                                    <option value="AHT Reduction (min)">AHT Reduction (min)</option>
                                                    <option value="Automation Rate (%)">Automation Rate (%)</option>
                                                    <option value="Self-Service Resolution (%)">Self-Service Resolution (%)</option>
                                                    <option value="Transfer Rate Reduction (%)">Transfer Rate Reduction (%)</option>
                                                </select>
                                                <input
                                                    type="number"
                                                    placeholder="Baseline Value"
                                                    value={newUseCase.baselineValue}
                                                    onChange={(e) => setNewUseCase({...newUseCase, baselineValue: parseFloat(e.target.value) || 0})}
                                                    className="px-3 py-2 border rounded"
                                                    step="0.01"
                                                />
                                            </div>
                                            <div className="mt-3 flex justify-end">
                                                <button
                                                    onClick={addUseCase}
                                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                                >
                                                    Add Use Case
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </>
                        )}

                        {/* Analytics Tab */}
                        {activeTab === 'analytics' && (
                            <div className="space-y-6">
                                {/* Analytics Controls */}
                                <div className="bg-white rounded-lg shadow-lg p-4">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Analytics View
                                        </h3>
                                        <div className="flex gap-2">
                                            <button onClick={() => setAnalyticsView('overall')} className={`filter-btn ${analyticsView === 'overall' ? 'filter-btn-active' : 'filter-btn-inactive'}`}>Overall</button>
                                            <button onClick={() => setAnalyticsView('category')} className={`filter-btn ${analyticsView === 'category' ? 'filter-btn-active' : 'filter-btn-inactive'}`}>By Category</button>
                                            <button onClick={() => setAnalyticsView('channel')} className={`filter-btn ${analyticsView === 'channel' ? 'filter-btn-active' : 'filter-btn-inactive'}`}>By Channel</button>
                                            <button onClick={() => setAnalyticsView('usecase')} className={`filter-btn ${analyticsView === 'usecase' ? 'filter-btn-active' : 'filter-btn-inactive'}`}>By Use Case</button>
                                            <button onClick={() => setAnalyticsView('specialgroup')} className={`filter-btn ${analyticsView === 'specialgroup' ? 'filter-btn-active' : 'filter-btn-inactive'}`}>By Special Group</button>
                                        </div>
                                    </div>

                                    {/* Dynamic Filters Based on Analytics View */}
                                    <div className="flex gap-4 pt-4 border-t flex-wrap">
                                        {/* Category Filter - Available for all views except 'category' */}
                                        {analyticsView !== 'category' && (
                                            <div className="flex items-center gap-2">
                                                <label className="text-sm font-medium">Category:</label>
                                                <select value={selectedCategory} onChange={(e) => setSelectedCategory(e.target.value)} className="px-3 py-1 border rounded text-sm">
                                                    <option value="all">All Categories</option>
                                                    {getCategories().map(cat => (<option key={cat} value={cat}>{cat}</option>))}
                                                </select>
                                            </div>
                                        )}
                                        
                                        {/* Channel Filter - Available for all views except 'channel' */}
                                        {analyticsView !== 'channel' && (
                                            <div className="flex items-center gap-2">
                                                <label className="text-sm font-medium">Channel:</label>
                                                <select value={selectedChannel} onChange={(e) => setSelectedChannel(e.target.value)} className="px-3 py-1 border rounded text-sm">
                                                    <option value="all">All Channels</option>
                                                    {ALL_CHANNELS.map(ch => (<option key={ch.id} value={ch.id} className="capitalize">{ch.label}</option>))}
                                                </select>
                                            </div>
                                        )}
                                        
                                        {/* Special Group Filter - Available for all views except 'specialgroup' */}
                                        {analyticsView !== 'specialgroup' && (
                                            <div className="flex items-center gap-2">
                                                <label className="text-sm font-medium">Special Group:</label>
                                                <select value={selectedSpecialGroup || 'all'} onChange={(e) => setSelectedSpecialGroup(e.target.value === 'all' ? null : e.target.value)} className="px-3 py-1 border rounded text-sm">
                                                    <option value="all">All Groups</option>
                                                    <option value="none">No Special Group</option>
                                                    {getAllSpecialGroups().map(sg => (<option key={sg} value={sg}>{sg}</option>))}
                                                </select>
                                            </div>
                                        )}
                                        
                                        {/* Metric Filter - Available for overall and usecase views */}
                                        {(analyticsView === 'overall' || analyticsView === 'usecase') && (
                                            <div className="flex items-center gap-2">
                                                <label className="text-sm font-medium">Metric:</label>
                                                <select value={selectedMetric || 'all'} onChange={(e) => setSelectedMetric(e.target.value === 'all' ? null : e.target.value)} className="px-3 py-1 border rounded text-sm">
                                                    <option value="all">All Metrics</option>
                                                    {[...new Set(useCases.map(uc => uc.metric))].map(metric => (<option key={metric} value={metric}>{metric}</option>))}
                                                </select>
                                            </div>
                                        )}
                                        
                                        {/* Clear Filters Button */}
                                        <div className="flex items-center">
                                            <button 
                                                onClick={() => {
                                                    setSelectedCategory('all');
                                                    setSelectedChannel('all');
                                                    setSelectedSpecialGroup(null);
                                                    setSelectedMetric(null);
                                                }}
                                                className="px-3 py-1 text-xs bg-gray-100 text-gray-600 border rounded hover:bg-gray-200"
                                            >
                                                Clear Filters
                                            </button>
                                        </div>
                                        
                                        {/* Active Filters Count */}
                                        <div className="flex items-center text-xs text-blue-600">
                                            {(() => {
                                                let activeFilters = 0;
                                                if (selectedCategory !== 'all') activeFilters++;
                                                if (selectedChannel !== 'all') activeFilters++;
                                                if (selectedSpecialGroup) activeFilters++;
                                                if (selectedMetric) activeFilters++;
                                                return activeFilters > 0 ? `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active` : 'No filters applied';
                                            })()} • {getFilteredUseCases().length} of {useCases.length} use cases
                                        </div>
                                    </div>

                                    {/* Date Range Selector */}
                                    <div className="date-range-picker mt-4">
                                        <div className="date-input-group">
                                            <label className="date-label">Start Month</label>
                                            <input type="month" value={analyticsDateRange.start} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, start: e.target.value })} className="date-input" />
                                        </div>
                                        <div className="date-input-group">
                                            <label className="date-label">End Month</label>
                                            <input type="month" value={analyticsDateRange.end} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, end: e.target.value })} className="date-input" />
                                        </div>
                                        <div className="flex items-end">
                                            <div className="px-4 py-2 bg-blue-100 text-blue-700 rounded">Analyzing {getFilteredMonths().length} months</div>
                                            <div className="ml-auto">
                                                <button onClick={exportAnalyticsCSV} className="ml-3 px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Export Current View CSV</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Overall View - Charts */}
                                {analyticsView === 'overall' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Monthly Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.monthly}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Cumulative Savings</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.cumulative}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="grid grid-cols-2 gap-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Savings by Category</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.category}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channel}></canvas></div>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* Category View - Charts and Table */}
                                {analyticsView === 'category' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-6 mb-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Category Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Savings = Volume × (Improvement - Baseline) × Effective Cost per Contact. 
                                                Effective cost is determined by hierarchy: Special Group > Category > Channel defaults. 
                                                For AHT metrics, costs are converted to per-minute rates.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Category</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Avg Savings/Contact<br /><small>($/contact)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const categoryStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    useCases.forEach(uc => {
                                                        if (!categoryStats[uc.category]) categoryStats[uc.category] = { useCases: [], volume: 0, savings: 0 };
                                                        categoryStats[uc.category].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            categoryStats[uc.category].volume += parseFloat(md.volume) || 0;
                                                            categoryStats[uc.category].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(categoryStats).map(([category, stats]) => (
                                                        <tr key={category}>
                                                            <td className="font-semibold">{category}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{stats.volume > 0 ? (stats.savings / stats.volume).toFixed(2) : '0.00'}</td>
                                                            <td>{totalSavingsAll > 0 ? `${(stats.savings / totalSavingsAll * 100).toFixed(1)}%` : '0%'}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Channel View - Charts and Table */}
                                {analyticsView === 'channel' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-6 mb-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Channel Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Shows performance across communication channels. 
                                                Default costs can be overridden by category settings or special group pricing. 
                                                Improvement values shown are the average across all use cases in each channel.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Channel</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Default Cost<br /><small>($/contact)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const channelStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    useCases.forEach(uc => {
                                                        if (!channelStats[uc.channel]) channelStats[uc.channel] = { useCases: [], volume: 0, savings: 0, improvements: [] };
                                                        channelStats[uc.channel].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            channelStats[uc.channel].volume += parseFloat(md.volume) || 0;
                                                            channelStats[uc.channel].savings += calculateSavings(uc, month.id);
                                                            if (md.improvement != null) channelStats[uc.channel].improvements.push(parseFloat(md.improvement) || 0);
                                                        });
                                                    });
                                                    return Object.entries(channelStats).map(([channel, stats]) => {
                                                        const avgImprovement = stats.improvements.length ? (stats.improvements.reduce((a,b)=>a+b,0)/stats.improvements.length) : 0;
                                                        return (
                                                            <tr key={channel}>
                                                                <td className="font-semibold capitalize">{channel}</td>
                                                                <td>{stats.useCases.length}</td>
                                                                <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                                <td>{`$${channelCosts[channel]}`}</td>
                                                                <td>{avgImprovement.toFixed(1)}%</td>
                                                                <td>{totalSavingsAll > 0 ? `${(stats.savings / totalSavingsAll * 100).toFixed(1)}%` : '0%'}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                    </div>
                                    </>
                                )}

                                {/* Use Case View - Charts and Table */}
                                {analyticsView === 'usecase' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-6 mb-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Top 5 Use Cases Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Use Case Performance Ranking</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Individual Use Case Performance</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Each use case's savings are calculated using its specific cost hierarchy. 
                                                Improvement values are net of baseline (e.g., if current deflection is 70% and baseline is 10%, net improvement is 60%). 
                                                For AHT metrics, improvements shown in minutes are converted to hourly cost savings.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Use Case</th><th>Category</th><th>Channel</th><th>Metric</th><th>Special Group</th><th>Total Volume<br /><small>(contacts)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>Total Savings<br /><small>($)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    return useCases.map(uc => {
                                                        let totalVolume = 0, totalSavings = 0; const improvements = [];
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            totalVolume += parseFloat(md.volume) || 0;
                                                            totalSavings += calculateSavings(uc, month.id);
                                                            if (md.improvement != null) improvements.push(parseFloat(md.improvement) || 0);
                                                        });
                                                        const avgImprovement = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                        return (
                                                            <tr key={uc.id}>
                                                                <td className="font-semibold">{uc.name}</td>
                                                                <td>{uc.category}</td>
                                                                <td className="capitalize">{uc.channel}</td>
                                                                <td>{uc.metric}</td>
                                                                <td>{uc.specialGroup || '-'}</td>
                                                                <td>{Math.round(totalVolume).toLocaleString()}</td>
                                                                <td>{uc.metric.includes('min') ? `${avgImprovement.toFixed(1)} min` : `${avgImprovement.toFixed(1)}%`}</td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(totalSavings).toLocaleString()}`}</td>
                                                                <td>{totalSavingsAll > 0 ? `${(totalSavings / totalSavingsAll * 100).toFixed(1)}%` : '0%'}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Special Group View - Charts and Table */}
                                {analyticsView === 'specialgroup' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-6 mb-6">
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Special Group Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Special groups have the highest priority in cost calculations, overriding both category and channel defaults. 
                                                Hourly rates are converted to per-contact costs using the group's configured AHT. 
                                                "No Special Group" shows use cases using category or channel default costs.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Special Group</th><th>Cost Type</th><th>Rate<br /><small>($/hr or $/contact)</small></th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const groupStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    // Skip specialGroups export as they are now nested within categoryCosts
                                                    groupStats['No Special Group'] = { costType: 'varies', value: '-', useCases: [], volume: 0, savings: 0 };
                                                    useCases.forEach(uc => {
                                                        const key = uc.specialGroup || 'No Special Group';
                                                        groupStats[key].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            groupStats[key].volume += parseFloat(md.volume) || 0;
                                                            groupStats[key].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(groupStats).map(([group, stats]) => (
                                                        <tr key={group}>
                                                            <td className="font-semibold">{group}</td>
                                                            <td className="capitalize">{stats.costType}</td>
                                                            <td>{stats.value !== '-' ? `$${stats.value} ${stats.costType === 'hourly' ? '/hr' : '/contact'}` : '-'}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{totalSavingsAll > 0 ? `${(stats.savings / totalSavingsAll * 100).toFixed(1)}%` : '0%'}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}
                            </div>
                        )}

                        {/* Guidance Tab */}
                        {activeTab === 'guidance' && (
                            <div className="space-y-6">
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <h2 className="text-2xl font-bold mb-4">Input Guidance</h2>
                                    <div className="grid grid-cols-1 gap-4">
                                        {Object.keys(InputGuidance).map((metric) => (
                                            <div
                                                key={metric}
                                                className="guidance-card cursor-pointer hover:shadow-lg transition-shadow"
                                                onClick={() => {
                                                    setSelectedMetricGuide(metric);
                                                    setShowGuidanceModal(true);
                                                }}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <div className="guidance-title">{metric}</div>
                                                        <div className="guidance-content">
                                                            <p className="mb-2">{InputGuidance[metric].baseline.description}</p>
                                                        </div>
                                                    </div>
                                                    <Icons.Info />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Guidance Modal */}
                        <GuidanceModal />
                    </div>
                </div>
            );
        };

        // Render the application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AIValueCalculator />);
    </script>
</body>
</html>