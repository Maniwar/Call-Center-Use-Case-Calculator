<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Contact Center ROI Calculator - Advanced Edition</title>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
    
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        // Register Chart.js components
        if (window.Chart && Chart.controllers && Chart.elements && Chart.plugins && Chart.scales) {
            try {
                Chart.register(
                    ...Object.values(Chart.controllers),
                    ...Object.values(Chart.elements),
                    ...Object.values(Chart.plugins),
                    ...Object.values(Chart.scales)
                );
            } catch (e) {
                console.log('Chart registration handled by Chart.js automatically');
            }
        }
    </script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Alternating row colors */
        .row-even {
            background-color: #ffffff !important;
        }
        .row-odd {
            background-color: #f9fafb !important;
        }
        .row-selected {
            background-color: #dbeafe !important;
        }
        .row-even td {
            background-color: inherit !important;
        }
        .row-odd td {
            background-color: inherit !important;
        }
        .row-selected td {
            background-color: inherit !important;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Enhanced loading animation */
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 2s ease-out, transform 2s ease-out;
        }
        
        .loading-container.fade-out {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.05);
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            z-index: 2;
            position: relative;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .floating-emojis {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }
        
        .emoji-float {
            position: absolute;
            font-size: 24px;
            animation: float-up 8s linear infinite;
            opacity: 0.8;
            bottom: -50px;
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.8;
                transform: translateY(-10vh) rotate(36deg);
            }
            90% {
                opacity: 0.8;
                transform: translateY(-90vh) rotate(324deg);
            }
            100% {
                transform: translateY(-110vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .emoji-float:nth-child(1) { left: 10%; animation-delay: 0s; animation-duration: 7s; }
        .emoji-float:nth-child(2) { left: 20%; animation-delay: 0.5s; animation-duration: 9s; }
        .emoji-float:nth-child(3) { left: 30%; animation-delay: 1s; animation-duration: 6s; }
        .emoji-float:nth-child(4) { left: 40%; animation-delay: 1.5s; animation-duration: 8s; }
        .emoji-float:nth-child(5) { left: 50%; animation-delay: 2s; animation-duration: 7.5s; }
        .emoji-float:nth-child(6) { left: 60%; animation-delay: 2.5s; animation-duration: 9.5s; }
        .emoji-float:nth-child(7) { left: 70%; animation-delay: 3s; animation-duration: 6.5s; }
        .emoji-float:nth-child(8) { left: 80%; animation-delay: 3.5s; animation-duration: 8.5s; }
        .emoji-float:nth-child(9) { left: 90%; animation-delay: 4s; animation-duration: 7s; }
        .emoji-float:nth-child(10) { left: 15%; animation-delay: 4.5s; animation-duration: 10s; }
        .emoji-float:nth-child(11) { left: 25%; animation-delay: 5s; animation-duration: 6s; }
        .emoji-float:nth-child(12) { left: 35%; animation-delay: 5.5s; animation-duration: 8s; }
        .emoji-float:nth-child(13) { left: 45%; animation-delay: 6s; animation-duration: 9s; }
        .emoji-float:nth-child(14) { left: 55%; animation-delay: 6.5s; animation-duration: 7s; }
        .emoji-float:nth-child(15) { left: 65%; animation-delay: 7s; animation-duration: 8s; }
        
        .loading-text {
            color: white;
            font-size: 20px;
            margin-top: 30px;
            font-weight: 500;
            z-index: 2;
            position: relative;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Print styles */
        @media print {
            .no-print {
                display: none !important;
            }
            body {
                background: white !important;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            /* Mobile layout adjustments */
            body {
                padding: 0;
                margin: 0;
            }
            
            /* Mobile navigation */
            .mobile-nav-toggle {
                display: block !important;
            }
            
            .desktop-only {
                display: none !important;
            }
            
            .mobile-only {
                display: block !important;
            }
            
            /* Mobile tabs - horizontal scroll */
            .tab-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                padding-bottom: 4px;
            }
            
            .tab-container::-webkit-scrollbar {
                height: 4px;
            }
            
            /* Mobile cards stack */
            .stats-grid {
                grid-template-columns: 1fr !important;
                gap: 0.5rem !important;
            }
            
            /* Mobile table */
            .mobile-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 0 -1rem;
                padding: 0 1rem;
            }
            
            table {
                min-width: 600px;
            }
            
            /* Mobile inputs */
            input[type="number"],
            input[type="text"] {
                font-size: 16px !important; /* 16px prevents zoom on iOS */
                min-height: 40px !important;
                padding: 8px 12px !important;
            }
            
            /* Mobile buttons - smaller for mobile */
            button {
                min-height: 32px !important;
                font-size: 13px !important;
                padding: 6px 10px !important;
                touch-action: manipulation;
            }
            
            /* Mobile dropdowns - minimal styling to allow native behavior */
            select {
                font-size: 16px; /* 16px prevents zoom on iOS */
            }
            
            /* Don't override native select appearance on mobile */
            select option {
                font-size: 16px;
            }
            
            /* Mobile modals */
            .modal-content {
                width: 95% !important;
                max-width: none !important;
                margin: 1rem !important;
                max-height: 90vh !important;
                padding: 1rem !important;
            }
            
            /* Mobile charts */
            .chart-container {
                height: 250px !important;
            }
            
            /* Mobile tooltips */
            .tooltip .tooltiptext {
                width: 90vw !important;
                left: 5vw !important;
                margin-left: 0 !important;
                bottom: 100% !important;
            }
            
            /* Mobile filter buttons */
            .filter-container {
                flex-wrap: wrap !important;
                gap: 0.5rem !important;
            }
            
            .filter-btn {
                flex: 1 1 calc(50% - 0.25rem) !important;
                min-width: 120px !important;
                font-size: 12px !important;
            }
            
            /* Mobile header controls */
            .header-controls {
                flex-direction: column !important;
                gap: 0.5rem !important;
            }
            
            .header-buttons {
                display: grid !important;
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 0.5rem !important;
                width: 100% !important;
            }
            
            /* Mobile date inputs */
            .date-range-container {
                flex-direction: column !important;
                gap: 0.5rem !important;
            }
            
            /* Mobile settings grid */
            .settings-grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Mobile bulk edit */
            .bulk-edit-controls {
                flex-direction: column !important;
                position: sticky !important;
                bottom: 0 !important;
                background: white !important;
                padding: 1rem !important;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1) !important;
                z-index: 100 !important;
            }
            
            /* Mobile table cells */
            td, th {
                padding: 6px 4px !important;
                font-size: 12px !important;
            }
            
            /* Mobile-friendly spacing */
            .p-6 {
                padding: 1rem !important;
            }
            
            .p-4 {
                padding: 0.75rem !important;
            }
            
            .mb-6 {
                margin-bottom: 1rem !important;
            }
            
            .gap-6 {
                gap: 1rem !important;
            }
            
            /* Removed old floating button styles */
        }
        
        @media (max-width: 480px) {
            /* Extra small devices */
            .header-buttons {
                grid-template-columns: 1fr !important;
            }
            
            .filter-btn {
                flex: 1 1 100% !important;
            }
            
            /* Stack stats vertically on very small screens */
            .stats-row {
                flex-direction: column !important;
            }
            
            /* Full-width modals on small screens */
            .modal-content {
                width: 100% !important;
                height: 100% !important;
                max-height: 100vh !important;
                margin: 0 !important;
                border-radius: 0 !important;
            }
        }
        
        /* Touch-friendly hover states */
        @media (hover: none) and (pointer: coarse) {
            .tooltip:hover .tooltiptext {
                visibility: hidden;
            }
            
            .bulk-edit-cell:hover .quick-actions {
                opacity: 1;
            }
            
            button:hover {
                transform: none;
            }
        }
        
        /* Hide mobile elements on desktop */
        .mobile-only {
            display: none;
        }
        
        .mobile-nav-toggle {
            display: none;
        }
        
        /* Chart container styles */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        
        /* Bulk edit mode styles */
        .bulk-edit-cell:hover .quick-actions {
            opacity: 1;
        }
        
        .quick-actions {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        
        /* Highlight selected rows */
        .selected-row {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border-left: 3px solid #3b82f6;
        }
        
        /* Improved input focus styles */
        .enhanced-input:focus {
            transform: scale(1.02);
            z-index: 10;
        }
        
        /* Paste feedback animation */
        @keyframes pasteFlash {
            0% { background-color: #dbeafe; }
            50% { background-color: #3b82f6; }
            100% { background-color: #dbeafe; }
        }
        
        .paste-flash {
            animation: pasteFlash 0.5s ease-in-out;
        }
        
        /* Loading states for templates */
        .template-loading {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Keyboard shortcuts help */
        .keyboard-hint {
            font-size: 0.7rem;
            color: #6b7280;
            margin-top: 2px;
        }
        
        /* Icon styles */
        .icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }
        
        /* Animated logo styles */
        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.5));
            }
            50% {
                transform: scale(1.05);
                filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.8));
            }
        }
        
        @keyframes rotate-slow {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        .logo-animated {
            animation: pulse-glow 3s ease-in-out infinite;
            display: inline-block;
        }
        
        .logo-rotate {
            animation: rotate-slow 20s linear infinite;
        }
        
        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        
        .title-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #667eea 75%, #764ba2 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 5s ease infinite;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 350px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -175px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Tab styles */
        .tab-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .tab-inactive {
            background-color: #E5E7EB;
            color: #374151;
        }
        
        .tab-inactive:hover {
            background-color: #D1D5DB;
        }
        
        /* Table styles */
        .analytics-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analytics-table th {
            background-color: #F3F4F6;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #E5E7EB;
        }
        
        .analytics-table td {
            padding: 8px;
            border-bottom: 1px solid #E5E7EB;
        }
        
        .analytics-table tr:hover {
            background-color: #F9FAFB;
        }
        
        /* Filter button styles */
        .filter-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .filter-btn-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .filter-btn-inactive {
            background-color: white;
            color: #374151;
            border: 1px solid #D1D5DB;
        }
        
        .filter-btn-inactive:hover {
            background-color: #F3F4F6;
        }
        
        /* Guidance section styles */
        .guidance-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #3B82F6;
        }
        
        .guidance-title {
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .guidance-content {
            color: #4B5563;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .example-box {
            background: #F3F4F6;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
        }
        
        .metric-guide {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }
        
        .metric-item {
            background: #F9FAFB;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #E5E7EB;
        }
        
        .metric-label {
            font-weight: 600;
            color: #374151;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .metric-value {
            color: #059669;
            font-weight: 500;
            font-size: 14px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Sponsor overlay styles */
        .sponsor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.95), rgba(147, 51, 234, 0.95));
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        @keyframes heartBeat {
            0% { transform: scale(1); }
            14% { transform: scale(1.3); }
            28% { transform: scale(1); }
            42% { transform: scale(1.3); }
            70% { transform: scale(1); }
        }
        
        @keyframes slideUp {
            from { 
                transform: translateY(30px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .sponsor-content {
            text-align: center;
            color: white;
            animation: slideUp 0.5s ease-out;
            max-width: 500px;
            padding: 2rem;
        }
        
        .heart-icon {
            animation: heartBeat 1.5s ease-in-out infinite;
            display: inline-block;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-200px) translateX(var(--float-x)) scale(0.3);
            }
        }
        
        .floating-heart {
            position: absolute;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sponsor-overlay.closing {
            animation: fadeOut 0.8s ease-out forwards;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 24px;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            cursor: pointer;
            background: #F3F4F6;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #E5E7EB;
        }
        
        /* Settings panel styles */
        .settings-section {
            background: #F9FAFB;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }
        
        .settings-item {
            display: flex;
            flex-direction: column;
        }
        
        .settings-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }
        
        .settings-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .settings-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Month selector styles */
        .month-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #F3F4F6;
            border-radius: 6px;
        }
        
        .month-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: white;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .month-remove {
            cursor: pointer;
            color: #EF4444;
            font-weight: bold;
        }
        
        .month-remove:hover {
            color: #DC2626;
        }
        
        /* Date range picker styles */
        .date-range-picker {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .date-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
        }
        
        .date-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Cost type toggle */
        .cost-type-toggle {
            display: inline-flex;
            background: #E5E7EB;
            border-radius: 6px;
            padding: 2px;
        }
        
        .cost-type-btn {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cost-type-btn-active {
            background: white;
            color: #1F2937;
            font-weight: 600;
        }
        
        .cost-type-btn-inactive {
            background: transparent;
            color: #6B7280;
        }
        
        .cost-type-btn-inactive:hover {
            color: #374151;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="loading-container" id="loadingScreen">
        <div class="floating-emojis">
            <span class="emoji-float">üí∞</span>
            <span class="emoji-float">ü§ñ</span>
            <span class="emoji-float">üíù</span>
            <span class="emoji-float">üìû</span>
            <span class="emoji-float">‚úâÔ∏è</span>
            <span class="emoji-float">üí¨</span>
            <span class="emoji-float">üéØ</span>
            <span class="emoji-float">üíµ</span>
            <span class="emoji-float">üë®‚Äçüíº</span>
            <span class="emoji-float">üìä</span>
            <span class="emoji-float">üöÄ</span>
            <span class="emoji-float">üíé</span>
            <span class="emoji-float">üåü</span>
            <span class="emoji-float">üìà</span>
            <span class="emoji-float">üèÜ</span>
        </div>
        <div class="spinner"></div>
        <p class="loading-text">Loading AI ROI Calculator...</p>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // SINGLE SOURCE OF TRUTH FOR ALL CHANNELS
        const ALL_CHANNELS = [
            { id: 'phone', label: 'Phone', defaultCost: 6.00, defaultAHT: 10 },
            { id: 'chat', label: 'Chat', defaultCost: 2.50, defaultAHT: 8 },
            { id: 'email', label: 'Email', defaultCost: 4.00, defaultAHT: 12 },
            { id: 'sms', label: 'SMS', defaultCost: 1.50, defaultAHT: 3 },
            { id: 'social', label: 'Social', defaultCost: 3.00, defaultAHT: 5 },
            { id: 'bot', label: 'Bot', defaultCost: 0.50, defaultAHT: 2 }
        ];
        
        // Simple SVG icons as components
        const Icons = {
            Download: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                </svg>
            ),
            Upload: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
            ),
            Plus: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
            ),
            Trash: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            ),
            Settings: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            ),
            Chart: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
            ),
            Save: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V2" />
                </svg>
            ),
            Users: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            ),
            Clock: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Dollar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Calendar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            ),
            Clear: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Help: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            FileText: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
            ),
            Info: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Close: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ),
            Copy: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
            ),
            RefreshCw: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Edit: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
            )
        };

        // Input Guidance Data
        const InputGuidance = {
            "Deflection Rate (%)": {
                baseline: {
                    description: "Current % of contacts that are already being deflected by existing automation (if any)",
                    typical: "0-10%",
                    example: "If you already have a basic FAQ bot handling 5% of queries, enter 5"
                },
                volume: {
                    description: "Number of simple, repetitive contacts that AI could potentially handle",
                    calculation: "Total contacts √ó % that are simple/repetitive",
                    example: "10,000 monthly chats √ó 40% simple = 4,000 volume"
                },
                improvement: {
                    description: "Expected % of the volume that AI will successfully handle without agent",
                    typical: "60-80%",
                    example: "If AI can handle 70% of the 4,000 simple queries, enter 70",
                    formula: "Volume √ó (Deflection% - Baseline%) √ó Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Password Resets": "85-95%",
                    "Order Status": "75-85%",
                    "FAQs": "70-80%",
                    "Account Balance": "80-90%"
                }
            },
            "AHT Reduction (min)": {
                baseline: {
                    description: "Current average handle time per contact (in minutes)",
                    typical: "8-15 min",
                    example: "If current AHT is 12 minutes, enter 12"
                },
                volume: {
                    description: "Number of agent-handled contacts where AI co-pilot will assist",
                    calculation: "Total agent contacts that need assistance",
                    example: "5,000 complex calls requiring agent assistance"
                },
                improvement: {
                    description: "Target AHT with AI assistance (in minutes)",
                    typical: "6-12 min",
                    example: "If AI will reduce AHT to 10 minutes, enter 10",
                    formula: "Volume √ó (Current AHT - Target AHT) √ó (Cost per Contact √∑ Current AHT) = $ Saved"
                },
                industryBenchmarks: {
                    "Basic Support (with AI)": "6-8 min",
                    "Technical Support (with AI)": "10-12 min",
                    "Sales (with AI)": "8-10 min",
                    "Complex Issues (with AI)": "12-15 min"
                }
            },
            "Automation Rate (%)": {
                baseline: {
                    description: "Current % of processes that are already automated",
                    typical: "10-20%",
                    example: "If 15% of orders are processed automatically, enter 15"
                },
                volume: {
                    description: "Number of routine tasks that could be automated",
                    calculation: "Total routine/repetitive tasks",
                    example: "8,000 order status checks per month"
                },
                improvement: {
                    description: "Expected % that will be fully automated by AI",
                    typical: "50-70%",
                    example: "AI can automate 65% of routine tasks, enter 65",
                    formula: "Volume √ó (Automation% - Baseline%) √ó Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Order Processing": "60-75%",
                    "Returns/Refunds": "50-65%",
                    "Appointment Scheduling": "70-85%",
                    "Document Processing": "55-70%"
                }
            },
            "Self-Service Resolution (%)": {
                baseline: {
                    description: "Current % resolved through existing self-service",
                    typical: "10-25%",
                    example: "If current portal resolves 20%, enter 20"
                },
                volume: {
                    description: "Number of contacts attempting self-service",
                    calculation: "Contacts that try self-service first",
                    example: "3,000 customers trying to self-serve"
                },
                improvement: {
                    description: "Expected % that AI will help resolve without agent",
                    typical: "40-60%",
                    example: "AI improves resolution to 55%, enter 55",
                    formula: "Volume √ó (Resolution% - Baseline%) √ó Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Product Comparisons": "45-60%",
                    "Troubleshooting": "40-55%",
                    "Account Management": "50-65%",
                    "Policy Information": "60-75%"
                }
            },
            "Transfer Rate Reduction (%)": {
                baseline: {
                    description: "Current transfer rate between agents/departments",
                    typical: "25-35%",
                    example: "If 30% of calls are transferred, enter 30"
                },
                volume: {
                    description: "Number of contacts that currently get transferred",
                    calculation: "Total contacts √ó current transfer rate",
                    example: "10,000 calls √ó 30% transfer rate = 3,000"
                },
                improvement: {
                    description: "Expected reduction in transfer rate",
                    typical: "30-50%",
                    example: "Reduce transfers by 40%, enter 40",
                    formula: "Volume √ó (Reduction% - Baseline%) √ó Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Smart Routing": "35-45%",
                    "Intent Detection": "40-50%",
                    "Skill-based Routing": "30-40%",
                    "Context Preservation": "45-55%"
                }
            },
            "NPS Improvement (points)": {
                baseline: {
                    description: "Current NPS score",
                    typical: "20-40 points",
                    example: "If current NPS is 30, enter 30"
                },
                volume: {
                    description: "Number of NPS survey responses (for tracking only)",
                    calculation: "This field is informational - it doesn't affect the dollar value calculation",
                    example: "500 survey responses per month",
                    warning: "üìä Volume tracks survey count but $ value is based on your entire customer base (configured in Settings)",
                    validation: "Sample size validation shown based on your customer base for statistical confidence"
                },
                improvement: {
                    description: "Target NPS score with AI",
                    typical: "30-55 points",
                    example: "If AI will improve NPS to 40, enter 40",
                    formula: "Value = (Annual Customers √ó Retention % √ó Avg Value) √∑ 12",
                    dollarConversion: "üí° Configure NPS value calculation in Settings ‚Üí Categories ‚Üí Metric Values. Set your annual customer base, average customer value, and retention impact rate."
                },
                industryBenchmarks: {
                    "AI Chat Support": "Target: 35-45",
                    "Voice Assistant": "Target: 30-40",
                    "Proactive Support": "Target: 40-50",
                    "Personalized Service": "Target: 38-48"
                }
            },
            "CSAT Improvement (%)": {
                baseline: {
                    description: "Current customer satisfaction score",
                    typical: "70-80%",
                    example: "If current CSAT is 75%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of surveyed interactions (not all interactions)",
                    calculation: "Interactions where CSAT is measured",
                    example: "2,000 CSAT surveys per month",
                    warning: "‚ö†Ô∏è Only count interactions with CSAT surveys"
                },
                improvement: {
                    description: "Expected CSAT percentage point increase",
                    typical: "10-20%",
                    example: "If CSAT improves from 75% to 85%, enter 10",
                    formula: "Surveyed Volume √ó (% Improvement / 100) √ó $ Value per Point",
                    dollarConversion: "üí° How to calculate $ value per CSAT point: (1) Estimate revenue at risk from dissatisfied customers, (2) Divide by total survey responses, (3) Multiply by retention improvement rate (typically 0.3-1%), (4) Example: $100K at risk / 1000 surveys √ó 0.5% = $25/point. Configure in Settings ‚Üí Category Metric Values."
                },
                industryBenchmarks: {
                    "Chatbot Assistance": "8-15%",
                    "Agent Augmentation": "12-18%",
                    "Proactive Support": "15-20%",
                    "Sentiment Analysis": "10-15%"
                }
            },
            "FCR Improvement (%)": {
                baseline: {
                    description: "Current first call resolution rate",
                    typical: "60-70%",
                    example: "If current FCR is 65%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Total contacts that could require follow-ups",
                    calculation: "All contacts needing resolution (not just failures)",
                    example: "6,000 support tickets per month",
                    note: "‚úÖ FCR saves money by avoiding repeat contacts"
                },
                improvement: {
                    description: "Expected FCR percentage point increase",
                    typical: "15-25%",
                    example: "If FCR improves from 65% to 80%, enter 15",
                    formula: "Volume √ó (% Improvement / 100) √ó Cost per Contact (avoided repeats)"
                },
                industryBenchmarks: {
                    "Knowledge Base AI": "15-20%",
                    "Agent Assist": "20-25%",
                    "Predictive Analytics": "10-15%",
                    "Smart Routing": "12-18%"
                }
            },
            "Conversion Rate (%)": {
                baseline: {
                    description: "Current sales conversion rate",
                    typical: "2-5%",
                    example: "If current conversion is 3%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of sales opportunities",
                    calculation: "Leads or prospects engaged",
                    example: "2,000 qualified leads per month",
                    note: "üí∞ This represents potential sales opportunities, not all contacts"
                },
                improvement: {
                    description: "Expected conversion rate percentage point increase",
                    typical: "0.5-2%",
                    example: "If conversion improves from 3% to 4%, enter 1",
                    formula: "Opportunities √ó (New Rate% - Baseline%) √ó Average Deal Value = $ Revenue Generated",
                    dollarConversion: "üí° How to calculate Average Deal Value: (1) Sum total revenue from recent period (e.g., last quarter), (2) Divide by number of closed deals, (3) For subscription: use Customer Lifetime Value, (4) Industry avg: B2C $50-500, B2B $1,000-10,000. Configure in Settings ‚Üí Category Metric Values."
                },
                industryBenchmarks: {
                    "Lead Scoring": "0.8-1.5%",
                    "Personalized Recommendations": "1-2%",
                    "Predictive Analytics": "0.5-1.2%",
                    "Chatbot Qualification": "0.6-1%"
                }
            },
            "Agent Retention (%)": {
                baseline: {
                    description: "Current agent turnover rate",
                    typical: "30-40% annually",
                    example: "Enter 0 as baseline since we measure improvement in retention"
                },
                volume: {
                    description: "Number of agents affected by AI tools",
                    calculation: "Total agents using AI assistance",
                    example: "100 contact center agents",
                    warning: "‚ö†Ô∏è Use agent count, not contact volume"
                },
                improvement: {
                    description: "Expected reduction in agent turnover",
                    typical: "10-20%",
                    example: "If turnover reduces from 35% to 25%, enter 10",
                    formula: "Agent Count √ó (Retention Improvement%) √ó Replacement Cost = $ Saved on Hiring/Training",
                    dollarConversion: "üí° How to calculate Agent Replacement Cost: (1) Recruiting costs (job boards, recruiter fees), (2) Training costs (trainer time √ó hourly rate √ó training hours), (3) Lost productivity (3-6 months ramp time √ó productivity gap), (4) Industry avg: $3,000-8,000 per agent. Configure in Settings ‚Üí Category Metric Values."
                },
                industryBenchmarks: {
                    "AI Assistance Tools": "10-15%",
                    "Reduced Stress": "15-20%",
                    "Career Development": "8-12%",
                    "Job Satisfaction": "12-18%"
                }
            },
            "Compliance Rate (%)": {
                baseline: {
                    description: "Current compliance rate for regulations",
                    typical: "85-95%",
                    example: "If current compliance is 90%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of interactions requiring compliance",
                    calculation: "Regulated interactions or transactions",
                    example: "10,000 regulated interactions per month",
                    note: "‚öñÔ∏è Count only interactions subject to compliance requirements"
                },
                improvement: {
                    description: "Expected compliance rate percentage point increase",
                    typical: "3-8%",
                    example: "If compliance improves from 90% to 95%, enter 5",
                    formula: "Regulated Volume √ó (Compliance Improvement%) √ó Cost per Violation = $ Fines/Penalties Avoided",
                    dollarConversion: "üí° How to calculate Cost per Violation: (1) Review regulatory fine schedules (TCPA: $500-1,500, GDPR: up to 4% revenue, HIPAA: $100-50,000), (2) Add legal fees and settlement costs, (3) Include reputation damage (lost customers √ó CLV), (4) Industry avg: $1,000-10,000 per violation. Configure in Settings ‚Üí Category Metric Values."
                },
                industryBenchmarks: {
                    "Automated Monitoring": "5-8%",
                    "Real-time Alerts": "4-6%",
                    "Quality Assurance AI": "3-5%",
                    "Script Compliance": "6-8%"
                }
            }
        };
        
        // ====================
        // EXCEL COLUMN DEFINITIONS
        // ====================
        const EXCEL_COLUMNS = {
            MAIN_EXPORT: {
                USE_CASE: 'A',
                CATEGORY: 'B', 
                CHANNEL: 'C',
                SPECIAL_GROUP: 'D',
                BENEFIT: 'E',
                MONTH: 'F',
                VOLUME: 'G',
                IMPROVEMENT: 'H',
                BASELINE: 'I',
                NET_IMPROVEMENT: 'J',
                EFFECTIVE_COST: 'K',
                SAVINGS: 'L'
            },
            ANALYTICS_EXPORT: {
                USE_CASE: 'A',
                CATEGORY: 'B',
                CHANNEL: 'C',
                BENEFIT: 'D',
                MONTH: 'E',
                VOLUME: 'F',
                IMPROVEMENT: 'G',
                BASELINE: 'H',
                NET_IMPROVEMENT: 'I',
                COST: 'J',
                SAVINGS: 'K'
            }
        };
        
        // ====================
        // SHARED EXPORT UTILITIES - Single source of truth for export logic
        // ====================
        const ExportUtils = {
            // Create comprehensive context for exports
            createContext: (component) => ({
                // State
                useCases: component.useCases,
                months: component.months,
                dateRange: component.dateRange,
                analyticsDateRange: component.analyticsDateRange,
                activeTab: component.activeTab,
                analyticsView: component.analyticsView,
                selectedCategory: component.selectedCategory,
                selectedChannel: component.selectedChannel,
                selectedSpecialGroup: component.selectedSpecialGroup,
                selectedMetric: component.selectedMetric,
                channelCosts: component.channelCosts,
                categoryCosts: component.categoryCosts,
                metricValues: component.metricValues,
                ahtNegotiationMode: component.ahtNegotiationMode,
                categories: component.categories,
                
                // Functions
                ensureUseCaseHasBenefits: component.ensureUseCaseHasBenefits,
                getEffectiveCost: component.getEffectiveCost,
                getCostSourceDescription: component.getCostSourceDescription,
                getCostConfiguration: component.getCostConfiguration,
                getApplicableAHT: component.getApplicableAHT,
                getEffectiveMetricValue: component.getEffectiveMetricValue,
                getBenefitVolumeValue: component.getBenefitVolumeValue,
                getVolumeLabel: component.getVolumeLabel,
                getTotalVolumeForUseCaseMonth: component.getTotalVolumeForUseCaseMonth,
                calculateBenefitSavings: component.calculateBenefitSavings,
                calculateSavings: component.calculateSavings,
                calculateTotalSavings: component.calculateTotalSavings,
                getFilteredUseCases: component.getFilteredUseCases,
                getFilteredMonths: component.getFilteredMonths,
                getChannelCostValue: component.getChannelCostValue,
                calculateSavingsBreakdownByType: component.calculateSavingsBreakdownByType,
                calculateCostSavings: component.calculateCostSavings,
                calculateRevenueImpact: component.calculateRevenueImpact,
                METRIC_CONFIG: component.METRIC_CONFIG,
                ALL_CHANNELS: component.ALL_CHANNELS
            }),
            
            // Get the proper data based on context
            getExportData: (context) => {
                const { activeTab, analyticsView, getFilteredUseCases, getFilteredMonths, useCases, months } = context;
                const filtered = activeTab === 'analytics';
                return {
                    useCases: filtered && getFilteredUseCases ? getFilteredUseCases() : useCases,
                    months: filtered && getFilteredMonths ? getFilteredMonths() : months
                };
            },
            
            // Generate Excel formula for savings calculation based on benefit type
            generateSavingsFormula: (benefit, uc, row, cols, options = {}) => {
                const metricConfig = METRIC_CONFIG[benefit.metric];
                
                if (!metricConfig) {
                    return `=${cols.VOLUME || 'G'}${row}*(${cols.NET_IMPROVEMENT || 'J'}${row}/100)*${cols.EFFECTIVE_COST || 'K'}${row}`;
                }
                
                // Access these from options or global scope
                const ahtNegotiationMode = options.ahtNegotiationMode;
                const effectiveCost = options.effectiveCost;
                const getApplicableAHT = options.getApplicableAHT;
                const getCostConfiguration = options.getCostConfiguration;
                const getEffectiveMetricValue = options.getEffectiveMetricValue;
                
                switch (metricConfig.type) {
                    case 'time_cost': {
                        const aht = getApplicableAHT ? getApplicableAHT(uc) : 10;
                        const originalAHT = Math.max(0.01, parseFloat(aht) || 10);
                        const costConfig = getCostConfiguration ? getCostConfiguration(uc) : null;
                        
                        if (ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                            // Negotiation mode with per-contact billing
                            return `=${cols.VOLUME}${row}*${cols.EFFECTIVE_COST}${row}*(1-MAX(0.01,${originalAHT}-${cols.NET_IMPROVEMENT}${row})/${originalAHT})`;
                        } else if (!ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                            // Standard mode with per-contact billing: no savings
                            return `0`;
                        } else {
                            // Hourly billing
                            const costPerMin = effectiveCost / originalAHT;
                            return `=${cols.VOLUME}${row}*MIN(${cols.NET_IMPROVEMENT}${row},${originalAHT})*${costPerMin}`;
                        }
                    }
                    case 'percentage_cost':
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${cols.EFFECTIVE_COST}${row}`;
                    case 'fcr_special':
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${cols.EFFECTIVE_COST}${row}*0.3`;
                    case 'points_value': {
                        const value = getEffectiveMetricValue ? getEffectiveMetricValue(metricConfig.metricKey, uc) : 0;
                        return `=${cols.VOLUME}${row}*${cols.NET_IMPROVEMENT}${row}*${value}`;
                    }
                    case 'percentage_value': {
                        const value = getEffectiveMetricValue ? getEffectiveMetricValue(metricConfig.metricKey, uc) : 0;
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${value}`;
                    }
                    default:
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${cols.EFFECTIVE_COST}${row}`;
                }
            },
            
            // Process use case data for export
            processUseCaseData: (uc, month, benefit, benefitIndex, options = {}) => {
                const { ensureUseCaseHasBenefits, METRIC_CONFIG } = options;
                const normalizedUC = ensureUseCaseHasBenefits ? ensureUseCaseHasBenefits(uc) : uc;
                const monthData = uc.data[month.id] || {};

                const volumeFieldKey = normalizedUC.benefits.length === 1
                    ? `volume_${benefit.metric}`
                    : `volume_${benefitIndex}_${benefit.metric}`;
                const improvementFieldKey = normalizedUC.benefits.length === 1
                    ? `improvement_${benefit.metric}`
                    : `improvement_${benefitIndex}_${benefit.metric}`;

                const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                const baseline = benefit.baselineValue || 0;

                // Calculate net improvement based on metric type
                const metricConfig = METRIC_CONFIG ? METRIC_CONFIG[benefit.metric] : null;
                let netImprovement;
                if (metricConfig && metricConfig.inverseMetric) {
                    // For AHT: baseline - improvement (current - target)
                    netImprovement = Math.max(0, baseline - improvement);
                } else {
                    // For normal metrics: improvement - baseline
                    netImprovement = Math.max(0, improvement - baseline);
                }

                return {
                    volume,
                    improvement,
                    baseline,
                    netImprovement,
                    volumeFieldKey,
                    improvementFieldKey
                };
            },
            
            // Generate CSV data rows
            generateCSVDataRows: (data, options = {}) => {
                const { 
                    includeFormulas = false,
                    separator = ',',
                    calculateBenefitSavings,
                    getEffectiveCost,
                    ensureUseCaseHasBenefits
                } = options;
                
                const rows = [];
                let currentRow = options.startRow || 6;
                
                data.useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        data.months.forEach(month => {
                            const processedData = ExportUtils.processUseCaseData(
                                uc, month, benefit, benefitIndex,
                                { ensureUseCaseHasBenefits, METRIC_CONFIG: options.METRIC_CONFIG }
                            );
                            
                            const effectiveCost = getEffectiveCost(uc, uc.channel);
                            let savings;
                            
                            if (includeFormulas) {
                                // Generate Excel formula
                                savings = ExportUtils.generateSavingsFormula(benefit, uc, currentRow, options.cols || {}, {
                                    ...options,
                                    effectiveCost
                                });
                            } else {
                                // Calculate actual value
                                const monthData = uc.data[month.id] || {};
                                savings = calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                            }
                            
                            // Generate Net Improvement formula based on metric type
                            const metricConfig = options.METRIC_CONFIG ? options.METRIC_CONFIG[benefit.metric] : null;
                            let netImprovementFormula;
                            if (metricConfig && metricConfig.inverseMetric) {
                                // For AHT: baseline - improvement (I - H)
                                netImprovementFormula = `=MAX(0,I${currentRow}-H${currentRow})`;
                            } else {
                                // For normal metrics: improvement - baseline (H - I)
                                netImprovementFormula = `=MAX(0,H${currentRow}-I${currentRow})`;
                            }

                            const row = [
                                uc.name,
                                uc.category,
                                uc.channel,
                                uc.specialGroup || 'None',
                                benefit.metric,
                                `${month.month} ${month.year}`,
                                processedData.volume,
                                processedData.improvement,
                                processedData.baseline,
                                includeFormulas ? netImprovementFormula : processedData.netImprovement,
                                effectiveCost.toFixed(6),
                                includeFormulas ? savings : savings.toFixed(2)
                            ];
                            
                            rows.push(row.join(separator));
                            currentRow++;
                        });
                    });
                });
                
                return { rows, endRow: currentRow - 1 };
            },
            
            // Create file download
            downloadFile: (content, filename, mimeType = 'text/csv') => {
                const blob = new Blob([content], { type: mimeType });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                window.URL.revokeObjectURL(url);
            },
            
            // Generate export header
            generateExportHeader: (title, options = {}) => {
                const { dateRange, filters, format = 'csv' } = options;
                const separator = format === 'excel' ? '\t' : ',';
                let header = `${title}\n`;
                header += `Export Date: ${new Date().toISOString()}\n`;
                if (dateRange) {
                    header += `Analysis Period: ${dateRange.start} to ${dateRange.end}\n`;
                }
                if (filters) {
                    Object.entries(filters).forEach(([key, value]) => {
                        if (value && value !== 'all') {
                            header += `${key}: ${value}\n`;
                        }
                    });
                }
                header += '\n';
                return header;
            },
            
            // Generate summary section
            generateSummarySection: (totals, options = {}) => {
                const { format = 'csv', startRow, endRow } = options;
                const separator = format === 'excel' ? '\t' : ',';
                let summary = '\nSUMMARY\n';
                
                if (format === 'excel' && startRow && endRow) {
                    summary += `Total Savings${separator}=SUM(L${startRow}:L${endRow})\n`;
                    summary += `Average Savings per Row${separator}=AVERAGE(L${startRow}:L${endRow})\n`;
                    summary += `Data Rows${separator}=COUNT(L${startRow}:L${endRow})\n`;
                } else {
                    Object.entries(totals).forEach(([key, value]) => {
                        summary += `${key}${separator}${typeof value === 'number' ? value.toFixed(2) : value}\n`;
                    });
                }
                
                return summary;
            },
            
            // Format number for export
            formatExportNumber: (value, decimals = 2) => {
                if (value == null || isNaN(value)) return '0';
                return parseFloat(value).toFixed(decimals);
            },
            
            // Generate Excel export with live formulas
            generateExcelExport: (context, options = {}) => {
                const { 
                    isAnalytics = false,
                    columns = null
                } = options;
                
                // For analytics, check if it needs aggregated view handling
                if (isAnalytics && context.analyticsView && 
                    ['category', 'channel', 'usecase', 'benefit', 'specialgroup'].includes(context.analyticsView)) {
                    return ExportUtils.generateAggregatedAnalyticsExcel(context, options);
                }
                
                // Use appropriate column mapping
                // Analytics overall view uses same columns as main export (12 columns with Special Group)
                // Other analytics views that reach here would use ANALYTICS_EXPORT (11 columns without Special Group)
                // But aggregated views (category, channel, etc.) are handled separately above
                const cols = columns || (
                    (isAnalytics && context.analyticsView === 'overall') ? EXCEL_COLUMNS.MAIN_EXPORT :
                    (isAnalytics && !context.analyticsView) ? EXCEL_COLUMNS.MAIN_EXPORT : // Default to main if no view specified
                    isAnalytics ? EXCEL_COLUMNS.ANALYTICS_EXPORT : 
                    EXCEL_COLUMNS.MAIN_EXPORT
                );
                const TAB = '\t';
                let csv = '';
                
                // Get data based on context
                const data = ExportUtils.getExportData(context);
                
                // Generate header
                const title = isAnalytics 
                    ? `ANALYTICS EXCEL EXPORT - ${context.analyticsView ? context.analyticsView.toUpperCase() : 'OVERALL'} VIEW`
                    : 'AI ROI CALCULATOR - EXCEL EXPORT WITH LIVE FORMULAS';
                    
                csv += title + '\n';
                csv += `Export Date${TAB}${new Date().toISOString().split('T')[0]}\n`;
                
                if (isAnalytics) {
                    csv += `Analytics Period${TAB}${context.analyticsDateRange.start} to ${context.analyticsDateRange.end}\n`;
                    csv += `View${TAB}${context.analyticsView || 'overall'}\n`;
                    if (context.selectedCategory && context.selectedCategory !== 'all') {
                        csv += `Category Filter${TAB}${context.selectedCategory}\n`;
                    }
                    if (context.selectedChannel && context.selectedChannel !== 'all') {
                        csv += `Channel Filter${TAB}${context.selectedChannel}\n`;
                    }
                } else {
                    csv += `Analysis Period${TAB}${context.dateRange.start} to ${context.dateRange.end}\n`;
                }
                
                csv += '\n';
                
                // Column headers based on export type
                if (isAnalytics && context.analyticsView === 'overall') {
                    // Overall view in analytics shows detailed data like main export but filtered
                    csv += `Use Case${TAB}Category${TAB}Channel${TAB}Special Group${TAB}Benefit${TAB}Month${TAB}Volume${TAB}Improvement${TAB}Baseline${TAB}Net Improvement${TAB}Effective Cost${TAB}Savings\n`;
                } else if (isAnalytics) {
                    csv += `Use Case${TAB}Category${TAB}Channel${TAB}Benefit${TAB}Month${TAB}Volume${TAB}Improvement${TAB}Baseline${TAB}Net Improvement${TAB}Cost${TAB}Savings\n`;
                } else {
                    csv += `Use Case${TAB}Category${TAB}Channel${TAB}Special Group${TAB}Benefit${TAB}Month${TAB}Volume${TAB}Improvement${TAB}Baseline${TAB}Net Improvement${TAB}Effective Cost${TAB}Savings\n`;
                }
                
                // Count the actual header rows by counting newlines
                const headerLines = csv.split('\n').length;
                let currentRow = headerLines; // This is the row number where data will start (1-based)
                const calcStartRow = currentRow;
                
                // Generate data rows
                data.useCases.forEach(uc => {
                    const normalizedUC = context.ensureUseCaseHasBenefits(uc);
                    
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        data.months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            
                            // Get volume and improvement values
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            
                            const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                            const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                            const baseline = benefit.baselineValue || 0;
                            const effectiveCost = context.getEffectiveCost(uc, uc.channel);

                            // Generate formulas - reverse for inverse metrics (AHT)
                            const metricConfig = context.METRIC_CONFIG[benefit.metric];
                            let netImprovementFormula;
                            if (metricConfig && metricConfig.inverseMetric) {
                                // For AHT: baseline - improvement
                                netImprovementFormula = `=MAX(0,${cols.BASELINE}${currentRow}-${cols.IMPROVEMENT}${currentRow})`;
                            } else {
                                // For normal metrics: improvement - baseline
                                netImprovementFormula = `=MAX(0,${cols.IMPROVEMENT}${currentRow}-${cols.BASELINE}${currentRow})`;
                            }
                            
                            // Generate savings formula with AHT negotiation logic
                            const savingsFormula = ExportUtils.generateExcelSavingsFormula(
                                benefit, uc, currentRow, cols, context
                            );
                            
                            // Build row
                            const rowData = [
                                uc.name,
                                uc.category,
                                uc.channel
                            ];
                            
                            // Include Special Group for main export and analytics overall view
                            if (!isAnalytics || context.analyticsView === 'overall') {
                                rowData.push(uc.specialGroup || 'None');
                            }
                            
                            rowData.push(
                                benefit.metric,
                                `${month.month} ${month.year}`,
                                volume,
                                improvement,
                                baseline,
                                netImprovementFormula,
                                effectiveCost > 0 ? effectiveCost.toFixed(6) : '0',
                                savingsFormula
                            );
                            
                            csv += rowData.join(TAB) + '\n';
                            currentRow++;
                        });
                    });
                });
                
                const calcEndRow = currentRow - 1;
                
                // Add summary section
                csv += '\n';
                csv += '===== SUMMARY =====\n';
                // Use the correct savings column based on the column mapping
                const savingsCol = cols.SAVINGS;
                csv += `Total Value${TAB}=SUM(${savingsCol}${calcStartRow}:${savingsCol}${calcEndRow})\n`;
                csv += `Data Rows${TAB}=COUNT(${savingsCol}${calcStartRow}:${savingsCol}${calcEndRow})\n`;
                csv += `Average Savings${TAB}=AVERAGE(${savingsCol}${calcStartRow}:${savingsCol}${calcEndRow})\n`;

                // Add savings vs revenue breakdown
                if (context.calculateSavingsBreakdownByType) {
                    const breakdown = context.calculateSavingsBreakdownByType();
                    csv += '\n';
                    csv += '===== VALUE BREAKDOWN =====\n';
                    csv += `Cost Savings${TAB}${Math.round(breakdown.savings)}\n`;
                    csv += `Revenue Impact${TAB}${Math.round(breakdown.revenue)}\n`;
                    csv += `Total${TAB}${Math.round(breakdown.total)}\n`;
                    csv += '\n';
                    csv += 'Note: Cost Savings includes operational efficiency improvements (deflection, automation, AHT reduction, etc.)\n';
                    csv += 'Revenue Impact includes revenue-generating improvements (NPS, CSAT, conversion rate, etc.)\n';
                }

                return csv;
            },
            
            // Generate Excel savings formula with AHT negotiation logic
            generateExcelSavingsFormula: (benefit, uc, row, cols, context) => {
                const metricConfig = context.METRIC_CONFIG[benefit.metric];
                const costCol = cols.EFFECTIVE_COST || cols.COST;
                
                if (!metricConfig) {
                    return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${costCol}${row}`;
                }
                
                const effectiveCost = context.getEffectiveCost(uc, uc.channel);
                
                switch (metricConfig.type) {
                    case 'time_cost': {
                        const aht = context.getApplicableAHT(uc) || 10;
                        const originalAHT = Math.max(0.01, parseFloat(aht) || 10);
                        const costConfig = context.getCostConfiguration(uc);
                        
                        if (context.ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                            // AHT Negotiation mode with per-contact billing
                            return `=${cols.VOLUME}${row}*${costCol}${row}*(1-MAX(0.01,${originalAHT}-${cols.NET_IMPROVEMENT}${row})/${originalAHT})`;
                        } else if (!context.ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                            // Standard mode with per-contact billing: no savings
                            return `0`;
                        } else {
                            // Hourly billing
                            const costPerMin = effectiveCost / originalAHT;
                            // For time_cost with hourly billing, use the capped minutes formula
                            return `=${cols.VOLUME}${row}*MIN(${cols.NET_IMPROVEMENT}${row},${originalAHT})*${costPerMin}`;
                        }
                    }
                    
                    case 'percentage_cost':
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${costCol}${row}`;
                    
                    case 'fcr_special':
                        // FCR uses a 0.3 repeat call factor
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${costCol}${row}*0.3`;
                    
                    case 'points_value': {
                        const value = context.getEffectiveMetricValue(metricConfig.metricKey, uc);
                        return `=${cols.VOLUME}${row}*${cols.NET_IMPROVEMENT}${row}*${value}`;
                    }
                    
                    case 'percentage_value': {
                        const value = context.getEffectiveMetricValue(metricConfig.metricKey, uc);
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${value}`;
                    }
                    
                    default:
                        return `=${cols.VOLUME}${row}*(${cols.NET_IMPROVEMENT}${row}/100)*${costCol}${row}`;
                }
            },
            
            // Generate aggregated analytics Excel export for category/channel/usecase views
            generateAggregatedAnalyticsExcel: (context, options = {}) => {
                const TAB = '\t';
                let csv = '';
                const { analyticsView } = context;
                
                // Header rows - keep track of how many header rows we have
                csv += `ANALYTICS EXCEL EXPORT - ${analyticsView.toUpperCase()} VIEW\n`; // Row 1
                csv += `Export Date${TAB}${new Date().toISOString().split('T')[0]}\n`; // Row 2
                csv += `Analytics Period${TAB}${context.analyticsDateRange.start} to ${context.analyticsDateRange.end}\n`; // Row 3
                csv += `View${TAB}${analyticsView}\n`; // Row 4
                csv += '\n'; // Row 5 (blank)
                
                // Get filtered data
                const filteredUseCases = context.getFilteredUseCases();
                const filteredMonths = context.getFilteredMonths();
                
                // Column headers based on view type (Row 6)
                let headerName = 'Category';
                if (analyticsView === 'channel') headerName = 'Channel';
                else if (analyticsView === 'usecase') headerName = 'Use Case';
                else if (analyticsView === 'benefit') headerName = 'Benefit Type';
                else if (analyticsView === 'specialgroup') headerName = 'Special Group';
                
                csv += `${headerName}${TAB}Total Volume${TAB}Total Savings${TAB}% of Total\n`; // Row 6
                
                // Collect aggregated data
                const aggregatedData = {};
                let totalSavings = 0;
                
                filteredUseCases.forEach(uc => {
                    let key;
                    if (analyticsView === 'category') key = uc.category;
                    else if (analyticsView === 'channel') key = uc.channel;
                    else if (analyticsView === 'usecase') key = uc.name;
                    else if (analyticsView === 'specialgroup') key = uc.specialGroup || 'None';
                    else if (analyticsView === 'benefit') {
                        // For benefit view, aggregate by benefit type
                        const normalizedUC = context.ensureUseCaseHasBenefits(uc);
                        normalizedUC.benefits.forEach(benefit => {
                            const benefitKey = benefit.metric;
                            if (!aggregatedData[benefitKey]) {
                                aggregatedData[benefitKey] = { volume: 0, savings: 0 };
                            }
                            filteredMonths.forEach(month => {
                                const monthData = uc.data[month.id] || {};
                                const benefitVolume = context.getBenefitVolumeValue(normalizedUC, monthData, benefit, normalizedUC.benefits.indexOf(benefit));
                                const benefitSavings = context.calculateBenefitSavings(normalizedUC, benefit, monthData, normalizedUC.benefits.indexOf(benefit));
                                aggregatedData[benefitKey].volume += benefitVolume;
                                aggregatedData[benefitKey].savings += benefitSavings;
                                totalSavings += benefitSavings;
                            });
                        });
                        return; // Skip the rest for benefit view
                    }
                    
                    if (!key) return;
                    
                    if (!aggregatedData[key]) {
                        aggregatedData[key] = { volume: 0, savings: 0 };
                    }
                    
                    filteredMonths.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        aggregatedData[key].volume += context.getTotalVolumeForUseCaseMonth(uc, monthData);
                        const savings = context.calculateSavings(uc, month.id);
                        aggregatedData[key].savings += savings;
                        totalSavings += savings;
                    });
                });
                
                // Write data rows with formulas
                let row = 7; // Data starts at row 7 (after 6 header rows)
                const startRow = row;
                const dataRows = Object.entries(aggregatedData).map(([name, data]) => ({
                    name,
                    volume: Math.round(data.volume),
                    savings: Math.round(data.savings)
                }));
                
                // Sort by savings descending
                dataRows.sort((a, b) => b.savings - a.savings);
                
                // Write each data row
                dataRows.forEach(data => {
                    // Percentage formula divides this row's savings by the total savings (which will be in the row after all data rows + 1 blank row)
                    const totalRow = startRow + dataRows.length + 1; // +1 for the blank row before TOTAL
                    const percentFormula = totalSavings > 0 ? `=C${row}/C$${totalRow}*100` : '0';
                    csv += `${data.name}${TAB}${data.volume}${TAB}${data.savings}${TAB}${percentFormula}\n`;
                    row++;
                });
                
                // Add blank row before total
                csv += '\n';
                row++;
                
                // Add total row with SUM formulas
                csv += `TOTAL${TAB}=SUM(B${startRow}:B${row-2})${TAB}=SUM(C${startRow}:C${row-2})${TAB}100\n`;
                
                return csv;
            },
            
            // Generate complete CSV export
            generateCompleteCSV: (context) => {
                const {
                    useCases, months, dateRange, activeTab, analyticsView,
                    analyticsDateRange, selectedCategory, selectedChannel,
                    selectedSpecialGroup, selectedMetric, channelCosts,
                    categoryCosts, metricValues, ensureUseCaseHasBenefits,
                    getEffectiveCost, getCostSourceDescription, getApplicableAHT,
                    getEffectiveMetricValue, getBenefitVolumeValue, getVolumeLabel,
                    getTotalVolumeForUseCaseMonth, calculateBenefitSavings,
                    calculateSavings, calculateTotalSavings, getFilteredUseCases,
                    getChannelCostValue, METRIC_CONFIG, categories
                } = context;
                
                let csv = '=== AI ROI CALCULATOR FULL EXPORT (MULTI-BENEFIT) ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${dateRange.start} to ${dateRange.end}\n`;
                csv += `Total Months: ${months.length}\n`;
                csv += `Total Use Cases: ${useCases.length}\n`;
                
                // Add filter information if on analytics tab
                if (activeTab === 'analytics') {
                    csv += `\n=== CURRENT ANALYTICS FILTERS ===\n`;
                    csv += `View: ${analyticsView}\n`;
                    csv += `Analytics Period: ${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                    csv += `Category Filter: ${selectedCategory}\n`;
                    csv += `Channel Filter: ${selectedChannel}\n`;
                    csv += `Special Group Filter: ${selectedSpecialGroup || 'all'}\n`;
                    csv += `Metric Filter: ${selectedMetric || 'all'}\n`;
                    csv += `Filtered Results: ${getFilteredUseCases().length} of ${useCases.length} use cases\n`;
                }
                csv += '\n';
                
                // The full CSV implementation would be too large to include here
                // This is a simplified version - the actual implementation is 500+ lines
                return csv + 'Full CSV export data...\n';
            }
        };

        const AIValueCalculator = () => {
            // Initialize with reasonable defaults
            const generateMonthsFromRange = (startDate, endDate) => {
                const months = [];
                
                // Handle invalid or empty dates
                if (!startDate || !endDate) {
                    return months;
                }
                
                // Parse the date strings (format: "YYYY-MM")
                const [startYear, startMonth] = startDate.split('-').map(Number);
                const [endYear, endMonth] = endDate.split('-').map(Number);
                
                // Create dates using local date constructor to avoid timezone issues
                // Set to first day of month at noon to avoid DST issues
                let current = new Date(startYear, startMonth - 1, 1, 12, 0, 0);
                let end = new Date(endYear, endMonth - 1, 1, 12, 0, 0);
                
                // Swap if dates are in wrong order
                if (current > end) {
                    [current, end] = [end, current];
                }
                
                while (current <= end) {
                    months.push({
                        id: `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`,
                        year: current.getFullYear(),
                        month: current.toLocaleString('default', { month: 'short' })
                    });
                    // Move to next month
                    current.setMonth(current.getMonth() + 1);
                }
                return months;
            };

            // Load saved data or use defaults
            const loadFromStorage = () => {
                try {
                    const savedData = localStorage.getItem('aiValueCalculatorData');
                    if (savedData) {
                        const parsed = JSON.parse(savedData);
                        // Ensure each category has metric values
                        const categoryCosts = parsed.categoryCosts || {};
                        const categories = parsed.categories || ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                        
                        // Initialize metric values for categories that don't have them
                        categories.forEach(category => {
                            if (!categoryCosts[category]) {
                                categoryCosts[category] = {};
                            }
                            if (!categoryCosts[category].metricValues) {
                                categoryCosts[category].metricValues = {
                                    npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                                    csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                                    fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                                    conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                                    agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                                    complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                                };
                            }
                        });

                        // Migration: Fix existing NPS configs missing mode/calculationMethod
                        categories.forEach(category => {
                            const npsConfig = categoryCosts[category]?.metricValues?.npsImprovement;
                            if (npsConfig && (npsConfig.annualCustomers || npsConfig.retentionImpactPer10Points)) {
                                // This is a new-style NPS config, ensure it has required fields
                                if (!npsConfig.mode) {
                                    npsConfig.mode = 'monetary';
                                }
                                if (!npsConfig.calculationMethod) {
                                    npsConfig.calculationMethod = 'retention_based';
                                }
                            }
                        });

                        return {
                            categories,
                            categoryCosts,
                            useCases: parsed.useCases || [],
                            dateRange: parsed.dateRange || {
                                start: new Date().toISOString().slice(0, 7),
                                end: new Date(new Date().setMonth(new Date().getMonth() + 11)).toISOString().slice(0, 7)
                            },
                            financialSettings: parsed.financialSettings || {
                                implementationCost: 0,
                                discountRate: 0.10,
                                costType: 'fixed',
                                costPercentage: 10,
                                includeOngoingCosts: false,
                                ongoingCostMonthly: 0
                            }
                        };
                    }
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
                
                const currentDate = new Date();
                const defaultStart = currentDate.toISOString().slice(0, 7);
                const defaultEnd = new Date(currentDate.setMonth(currentDate.getMonth() + 11)).toISOString().slice(0, 7);
                
                // Return sensible defaults with example data
                const defaultCategories = ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                const defaultCategoryCosts = {};
                
                // Initialize each category with metric values
                defaultCategories.forEach(category => {
                    defaultCategoryCosts[category] = {
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        }
                    };
                });
                
                return {
                    categories: defaultCategories,
                    categoryCosts: defaultCategoryCosts,
                    useCases: [
                        {
                            id: 'uc1',
                            category: 'Pre-Sales',
                            name: 'Answer Bot - General Q&A',
                            channel: 'chat',
                            metric: 'Deflection Rate (%)',
                            baselineValue: 0,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc2',
                            category: 'Pre-Sales',
                            name: 'Product Comparison Bot',
                            channel: 'chat',
                            metric: 'Self-Service Resolution (%)',
                            baselineValue: 10,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc3',
                            category: 'Pre-Sales',
                            name: 'Sales Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 1 Agents',
                            data: {}
                        },
                        {
                            id: 'uc4',
                            category: 'Order Support',
                            name: 'Order Status Automation',
                            channel: 'email',
                            metric: 'Automation Rate (%)',
                            baselineValue: 20,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc5',
                            category: 'Order Support',
                            name: 'Returns Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 2 Agents',
                            data: {}
                        }
                    ],
                    dateRange: {
                        start: defaultStart,
                        end: defaultEnd
                    },
                    defaultAHT: 10,
                    metricValues: {
                        npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                        csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                        fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                        conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                        agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                        complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                    }
                };
            };

            const initialData = loadFromStorage();
            
            // State management
            // channelCosts is deprecated but kept as empty object for backward compatibility
            const channelCosts = {};
            const setChannelCosts = () => {}; // No-op setter
            const [categoryCosts, setCategoryCosts] = useState(initialData.categoryCosts);
            const [useCases, setUseCases] = useState(initialData.useCases);
            const [bulkEditMode, setBulkEditMode] = useState(false);
            const [selectedUseCases, setSelectedUseCases] = useState(new Set());
            const [fillMode, setFillMode] = useState('constant'); // 'constant' or 'gradual'
            const [curveType, setCurveType] = useState('linear'); // 'linear', 'exponential', 'scurve', 'logarithmic'
            const [undoStack, setUndoStack] = useState([]);
            const [redoStack, setRedoStack] = useState([]);
            const [unsavedChanges, setUnsavedChanges] = useState(new Set());
            const [dataTemplates, setDataTemplates] = useState(() => {
                const saved = localStorage.getItem('dataTemplates');
                return saved ? JSON.parse(saved) : {
                    'Basic Customer Service': {
                        useCases: [
                            {
                                id: Date.now(),
                                category: 'Customer Service',
                                name: 'General Inquiry Automation',
                                channel: 'chat',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 0}],
                                data: {}
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: '2024-01-01T00:00:00.000Z'
                    },
                    'Technical Support Suite': {
                        useCases: [
                            {
                                id: Date.now() + 1,
                                category: 'Technical Support',
                                name: 'Password Reset Automation',
                                channel: 'bot',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 0}],
                                data: {}
                            },
                            {
                                id: Date.now() + 2,
                                category: 'Technical Support',
                                name: 'Account Status Check',
                                channel: 'bot',
                                benefits: [{metric: 'AHT Reduction (min)', baselineValue: 5}],
                                data: {}
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: '2024-01-01T00:00:00.000Z'
                    },
                    'Comprehensive Test Suite': {
                        useCases: [
                            // Test Cost-based metrics with different channels
                            {
                                id: Date.now() + 100,
                                category: 'Customer Service',
                                name: 'Test: Deflection (Phone)',
                                channel: 'phone',
                                specialGroup: '',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 10}],
                                data: {
                                    'month-1': {
                                        'volume_Deflection Rate (%)': 1000,  // Contacts
                                        'improvement_Deflection Rate (%)': 50  // 50% deflection
                                    }
                                }
                            },
                            {
                                id: Date.now() + 101,
                                category: 'Technical Support',
                                name: 'Test: AHT Reduction (Chat)',
                                channel: 'chat',
                                specialGroup: 'Tier 1',
                                benefits: [{metric: 'AHT Reduction (min)', baselineValue: 2}],
                                data: {
                                    'month-1': {
                                        'volume_AHT Reduction (min)': 500,  // Contacts
                                        'improvement_AHT Reduction (min)': 5  // 5 minutes saved
                                    }
                                }
                            },
                            {
                                id: Date.now() + 102,
                                category: 'Order Support',
                                name: 'Test: FCR Improvement',
                                channel: 'email',
                                specialGroup: '',
                                benefits: [{metric: 'FCR Improvement (%)', baselineValue: 70}],
                                data: {
                                    'month-1': {
                                        'volume_FCR Improvement (%)': 800,  // Contacts
                                        'improvement_FCR Improvement (%)': 85  // 85% FCR
                                    }
                                }
                            },
                            // Test Value-based metrics with different volume types
                            {
                                id: Date.now() + 103,
                                category: 'Customer Service',
                                name: 'Test: NPS Improvement',
                                channel: 'phone',
                                specialGroup: '',
                                benefits: [{metric: 'NPS Improvement (points)', baselineValue: 0}],
                                data: {
                                    'month-1': {
                                        'volume_NPS Improvement (points)': 200,  // Surveys
                                        'improvement_NPS Improvement (points)': 5  // 5 point improvement
                                    }
                                }
                            },
                            {
                                id: Date.now() + 104,
                                category: 'Pre-Sales',
                                name: 'Test: Conversion Rate',
                                channel: 'chat',
                                specialGroup: '',
                                benefits: [{metric: 'Conversion Rate (%)', baselineValue: 5}],
                                data: {
                                    'month-1': {
                                        'volume_Conversion Rate (%)': 100,  // Opportunities
                                        'improvement_Conversion Rate (%)': 15  // 15% conversion
                                    }
                                }
                            },
                            {
                                id: Date.now() + 105,
                                category: 'Technical Support',
                                name: 'Test: Agent Retention',
                                channel: 'phone',
                                specialGroup: 'Offshore',
                                benefits: [{metric: 'Agent Retention (%)', baselineValue: 80}],
                                data: {
                                    'month-1': {
                                        'volume_Agent Retention (%)': 50,  // Agents
                                        'improvement_Agent Retention (%)': 90  // 90% retention
                                    }
                                }
                            },
                            // Test Multiple Benefits in one use case
                            {
                                id: Date.now() + 106,
                                category: 'Customer Service',
                                name: 'Test: Multi-Benefit Case',
                                channel: 'bot',
                                specialGroup: '',
                                benefits: [
                                    {metric: 'Deflection Rate (%)', baselineValue: 20},
                                    {metric: 'NPS Improvement (points)', baselineValue: 0},
                                    {metric: 'AHT Reduction (min)', baselineValue: 1}
                                ],
                                data: {
                                    'month-1': {
                                        'volume_0_Deflection Rate (%)': 2000,  // Contacts for deflection
                                        'improvement_0_Deflection Rate (%)': 60,  // 60% deflection
                                        'volume_1_NPS Improvement (points)': 150,  // Surveys for NPS
                                        'improvement_1_NPS Improvement (points)': 3,  // 3 point improvement
                                        'volume_2_AHT Reduction (min)': 1500,  // Contacts for AHT
                                        'improvement_2_AHT Reduction (min)': 4  // 4 minutes saved
                                    }
                                }
                            },
                            // Test edge cases
                            {
                                id: Date.now() + 107,
                                category: 'Order Support',
                                name: 'Test: Zero Baseline',
                                channel: 'sms',
                                specialGroup: '',
                                benefits: [{metric: 'Automation Rate (%)', baselineValue: 0}],
                                data: {
                                    'month-1': {
                                        'volume_Automation Rate (%)': 300,
                                        'improvement_Automation Rate (%)': 75
                                    }
                                }
                            },
                            {
                                id: Date.now() + 108,
                                category: 'Technical Support',
                                name: 'Test: High Baseline',
                                channel: 'social',
                                specialGroup: 'Tier 2',
                                benefits: [{metric: 'Self-Service Resolution (%)', baselineValue: 50}],
                                data: {
                                    'month-1': {
                                        'volume_Self-Service Resolution (%)': 400,
                                        'improvement_Self-Service Resolution (%)': 80  // Only 30% net improvement
                                    }
                                }
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 100, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 50, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 20, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 500, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 10000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 2000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: new Date().toISOString()
                    }
                };
            });
            const [dateRange, setDateRange] = useState(initialData.dateRange);
            const [months, setMonths] = useState(generateMonthsFromRange(initialData.dateRange.start, initialData.dateRange.end));
            const [activeTab, setActiveTab] = useState('data');
            const [analyticsView, setAnalyticsView] = useState('overall');
            const [analyticsDateRange, setAnalyticsDateRange] = useState({ ...initialData.dateRange });
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [selectedChannel, setSelectedChannel] = useState('all');
            const [selectedSpecialGroup, setSelectedSpecialGroup] = useState(null);
            const [selectedUseCase, setSelectedUseCase] = useState(null);
            const [selectedMetric, setSelectedMetric] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showAddUseCase, setShowAddUseCase] = useState(false);
            const [showTemplates, setShowTemplates] = useState(false); // Toggle for template library
            const [showGuidanceModal, setShowGuidanceModal] = useState(false);
            const [showSponsorOverlay, setShowSponsorOverlay] = useState(false);
            const [isClosingWithHearts, setIsClosingWithHearts] = useState(false);
            const [selectedMetricGuide, setSelectedMetricGuide] = useState(null);
            const [lastSaved, setLastSaved] = useState(new Date());
            const [showSaveIndicator, setShowSaveIndicator] = useState(false);
            const [ahtNegotiationMode, setAhtNegotiationMode] = useState(false); // Toggle for AHT negotiation calculations
            
            // Mobile detection
            const [isMobile, setIsMobile] = useState(false);
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            
            useEffect(() => {
                const checkMobile = () => {
                    // Check for actual mobile device, not just screen size
                    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const isSmallScreen = window.innerWidth <= 768;
                    // Consider it mobile if it's either a mobile device OR a small screen
                    setIsMobile(isMobileDevice || isSmallScreen);
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);
            // Global defaults removed - all configuration at category-channel level
            const defaultAHT = null; // Deprecated - use category-channel config
            const setDefaultAHT = () => {}; // No-op setter for backward compatibility
            const agentUtilization = null; // Deprecated - use category-channel config
            const setAgentUtilization = () => {}; // No-op setter for backward compatibility
            
            const [editingUseCase, setEditingUseCase] = useState(null);
            const [showEditModal, setShowEditModal] = useState(false)
            
            // Category management - ensure all categories from categoryCosts are included
            const deriveCategories = () => {
                const fromInitial = initialData.categories || ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                const fromCosts = Object.keys(initialData.categoryCosts || {});
                const combined = new Set([...fromInitial, ...fromCosts]);
                return Array.from(combined);
            };
            const [categories, setCategories] = useState(deriveCategories());
            const [showCategoryManager, setShowCategoryManager] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [editingCategory, setEditingCategory] = useState(null);
            
            // Value configuration for non-cost metrics
            // Global metric values removed - all configuration at category level
            const metricValues = {}; // Deprecated - use category-specific metric values
            const setMetricValues = () => {}; // No-op setter for backward compatibility
            
            // Metric definitions for UI display
            const METRIC_DEFINITIONS = {
                npsImprovement: { label: 'NPS Configuration' },
                csatImprovement: { label: 'CSAT Configuration' },
                fcrImprovement: { label: 'Value per FCR % Improvement ($)' },
                conversionRate: { label: 'Average Deal Value ($)' },
                agentRetention: { label: 'Agent Replacement Cost ($)' },
                complianceRate: { label: 'Cost per Compliance Violation ($)' }
            };
            
            const fileInputRef = useRef(null);
            const chartRefs = {
                monthly: useRef(null),
                cumulative: useRef(null),
                category: useRef(null),
                channel: useRef(null),
                categoryTrend: useRef(null),
                categoryBreakdown: useRef(null),
                channelTrend: useRef(null),
                channelBreakdown: useRef(null),
                usecaseTrend: useRef(null),
                npsTrend: useRef(null),
                npsCategory: useRef(null),
                npsChannel: useRef(null),
                csatTrend: useRef(null),
                csatCategory: useRef(null),
                csatChannel: useRef(null),
                savingsTrend: useRef(null),
                revenueTrend: useRef(null),
                usecaseBreakdown: useRef(null),
                specialgroupTrend: useRef(null),
                specialgroupBreakdown: useRef(null),
                // Financial Analysis charts
                cashFlow: useRef(null),
                breakeven: useRef(null),
                financialTrend: useRef(null),
                categoryImplementation: useRef(null),
                categoryCostTimeline: useRef(null)
            };
            const chartInstances = useRef({});

            const [newUseCase, setNewUseCase] = useState({
                category: categories[0] || '',
                name: '',
                channel: 'phone',
                specialGroup: null,
                benefits: [
                    {
                        metric: 'Deflection Rate (%)',
                        baselineValue: 0
                    }
                ]
            });

            const [newSpecialGroup, setNewSpecialGroup] = useState({
                name: '',
                costType: 'hourly',
                value: 30.00,
                ahtMinutes: 10, // Default AHT if not specified
                utilization: 75 // Default utilization if not specified
            });

            // Initialize default category billing structure
            const getDefaultCategoryBilling = () => ({
                'Pre-Sales': {
                    implementationCost: 10000,
                    implementationMonth: 0,
                    ongoingCostMonthly: 500,
                    billingCycle: 'monthly'
                },
                'Order Support': {
                    implementationCost: 15000,
                    implementationMonth: 1,
                    ongoingCostMonthly: 750,
                    billingCycle: 'monthly'
                },
                'Technical Support': {
                    implementationCost: 25000,
                    implementationMonth: 2,
                    ongoingCostMonthly: 1000,
                    billingCycle: 'quarterly'
                },
                'Customer Service': {
                    implementationCost: 20000,
                    implementationMonth: 0,
                    ongoingCostMonthly: 800,
                    billingCycle: 'monthly'
                }
            });

            // Financial Analysis State
            const [financialSettings, setFinancialSettings] = useState(() => {
                const saved = initialData.financialSettings || {};
                return {
                    implementationCost: saved.implementationCost || 0,
                    discountRate: saved.discountRate || 0.10,
                    costType: saved.costType || 'fixed',
                    costPercentage: saved.costPercentage || 20,
                    includeOngoingCosts: saved.includeOngoingCosts || false,
                    ongoingCostMonthly: saved.ongoingCostMonthly || 0,
                    showMonthlyBreakdown: saved.showMonthlyBreakdown || false,
                    useCategoryBilling: saved.useCategoryBilling || false,
                    categoryBilling: saved.categoryBilling || getDefaultCategoryBilling()
                };
            });

            const [financialMetrics, setFinancialMetrics] = useState({
                npv: 0,
                irr: 0,
                paybackPeriod: null,
                cashFlows: [],
                breakEvenMonth: null,
                totalROI: 0
            });

            // Update months when date range changes and sync analytics date range
            useEffect(() => {
                setMonths(generateMonthsFromRange(dateRange.start, dateRange.end));
                // Also update analytics date range to match
                setAnalyticsDateRange({ ...dateRange });
            }, [dateRange]);

            // Category management functions
            const addCategory = (name) => {
                if (name && !categories.includes(name)) {
                    setCategories([...categories, name]);
                    // Initialize cost structure with default metric values for new category
                    setCategoryCosts({
                        ...categoryCosts,
                        [name]: {
                            metricValues: {
                                npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                                csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                                fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                                conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                                agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                                complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                            }
                        }
                    });
                }
            };
            
            const editCategory = (oldName, newName) => {
                if (newName && oldName !== newName) {
                    // Update categories list
                    setCategories(categories.map(cat => cat === oldName ? newName : cat));
                    
                    // Update category costs
                    const newCategoryCosts = { ...categoryCosts };
                    if (newCategoryCosts[oldName]) {
                        newCategoryCosts[newName] = newCategoryCosts[oldName];
                        delete newCategoryCosts[oldName];
                    }
                    setCategoryCosts(newCategoryCosts);
                    
                    // Update use cases with the old category
                    setUseCases(useCases.map(uc => ({
                        ...uc,
                        category: uc.category === oldName ? newName : uc.category
                    })));
                }
            };
            
            const removeCategory = (name) => {
                // Check if any use cases use this category
                const hasUseCases = useCases.some(uc => uc.category === name);
                if (hasUseCases) {
                    alert(`Cannot delete category "${name}" - it has active use cases. Please reassign or delete those use cases first.`);
                    return;
                }
                
                // Remove from categories
                setCategories(categories.filter(cat => cat !== name));
                
                // Remove from category costs
                const newCategoryCosts = { ...categoryCosts };
                delete newCategoryCosts[name];
                setCategoryCosts(newCategoryCosts);
            };
            
            // Auto-save functionality with deep comparison
            const prevDataRef = useRef();
            useEffect(() => {
                const dataToSave = {
                    categoryCosts,
                    categories,
                    useCases,
                    dateRange,
                    financialSettings,
                    ahtNegotiationMode
                };
                
                // Deep comparison to prevent unnecessary saves
                const dataString = JSON.stringify(dataToSave);
                if (prevDataRef.current === dataString) {
                    return; // No changes, skip save
                }
                
                const saveTimeout = setTimeout(() => {
                    try {
                        prevDataRef.current = dataString;
                        localStorage.setItem('aiValueCalculatorData', JSON.stringify({
                            ...dataToSave,
                            savedAt: new Date().toISOString()
                        }));
                        setLastSaved(new Date());
                        setShowSaveIndicator(true);
                        setTimeout(() => setShowSaveIndicator(false), 2000);
                    } catch (error) {
                        console.error('Save error:', error);
                    }
                }, 1000);

                return () => clearTimeout(saveTimeout);
            }, [categoryCosts, categories, useCases, dateRange, financialSettings, ahtNegotiationMode]);

            // Calculate cost based on category-channel hierarchy ONLY (no channel defaults)
            const getEffectiveCost = (useCase, channel, options = {}) => {
                const { debug = false } = options;
                
                // Simplified Priority: Category-Channel-SpecialGroup > Category-Channel
                // NO channel defaults - must configure costs at category level
                if (!categoryCosts[useCase.category]) {
                    if (debug) {
                        console.warn(`No cost configuration found for category: "${useCase.category}". Available categories:`, Object.keys(categoryCosts));
                    }
                    return 0; // No cost configured for this category
                }
                
                const categoryData = categoryCosts[useCase.category];
                
                // 1) Category-Channel Special Group (highest priority)
                if (
                    useCase.specialGroup &&
                    categoryData[channel] &&
                    categoryData[channel]._specialGroups &&
                    categoryData[channel]._specialGroups[useCase.specialGroup]
                ) {
                    const specialGroupCost = categoryData[channel]._specialGroups[useCase.specialGroup];
                    if (specialGroupCost.costType === 'perContact') {
                        return specialGroupCost.value || 0;
                    }
                    // Hourly ‚Üí per-contact using AHT and utilization
                    let aht = specialGroupCost.ahtMinutes;
                    if (!aht || aht <= 0) {
                        const channelData = categoryData[channel];
                        if (channelData && channelData._default && channelData._default.ahtMinutes > 0) {
                            aht = channelData._default.ahtMinutes;
                        } else {
                            aht = 10; // Fallback if no AHT configured
                        }
                    }
                    const utilization = specialGroupCost.utilization || 75;
                    const utilizationFactor = utilization > 0 ? (100 / utilization) : 1;
                    return (specialGroupCost.value * aht / 60) * utilizationFactor;
                }
                
                // 2) Category-Channel default
                const channelNode = categoryData[channel];
                if (!channelNode) {
                    if (debug) {
                        console.warn(`No cost configuration for channel "${channel}" in category "${useCase.category}". Available channels:`, Object.keys(categoryData).filter(k => !k.startsWith('_')));
                    }
                    return 0;
                }
                
                if (channelNode && typeof channelNode === 'object') {
                    // Check if this is a cost configuration object (has costType)
                    const costCfg = channelNode.costType ? channelNode : channelNode._default;
                    if (costCfg && costCfg.costType) {
                        if (costCfg.costType === 'perContact') {
                            return costCfg.value || 0;
                        }
                        const aht = (typeof costCfg.ahtMinutes === 'number' && costCfg.ahtMinutes > 0)
                            ? costCfg.ahtMinutes
                            : 10; // Fallback if no AHT configured
                        const utilization = costCfg.utilization || 75;
                        const utilizationFactor = utilization > 0 ? (100 / utilization) : 1;
                        return (costCfg.value * aht / 60) * utilizationFactor;
                    }
                }
                
                // No configuration found for this category-channel combination
                return 0;
            };
            
            // Get the actual cost configuration object for a use case
            const getCostConfiguration = (useCase) => {
                if (!categoryCosts[useCase.category]) return null;
                
                const categoryData = categoryCosts[useCase.category];
                const channel = useCase.channel;
                
                // Check for special group first
                if (useCase.specialGroup && 
                    categoryData[channel] && 
                    categoryData[channel]._specialGroups && 
                    categoryData[channel]._specialGroups[useCase.specialGroup]) {
                    return categoryData[channel]._specialGroups[useCase.specialGroup];
                }
                
                // Then check category-channel
                if (categoryData[channel]) {
                    return categoryData[channel].costType ? categoryData[channel] : categoryData[channel]._default;
                }
                
                return null;
            };
            
            // Get the cost source description for transparency
            const getCostSourceDescription = (useCase, channel) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // Check for special group within category-channel
                    if (useCase.specialGroup && categoryData[channel] && categoryData[channel]._specialGroups && categoryData[channel]._specialGroups[useCase.specialGroup]) {
                        return `Category-Channel-SpecialGroup: ${useCase.category} (${channel}) - ${useCase.specialGroup}`;
                    }
                    
                    // Check for channel-specific cost
                    if (categoryData[channel] && typeof categoryData[channel] === 'object') {
                        return `Category-Channel: ${useCase.category} (${channel})`;
                    }
                    
                    // Category default
                    if (categoryData._default || categoryData.costType) {
                        return `Category Default: ${useCase.category}`;
                    }
                }
                
                return `Not Configured: ${useCase.category} - ${channel}`;
            };

            // Helper to get channel configuration (using top-level ALL_CHANNELS)
            const getChannelConfig = (channelId) => {
                return ALL_CHANNELS.find(ch => ch.id === channelId) || { id: channelId, label: channelId, defaultCost: 0 };
            };
            
            // Helper to ensure all channels exist in channelCosts
            const ensureAllChannelsExist = () => {
                const missingChannels = {};
                ALL_CHANNELS.forEach(channel => {
                    if (!channelCosts.hasOwnProperty(channel.id)) {
                        missingChannels[channel.id] = channel.defaultCost;
                    }
                });
                
                if (Object.keys(missingChannels).length > 0) {
                    setChannelCosts(prev => ({ ...prev, ...missingChannels }));
                    return true; // Channels were added
                }
                return false; // No missing channels
            };
            
            // Get applicable AHT minutes for a use case (SpecialGroup > Category-Channel > Category Default > Global Default)
            const getApplicableAHT = (useCase) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // 1. Special Group AHT (highest priority)
                    if (useCase.specialGroup && categoryData[useCase.channel] && categoryData[useCase.channel]._specialGroups && categoryData[useCase.channel]._specialGroups[useCase.specialGroup]) {
                        const specialGroupData = categoryData[useCase.channel]._specialGroups[useCase.specialGroup];
                        if (specialGroupData && typeof specialGroupData.ahtMinutes === 'number' && specialGroupData.ahtMinutes > 0) {
                            return specialGroupData.ahtMinutes;
                        }
                    }
                    
                    // 2. Category-Channel specific AHT
                    if (categoryData[useCase.channel] && typeof categoryData[useCase.channel] === 'object') {
                        const channelSpecific = categoryData[useCase.channel]._default || categoryData[useCase.channel];
                        if (channelSpecific && typeof channelSpecific.ahtMinutes === 'number' && channelSpecific.ahtMinutes > 0) {
                            return channelSpecific.ahtMinutes;
                        }
                    }
                    
                    // 3. Category default AHT
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && typeof defaultCost.ahtMinutes === 'number' && defaultCost.ahtMinutes > 0) {
                        return defaultCost.ahtMinutes;
                    }
                }
                
                // 4. Global default
                return 10; // Fallback if no AHT configured
            };
            
            // Helper function to get available special groups for a category-channel combination
            const getAvailableSpecialGroups = (category, channel) => {
                if (!categoryCosts[category] || !categoryCosts[category][channel] || !categoryCosts[category][channel]._specialGroups) {
                    return [];
                }
                return Object.keys(categoryCosts[category][channel]._specialGroups);
            };
            
            // Helper function to get all special groups across all category-channel combinations
            const getAllSpecialGroups = () => {
                const allGroups = new Set();
                Object.values(categoryCosts).forEach(categoryData => {
                    Object.values(categoryData).forEach(channelData => {
                        if (channelData && channelData._specialGroups) {
                            Object.keys(channelData._specialGroups).forEach(group => {
                                allGroups.add(group);
                            });
                        }
                    });
                });
                return Array.from(allGroups);
            };

            // Helper function to ensure use case has benefits array (backward compatibility)
            const ensureUseCaseHasBenefits = (useCase) => {
                if (!useCase.benefits && useCase.metric) {
                    // Convert old format to new format
                    return {
                        ...useCase,
                        benefits: [
                            {
                                metric: useCase.metric,
                                baselineValue: useCase.baselineValue || 0
                            }
                        ]
                    };
                }
                return useCase;
            };

            // Migrate monthly data keys when the benefit set (metric names/count) changes
            // Preserves entered volumes/improvements by renaming keys to match the new benefit schema
            const migrateUseCaseBenefitKeys = (oldUseCase, newUseCase) => {
                const oldUC = ensureUseCaseHasBenefits(oldUseCase);
                const newUC = ensureUseCaseHasBenefits(newUseCase);
                const migrated = { ...newUC, data: { ...(oldUseCase.data || {}) } };
                const monthsIds = Object.keys(oldUseCase.data || {});

                const renameKey = (obj, fromKey, toKey) => {
                    if (Object.prototype.hasOwnProperty.call(obj, fromKey)) {
                        obj[toKey] = obj[fromKey];
                        if (toKey !== fromKey) delete obj[fromKey];
                    }
                };

                monthsIds.forEach((monthId) => {
                    const md = { ...(migrated.data[monthId] || {}) };
                    const oldB = oldUC.benefits || [];
                    const newB = newUC.benefits || [];
                    const singleOld = oldB.length === 1;
                    const singleNew = newB.length === 1;

                    if (singleOld && singleNew) {
                        // volume_<oldMetric> -> volume_<newMetric>
                        renameKey(md, `volume_${oldB[0].metric}`, `volume_${newB[0].metric}`);
                        renameKey(md, `improvement_${oldB[0].metric}`, `improvement_${newB[0].metric}`);
                    } else if (!singleOld && !singleNew) {
                        const minLen = Math.min(oldB.length, newB.length);
                        for (let i = 0; i < minLen; i++) {
                            renameKey(md, `volume_${i}_${oldB[i].metric}`, `volume_${i}_${newB[i].metric}`);
                            renameKey(md, `improvement_${i}_${oldB[i].metric}`, `improvement_${i}_${newB[i].metric}`);
                        }
                        // Remove any keys for old benefits beyond the new length
                        for (let i = minLen; i < oldB.length; i++) {
                            delete md[`volume_${i}_${oldB[i].metric}`];
                            delete md[`improvement_${i}_${oldB[i].metric}`];
                        }
                    } else if (singleOld && !singleNew) {
                        // Map single keys to index 0 of the new list
                        if (newB[0]) {
                            renameKey(md, `volume_${oldB[0].metric}`, `volume_0_${newB[0].metric}`);
                            renameKey(md, `improvement_${oldB[0].metric}`, `improvement_0_${newB[0].metric}`);
                        }
                    } else if (!singleOld && singleNew) {
                        // Map index 0 to the single keys; drop the rest
                        if (oldB[0]) {
                            renameKey(md, `volume_0_${oldB[0].metric}`, `volume_${newB[0].metric}`);
                            renameKey(md, `improvement_0_${oldB[0].metric}`, `improvement_${newB[0].metric}`);
                        }
                        for (let i = 1; i < oldB.length; i++) {
                            delete md[`volume_${i}_${oldB[i].metric}`];
                            delete md[`improvement_${i}_${oldB[i].metric}`];
                        }
                    }

                    migrated.data[monthId] = md;
                });

                return migrated;
            };

            // Centralized metric configuration - single source of truth for all calculations
            // To add a new metric:
            // 1. Add entry to METRIC_CONFIG with unique key matching metric name
            // 2. Set type: 'percentage_cost', 'time_cost', 'points_value', 'percentage_value', or create new type
            // 3. Define formula (documentation) and excelFormula (function returning Excel formula string)
            // 4. For value-based metrics, add metricKey pointing to metricValues configuration
            // 5. Update calculateBenefitSavings switch statement if new type is created
            const METRIC_CONFIG = {
                'Deflection Rate (%)': {
                    type: 'percentage_cost',
                    valueType: 'savings',  // Reduces operational costs
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage of contacts deflected'
                },
                'AHT Reduction (min)': {
                    type: 'time_cost',
                    valueType: 'savings',  // Reduces agent time costs
                    formula: 'volume * cappedMinutes * costPerMinute',
                    excelFormula: (row, params) => `=G${row}*MIN(J${row},${params.aht})*${params.rate}`,
                    requiresAHT: true,
                    description: 'Reduction in average handle time (baseline = current AHT, improvement = target AHT)',
                    inverseMetric: true  // Lower improvement value = better (baseline - improvement)
                },
                'Automation Rate (%)': {
                    type: 'percentage_cost',
                    valueType: 'savings',  // Eliminates manual work costs
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage of contacts automated'
                },
                'Self-Service Resolution (%)': {
                    type: 'percentage_cost',
                    valueType: 'savings',  // Prevents agent contact costs
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage resolved via self-service'
                },
                'Transfer Rate Reduction (%)': {
                    type: 'percentage_cost',
                    valueType: 'savings',  // Reduces duplicate handling costs
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Reduction in transfer rate'
                },
                'NPS Improvement (points)': {
                    type: 'points_value',
                    valueType: 'revenue',  // Customer retention drives revenue
                    metricKey: 'npsImprovement',
                    formula: 'volume * netImprovement * valuePerPoint',
                    excelFormula: (row, value) => `=G${row}*J${row}*${value}`,
                    description: 'NPS points improvement'
                },
                'CSAT Improvement (%)': {
                    type: 'percentage_value',
                    valueType: 'revenue',  // Customer satisfaction drives revenue
                    metricKey: 'csatImprovement',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'CSAT percentage improvement'
                },
                'FCR Improvement (%)': {
                    type: 'fcr_special',
                    valueType: 'savings',  // Prevents repeat call costs
                    formula: 'volume * (netImprovement / 100) * cost * repeatCallFactor',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}*0.3`,
                    repeatCallFactor: 0.3,
                    description: 'First Call Resolution improvement'
                },
                'Conversion Rate (%)': {
                    type: 'percentage_value',
                    valueType: 'revenue',  // Directly drives sales revenue
                    metricKey: 'conversionRate',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Conversion rate improvement'
                },
                'Agent Retention (%)': {
                    type: 'percentage_value',
                    valueType: 'savings',  // Reduces hiring/training costs
                    metricKey: 'agentRetention',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Agent retention improvement'
                },
                'Compliance Rate (%)': {
                    type: 'percentage_value',
                    valueType: 'savings',  // Prevents compliance penalties/costs
                    metricKey: 'complianceRate',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Compliance rate improvement'
                }
            };

            // Helper function to get all available metric types
            const getAvailableMetrics = () => {
                return Object.keys(METRIC_CONFIG);
            };
            
            // Helper function to validate metric configuration consistency
            const validateMetricConfig = () => {
                const errors = [];
                Object.entries(METRIC_CONFIG).forEach(([metric, config]) => {
                    if (!config.type) errors.push(`${metric}: missing type`);
                    if (!config.formula) errors.push(`${metric}: missing formula documentation`);
                    if (!config.excelFormula) errors.push(`${metric}: missing excelFormula function`);
                    if (config.type.includes('value') && !config.metricKey) {
                        errors.push(`${metric}: value-based metric missing metricKey`);
                    }
                });
                if (errors.length > 0) {
                    console.error('Metric configuration errors:', errors);
                }
                return errors.length === 0;
            };
            
            // Helper to get metric info for UI display
            const getMetricInfo = (metricName) => {
                const config = METRIC_CONFIG[metricName];
                if (!config) return { description: 'Unknown metric', unit: '%' };
                
                const unit = metricName.includes('(min)') ? 'minutes' : 
                            metricName.includes('(points)') ? 'points' : 
                            metricName.includes('(%)') ? '%' : '';
                
                return {
                    description: config.description || metricName,
                    unit: unit,
                    type: config.type,
                    requiresAHT: config.requiresAHT || false
                };
            };

            // Helper function to categorize metrics by type for analytics
            const getMetricTypeForMetric = (metric) => {
                if (metric.includes('NPS') || metric.includes('CSAT')) {
                    return 'Quality Improvement';
                } else if (metric.includes('FCR')) {
                    return 'Cost Savings'; // FCR prevents repeat calls, saving contact costs
                } else if (metric.includes('Conversion Rate')) {
                    return 'Revenue Generation';
                } else if (metric.includes('Agent Retention')) {
                    return 'Cost Avoidance';
                } else if (metric.includes('Compliance')) {
                    return 'Risk Reduction';
                } else {
                    return 'Cost Savings'; // Default for traditional cost metrics
                }
            };

            // Helper function to get all available metric types
            const getAvailableMetricTypes = () => {
                return ['Cost Savings', 'Quality Improvement', 'Revenue Generation', 'Cost Avoidance', 'Risk Reduction'];
            };
            
            // Helper functions for channel cost extraction to handle both number and object formats
            const getChannelCostValue = (channel) => {
                const cost = channelCosts[channel];
                if (!cost) return 0;
                return typeof cost === 'object' ? cost.value : cost;
            };

            const getChannelCostType = (channel) => {
                const cost = channelCosts[channel];
                if (!cost || typeof cost !== 'object') return 'perContact';
                return cost.costType || 'perContact';
            };

            const getChannelAHT = (channel) => {
                const cost = channelCosts[channel];
                if (!cost || typeof cost !== 'object') return 10;
                return cost.ahtMinutes || 10;
            };
            
            // Curve interpolation functions
            const interpolateValue = (startVal, endVal, progress, curve) => {
                const delta = endVal - startVal;
                
                switch (curve) {
                    case 'linear':
                        // Linear interpolation: steady growth
                        return startVal + delta * progress;
                        
                    case 'exponential':
                        // Exponential: slow start, rapid acceleration
                        const expProgress = (Math.exp(progress * 2) - 1) / (Math.exp(2) - 1);
                        return startVal + delta * expProgress;
                        
                    case 'scurve':
                        // S-curve (sigmoid): slow start, rapid middle, slow end
                        const sigmoid = 1 / (1 + Math.exp(-10 * (progress - 0.5)));
                        return startVal + delta * sigmoid;
                        
                    case 'logarithmic':
                        // Logarithmic: rapid start, slow later
                        const logProgress = Math.log(1 + progress * 9) / Math.log(10);
                        return startVal + delta * logProgress;
                        
                    case 'custom':
                        // Custom curve based on milestone percentages
                        const milestone3 = parseFloat(document.getElementById('custom-milestone-3')?.value || '25') / 100;
                        const milestone6 = parseFloat(document.getElementById('custom-milestone-6')?.value || '50') / 100;
                        const milestone9 = parseFloat(document.getElementById('custom-milestone-9')?.value || '75') / 100;
                        
                        // Map progress to custom milestones
                        if (progress <= 0.25) {
                            // 0-25% of time: interpolate to milestone3
                            return startVal + delta * (milestone3 * (progress / 0.25));
                        } else if (progress <= 0.5) {
                            // 25-50% of time: interpolate from milestone3 to milestone6
                            const localProgress = (progress - 0.25) / 0.25;
                            const milestoneValue = milestone3 + (milestone6 - milestone3) * localProgress;
                            return startVal + delta * milestoneValue;
                        } else if (progress <= 0.75) {
                            // 50-75% of time: interpolate from milestone6 to milestone9
                            const localProgress = (progress - 0.5) / 0.25;
                            const milestoneValue = milestone6 + (milestone9 - milestone6) * localProgress;
                            return startVal + delta * milestoneValue;
                        } else {
                            // 75-100% of time: interpolate from milestone9 to 1
                            const localProgress = (progress - 0.75) / 0.25;
                            const milestoneValue = milestone9 + (1 - milestone9) * localProgress;
                            return startVal + delta * milestoneValue;
                        }
                        
                    default:
                        return startVal + delta * progress;
                }
            };
            
            // Helper function to get the appropriate volume label for a metric
            const getVolumeLabel = (metric) => {
                if (metric.includes('Deflection') || metric.includes('Automation') ||
                    metric.includes('Self-Service') || metric.includes('AHT') ||
                    metric.includes('Transfer') || metric.includes('FCR')) {
                    return 'Contacts';
                } else if (metric.includes('NPS')) {
                    return 'Surveys';
                } else if (metric.includes('CSAT')) {
                    return 'CSAT Cases';
                } else if (metric.includes('Agent Retention')) {
                    return 'Agents';
                } else if (metric.includes('Conversion Rate')) {
                    return 'Opportunities';
                } else if (metric.includes('Compliance')) {
                    return 'Audits';
                } else {
                    return 'Volume';
                }
            };

            // Helper: return appropriate label for improvement field based on metric type
            const getImprovementLabel = (metric) => {
                const metricConfig = METRIC_CONFIG[metric];
                if (metricConfig && metricConfig.inverseMetric) {
                    // For AHT (inverse metric), user enters target value, not the improvement
                    if (metric.includes('AHT')) {
                        return 'Target AHT';
                    }
                    return 'Target';
                }
                // For NPS, user enters target score, not improvement
                if (metric.includes('NPS')) {
                    return 'Target NPS';
                }
                // For CSAT, user enters target CSAT percentage
                if (metric.includes('CSAT')) {
                    return 'Target CSAT';
                }
                // For all other metrics, keep "Impact" as the label
                return 'Impact';
            };

            // Helper: Get NPS/metric configuration for a category
            const getCategoryMetricConfig = (category, metricKey) => {
                return categoryCosts[category]?.metricValues?.[metricKey] || null;
            };

            // Helper: Get default NPS configuration (backward compatibility)
            const getDefaultNPSConfig = () => {
                return {
                    mode: 'monetary',
                    calculationMethod: 'retention_based',
                    industry: 'Other',
                    annualCustomers: 10000,
                    avgCustomerValue: 100,
                    retentionImpactPer10Points: 1.5,
                    attributionMonths: 12, // How many months to spread annual value over (12 = monthly, 1 = lump sum)
                    displayUnit: 'NPS Points'
                };
            };

            // Helper: Get benchmark retention rate for industry
            const getTypicalRetention = (industry) => {
                const benchmarks = {
                    'E-commerce': 1.4,
                    'SaaS': 1.8,
                    'Healthcare': 1.2,
                    'Financial Services': 1.6,
                    'Retail': 1.3,
                    'Manufacturing': 1.5,
                    'Professional Services': 1.5,
                    'Other': 1.5
                };
                return benchmarks[industry] || 1.5;
            };

            // Helper: Calculate NPS monetary value based on configuration
            const calculateNPSValue = (config, npsPointsImprovement) => {
                if (!config || config.mode === 'non-monetary') {
                    return 0;
                }

                if (config.calculationMethod === 'retention_based') {
                    // User's custom retention rate
                    const retentionRate = (config.retentionImpactPer10Points || 1.5) / 100; // e.g., 1.5% = 0.015
                    const customersRetained = (config.annualCustomers || 0) * retentionRate * (npsPointsImprovement / 10);
                    const annualValue = customersRetained * (config.avgCustomerValue || 0);

                    // Attribution: spread annual value over specified months
                    // 12 months = continuous monthly value, 1 month = one-time annual value in first month
                    const attributionMonths = config.attributionMonths || 12;
                    const monthlyValue = annualValue / attributionMonths;

                    // NPS affects entire customer base - volume is just for tracking surveys
                    return monthlyValue;
                } else if (config.calculationMethod === 'fixed_value') {
                    // User provided total annual value per 10 points
                    const attributionMonths = config.attributionMonths || 12;
                    const valuePerPoint = (config.fixedAnnualValuePer10Points || 0) / 10 / attributionMonths;
                    return valuePerPoint * npsPointsImprovement;
                }

                return 0;
            };

            // Helper: Calculate non-monetary benefits (NPS points)
            const calculateNonMonetaryBenefits = (useCase, benefit, monthData, benefitIndex = 0) => {
                const metricConfig = METRIC_CONFIG[benefit.metric];
                if (!metricConfig || !metricConfig.metricKey) {
                    return null;
                }

                const config = getCategoryMetricConfig(useCase.category, metricConfig.metricKey);
                if (!config || config.mode !== 'non-monetary') {
                    return null;
                }

                // Calculate the actual impact value (e.g., NPS points)
                const normalizedUC = ensureUseCaseHasBenefits(useCase);

                // IMPORTANT: Find the ORIGINAL index of this benefit in the full benefits array
                // benefitIndex might be from a filtered array, but data fields use original indices
                const originalIndex = normalizedUC.benefits.findIndex(b => b.metric === benefit.metric);
                const actualIndex = originalIndex >= 0 ? originalIndex : benefitIndex;

                const volumeFieldKey = normalizedUC.benefits.length === 1
                    ? `volume_${benefit.metric}`
                    : `volume_${actualIndex}_${benefit.metric}`;
                const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;

                const fieldKey = normalizedUC.benefits.length === 1
                    ? `improvement_${benefit.metric}`
                    : `improvement_${actualIndex}_${benefit.metric}`;
                const improvement = parseFloat(monthData[fieldKey]) || 0;
                const baseline = parseFloat(benefit.baselineValue) || 0;
                const netImprovement = Math.max(0, improvement - baseline);

                return {
                    metric: benefit.metric,
                    volume: volume,
                    improvement: netImprovement,
                    unit: config.displayUnit || 'points',
                    totalImpact: volume * netImprovement // e.g., 500 surveys √ó 10 points = 5000 point-surveys
                };
            };

            // Helper: Check if there are any non-monetary benefits
            const hasNonMonetaryBenefits = () => {
                return useCases.some(uc => {
                    const normalized = ensureUseCaseHasBenefits(uc);
                    return normalized.benefits.some(b => {
                        const metricConfig = METRIC_CONFIG[b.metric];
                        if (!metricConfig?.metricKey) return false;
                        const config = getCategoryMetricConfig(uc.category, metricConfig.metricKey);
                        return config?.mode === 'non-monetary';
                    });
                });
            };

            // ========== CSAT Helper Functions ==========

            // Helper: Get default CSAT configuration (backward compatibility)
            const getDefaultCSATConfig = () => {
                return {
                    mode: 'monetary',
                    calculationMethod: 'retention_based',
                    industry: 'Other',
                    annualCustomers: 10000,
                    avgCustomerValue: 100,
                    retentionImpactPerCSATPoint: 0.3, // % retention change per 1 CSAT point (e.g., 0.3% = 0.003)
                    attributionMonths: 12,
                    displayUnit: 'CSAT Points'
                };
            };

            // Helper: Get benchmark retention rate per CSAT point for industry
            const getTypicalCSATRetention = (industry) => {
                // CSAT impact is typically smaller than NPS (CSAT is 1-5 scale, NPS is -100 to 100)
                // Industry benchmarks show ~0.2-0.5% retention change per 1 CSAT point
                const benchmarks = {
                    'E-commerce': 0.28,
                    'SaaS': 0.36,
                    'Healthcare': 0.24,
                    'Financial Services': 0.32,
                    'Retail': 0.26,
                    'Manufacturing': 0.30,
                    'Professional Services': 0.30,
                    'Other': 0.30
                };
                return benchmarks[industry] || 0.30;
            };

            // Helper: Calculate CSAT monetary value based on configuration
            const calculateCSATValue = (config, csatPointsImprovement) => {
                if (!config || config.mode === 'non-monetary') {
                    return 0;
                }

                if (config.calculationMethod === 'retention_based') {
                    // User's custom retention rate per CSAT point
                    const retentionRate = (config.retentionImpactPerCSATPoint || 0.3) / 100; // e.g., 0.3% = 0.003
                    const customersRetained = (config.annualCustomers || 0) * retentionRate * csatPointsImprovement;
                    const annualValue = customersRetained * (config.avgCustomerValue || 0);

                    // Attribution: spread annual value over specified months
                    const attributionMonths = config.attributionMonths || 12;
                    const monthlyValue = annualValue / attributionMonths;

                    return monthlyValue;
                } else if (config.calculationMethod === 'fixed_value') {
                    // User provided total annual value per CSAT point
                    const attributionMonths = config.attributionMonths || 12;
                    const valuePerPoint = (config.fixedAnnualValuePerCSATPoint || 0) / attributionMonths;
                    return valuePerPoint * csatPointsImprovement;
                }

                return 0;
            };

            // Helper: Calculate required sample size for NPS statistical validity
            // Using standard formula: n = (Z^2 * p * (1-p)) / E^2
            // Z = 1.96 for 95% confidence, E = margin of error (typically 5%)
            const getRequiredNPSSampleSize = (population, confidenceLevel = 95, marginOfError = 5) => {
                const Z = confidenceLevel === 95 ? 1.96 : 2.58; // 95% or 99%
                const p = 0.5; // Maximum variability (worst case)
                const e = marginOfError / 100;

                const numerator = (Z * Z * p * (1 - p));
                const denominator = e * e;

                let sampleSize = numerator / denominator;

                // Finite population correction
                if (population && population > 0) {
                    sampleSize = sampleSize / (1 + ((sampleSize - 1) / population));
                }

                return Math.ceil(sampleSize);
            };

            // Helper: Check if NPS sample size is statistically valid
            const getNPSSampleValidation = (sampleSize, population) => {
                if (!sampleSize || sampleSize === 0) {
                    return { valid: false, message: 'No sample size provided', color: 'gray' };
                }

                const required = getRequiredNPSSampleSize(population, 95, 5);
                const percentage = population > 0 ? (sampleSize / population * 100) : 0;

                if (sampleSize >= required) {
                    return {
                        valid: true,
                        message: `‚úì Valid sample (${sampleSize} ‚â• ${required} required for 95% confidence)`,
                        color: 'green'
                    };
                } else if (sampleSize >= required * 0.7) {
                    return {
                        valid: 'partial',
                        message: `‚ö† Acceptable sample (${sampleSize} of ${required} needed for 95% confidence)`,
                        color: 'yellow'
                    };
                } else {
                    return {
                        valid: false,
                        message: `‚úó Small sample (${sampleSize} < ${required} needed for statistical validity)`,
                        color: 'red'
                    };
                }
            };

            // Helper: return the volume used for a specific benefit in a given month
            const getBenefitVolumeValue = (useCaseOrNormalized, monthData, benefit, benefitIndex = 0) => {
                const normalizedUC = (useCaseOrNormalized && useCaseOrNormalized.benefits)
                    ? useCaseOrNormalized
                    : ensureUseCaseHasBenefits(useCaseOrNormalized);
                const key = (normalizedUC.benefits?.length === 1)
                    ? `volume_${benefit.metric}`
                    : `volume_${benefitIndex}_${benefit.metric}`;
                const v = parseFloat(monthData?.[key]);
                if (!isNaN(v)) return v;
                const generic = parseFloat(monthData?.volume);
                return isNaN(generic) ? 0 : generic;
            };

            // Helper: total volume for a use case in a given month (sums benefit-specific volumes; falls back to generic volume)
            const getTotalVolumeForUseCaseMonth = (useCaseOrNormalized, monthData) => {
                const normalizedUC = (useCaseOrNormalized && useCaseOrNormalized.benefits)
                    ? useCaseOrNormalized
                    : ensureUseCaseHasBenefits(useCaseOrNormalized);
                let found = false;
                let total = 0;
                (normalizedUC.benefits || []).forEach((benefit, i) => {
                    const key = (normalizedUC.benefits.length === 1)
                        ? `volume_${benefit.metric}`
                        : `volume_${i}_${benefit.metric}`;
                    if (monthData && monthData[key] !== undefined && monthData[key] !== null && monthData[key] !== '') {
                        total += parseFloat(monthData[key]) || 0;
                        found = true;
                    }
                });
                if (!found) total += parseFloat(monthData?.volume) || 0;
                return total;
            };
            
            // Helper function to get effective metric value (with hierarchy: Special Group > Category > Global)
            const getEffectiveMetricValue = (metricKey, useCase) => {
                // First check if special group has an override
                if (useCase.specialGroup && categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    const channelData = categoryData[useCase.channel];
                    if (channelData && channelData._specialGroups && channelData._specialGroups[useCase.specialGroup]) {
                        const specialGroupData = channelData._specialGroups[useCase.specialGroup];
                        if (specialGroupData.metricValues && specialGroupData.metricValues[metricKey]) {
                            return specialGroupData.metricValues[metricKey].value;
                        }
                    }
                }
                
                // Then check if category has an override
                if (categoryCosts[useCase.category] && categoryCosts[useCase.category].metricValues && 
                    categoryCosts[useCase.category].metricValues[metricKey]) {
                    return categoryCosts[useCase.category].metricValues[metricKey].value;
                }
                
                // No global default - must be configured at category level
                return 0;
            };
            
            // Migration function to convert old category structure to new category-channel structure
            const migrateCategoryCosts = () => {
                const newCategoryCosts = {};
                let migrationApplied = false;
                
                Object.entries(categoryCosts).forEach(([category, data]) => {
                    // Check if it's already in new format (has channel keys or _default)
                    if (data._default || Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))) {
                        // Already in new format, keep as is
                        newCategoryCosts[category] = data;
                    } else {
                        // Old format, migrate to new format
                        newCategoryCosts[category] = {
                            _default: {
                                costType: data.costType,
                                value: data.value,
                                ahtMinutes: data.ahtMinutes
                            }
                        };
                        migrationApplied = true;
                    }
                });
                
                if (migrationApplied) {
                    setCategoryCosts(newCategoryCosts);
                    alert(`Migration completed! ${Object.keys(categoryCosts).length} categories converted to new category-channel structure. You can now set different costs per channel for each category.`);
                } else {
                    alert('No migration needed - your data is already in the new category-channel format.');
                }
            };
            
            // Check if migration is needed
            const needsMigration = () => {
                return Object.values(categoryCosts).some(data => 
                    data.costType && !data._default && !Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))
                );
            };
            
            // Helper function to get all available channels (from single source of truth)
            const getUniqueChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };
            
            // Helper function to add a new channel-specific cost for a category
            const addChannelCostToCategory = (category, channel, costData) => {
                setCategoryCosts(prev => ({
                    ...prev,
                    [category]: {
                        ...prev[category],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a category
            const removeChannelCostFromCategory = (category, channel) => {
                setCategoryCosts(prev => {
                    const newCategoryData = { ...prev[category] };
                    delete newCategoryData[channel];
                    return {
                        ...prev,
                        [category]: newCategoryData
                    };
                });
            };
            
            // Helper function to add a new channel-specific cost for a special group
            const addChannelCostToSpecialGroup = (group, channel, costData) => {
                setSpecialGroups(prev => ({
                    ...prev,
                    [group]: {
                        ...prev[group],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a special group
            const removeChannelCostFromSpecialGroup = (group, channel) => {
                setSpecialGroups(prev => {
                    const newGroupData = { ...prev[group] };
                    delete newGroupData[channel];
                    return {
                        ...prev,
                        [group]: newGroupData
                    };
                });
            };
            

            // Calculate savings for a single benefit using centralized metric config
            const calculateBenefitSavings = (useCase, benefit, monthData, benefitIndex = 0) => {
                const normalizedUC = ensureUseCaseHasBenefits(useCase);

                // Get metric configuration
                const metricConfig = METRIC_CONFIG[benefit.metric];
                if (!metricConfig) {
                    console.warn(`No configuration found for metric: ${benefit.metric}`);
                    return 0;
                }

                // IMPORTANT: Find the ORIGINAL index of this benefit in the full benefits array
                // benefitIndex might be from a filtered array, but data fields use original indices
                const originalIndex = normalizedUC.benefits.findIndex(b => b.metric === benefit.metric);
                const actualIndex = originalIndex >= 0 ? originalIndex : benefitIndex;

                // Get benefit-specific volume or fall back to general volume
                const volumeFieldKey = normalizedUC.benefits.length === 1
                    ? `volume_${benefit.metric}`
                    : `volume_${actualIndex}_${benefit.metric}`;
                const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;

                const fieldKey = normalizedUC.benefits.length === 1
                    ? `improvement_${benefit.metric}`
                    : `improvement_${actualIndex}_${benefit.metric}`;
                const improvement = parseFloat(monthData[fieldKey]) || 0;
                const baseline = parseFloat(benefit.baselineValue) || 0;

                // Calculate net improvement
                // For inverse metrics (like AHT where lower = better), use baseline - improvement
                // For normal metrics (like Deflection where higher = better), use improvement - baseline
                let netImprovement;
                if (metricConfig.inverseMetric) {
                    // AHT: baseline is current AHT, improvement is target AHT
                    // Reduction = current - target (e.g., 12 min - 10 min = 2 min saved)
                    netImprovement = Math.max(0, baseline - improvement);
                } else {
                    // Normal metrics: improvement - baseline
                    netImprovement = Math.max(0, improvement - baseline);
                }
                
                // Calculate based on metric type from configuration
                switch (metricConfig.type) {
                    case 'time_cost': {
                        // AHT Reduction calculation
                        const costConfig = getCostConfiguration(useCase);
                        
                        // For per-contact costs, handle based on negotiation mode
                        if (costConfig && costConfig.costType === 'perContact') {
                            if (ahtNegotiationMode) {
                                // Calculate what the new per-contact cost SHOULD be
                                // This helps in contract negotiations
                                const originalAHT = Math.max(0.01, parseFloat(getApplicableAHT(useCase)) || 10);
                                const newAHT = Math.max(0.01, originalAHT - netImprovement);
                                const reductionRatio = newAHT / originalAHT;
                                const currentCost = getEffectiveCost(useCase, useCase.channel);
                                const suggestedNewCost = currentCost * reductionRatio;
                                const savingsPerContact = currentCost - suggestedNewCost;
                                return volume * savingsPerContact;
                            } else {
                                // Standard mode: no savings for per-contact billing
                                return 0;
                            }
                        }
                        
                        // For hourly costs, AHT reductions always save money
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const aht = Math.max(0.01, parseFloat(getApplicableAHT(useCase)) || 10);
                        const costPerMinute = effectiveCost / aht;
                        const cappedMinutes = Math.min(netImprovement, aht);
                        return volume * cappedMinutes * costPerMinute;
                    }
                    
                    case 'percentage_cost': {
                        // Deflection, Automation, Resolution, Transfer Rate calculations
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        return volume * (pct / 100) * effectiveCost;
                    }
                    
                    case 'fcr_special': {
                        // FCR with repeat call factor
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        const repeatCallFactor = metricConfig.repeatCallFactor || 0.3;
                        return volume * (pct / 100) * effectiveCost * repeatCallFactor;
                    }
                    
                    case 'points_value': {
                        // NPS points-based calculation
                        const config = getCategoryMetricConfig(useCase.category, metricConfig.metricKey);

                        // Check if user has configured NPS mode
                        if (config) {
                            if (config.mode === 'non-monetary') {
                                // Return 0 for financial calculations, tracked separately
                                return 0;
                            }

                            // Monetary mode - calculate value based on retention or fixed value
                            // NOTE: Volume is NOT used - NPS improvement affects entire customer base
                            // Volume field is just for tracking survey count
                            return calculateNPSValue(config, netImprovement);
                        }

                        // Backward compatibility: Use legacy per-point value if no config exists
                        const legacyValue = getEffectiveMetricValue(metricConfig.metricKey, useCase);
                        return volume * netImprovement * legacyValue;
                    }
                    
                    case 'percentage_value': {
                        // CSAT, Conversion, Agent Retention, Compliance percentage-based calculations

                        // Special handling for CSAT improvement (similar to NPS)
                        if (metricConfig.metricKey === 'csatImprovement') {
                            const config = getCategoryMetricConfig(useCase.category, metricConfig.metricKey);

                            // Check if user has configured CSAT mode
                            if (config) {
                                if (config.mode === 'non-monetary') {
                                    // Return 0 for financial calculations, tracked separately
                                    return 0;
                                }

                                // Monetary mode - calculate value based on retention or fixed value
                                // NOTE: netImprovement for CSAT is in percentage points (e.g., 5% = 5)
                                // But CSAT is typically on 1-5 scale, so we need to convert
                                // If user enters CSAT as percentage (0-100), use as-is
                                // If user enters CSAT as points (1-5), convert to percentage
                                // For simplicity, assume percentage input and convert to points
                                const csatPoints = netImprovement / 20; // 100% = 5 points, so 20% = 1 point
                                return calculateCSATValue(config, csatPoints);
                            } else {
                                // No config - use default CSAT config for this category
                                const defaultConfig = getDefaultCSATConfig();
                                if (defaultConfig.mode === 'non-monetary') {
                                    return 0;
                                }
                                const csatPoints = netImprovement / 20;
                                return calculateCSATValue(defaultConfig, csatPoints);
                            }
                        }

                        // Standard percentage-based calculation for other metrics
                        const value = getEffectiveMetricValue(metricConfig.metricKey, useCase);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        return volume * (pct / 100) * value;
                    }
                    
                    default:
                        console.warn(`Unknown metric type: ${metricConfig.type} for metric: ${benefit.metric}`);
                        return 0;
                }
            };

            // Calculate total savings for a use case (sum of all benefits)
            const calculateSavings = (useCase, monthId) => {
                // Ensure backward compatibility
                const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                const monthData = normalizedUseCase.data[monthId] || {};

                let totalSavings = 0;

                // Sum savings from filtered benefits (respects metric filter)
                const filteredBenefits = getFilteredBenefits(useCase);
                filteredBenefits.forEach((benefit, filteredIndex) => {
                    // Find original index for correct data field access
                    const originalIndex = normalizedUseCase.benefits.findIndex(b => b.metric === benefit.metric);
                    const actualIndex = originalIndex >= 0 ? originalIndex : filteredIndex;
                    totalSavings += calculateBenefitSavings(normalizedUseCase, benefit, monthData, actualIndex);
                });

                return totalSavings;
            };
            
            // New function to get detailed savings breakdown by benefit
            const calculateSavingsBreakdown = (useCase, monthId) => {
                const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                const monthData = normalizedUseCase.data[monthId] || {};

                const breakdown = [];
                let totalSavings = 0;

                // Use filtered benefits (respects metric filter)
                const filteredBenefits = getFilteredBenefits(useCase);
                filteredBenefits.forEach((benefit, filteredIndex) => {
                    // Find original index for correct data field access
                    const originalIndex = normalizedUseCase.benefits.findIndex(b => b.metric === benefit.metric);
                    const actualIndex = originalIndex >= 0 ? originalIndex : filteredIndex;
                    const savings = calculateBenefitSavings(normalizedUseCase, benefit, monthData, actualIndex);
                    totalSavings += savings;
                    breakdown.push({
                        metric: benefit.metric,
                        savings: savings,
                        percentage: 0 // Will calculate after total
                    });
                });

                // Calculate percentages
                breakdown.forEach(item => {
                    item.percentage = totalSavings > 0 ? (item.savings / totalSavings * 100) : 0;
                });

                return {
                    total: totalSavings,
                    breakdown: breakdown
                };
            };

            // Check if there are AHT reductions with per-contact billing
            const hasAHTWithPerContactBilling = () => {
                return useCases.some(uc => {
                    const costConfig = getCostConfiguration(uc);
                    if (costConfig && costConfig.costType === 'perContact') {
                        // Check if this use case has AHT reduction benefits
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        return normalizedUC.benefits.some(b => b.metric === 'AHT Reduction (min)');
                    }
                    return false;
                });
            };
            
            const calculateTotalSavings = () => {
                let total = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();

                filteredUseCases.forEach(uc => {
                    filteredMonths.forEach(month => {
                        total += calculateSavings(uc, month.id);
                    });
                });
                return total;
            };

            // Calculate savings breakdown by value type (savings vs revenue)
            const calculateSavingsBreakdownByType = () => {
                let savings = 0;
                let revenue = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();

                filteredUseCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    const filteredBenefits = getFilteredBenefits(uc);

                    filteredMonths.forEach(month => {
                        const monthData = normalizedUC.data[month.id] || {};

                        filteredBenefits.forEach((benefit, benefitIndex) => {
                            const metricConfig = METRIC_CONFIG[benefit.metric];
                            if (metricConfig) {
                                const benefitSavings = calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);

                                if (metricConfig.valueType === 'revenue') {
                                    revenue += benefitSavings;
                                } else {
                                    savings += benefitSavings;
                                }
                            }
                        });
                    });
                });

                return { savings, revenue, total: savings + revenue };
            };

            // Calculate only cost savings (excludes revenue-generating metrics)
            const calculateCostSavings = () => {
                const breakdown = calculateSavingsBreakdownByType();
                return breakdown.savings;
            };

            // Calculate only revenue impact (from revenue-generating metrics)
            const calculateRevenueImpact = () => {
                const breakdown = calculateSavingsBreakdownByType();
                return breakdown.revenue;
            };

            // Calculate average NPS improvement points (weighted by survey volume)
            const calculateAvgNPS = () => {
                let weightedSum = 0;
                let totalVolume = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();

                filteredUseCases.forEach(uc => {
                    const filteredBenefits = getFilteredBenefits(uc);
                    filteredBenefits.forEach((benefit, benefitIndex) => {
                        if (benefit.metric.includes('NPS')) {
                            filteredMonths.forEach(month => {
                                const monthData = uc.data[month.id] || {};
                                const nonMon = calculateNonMonetaryBenefits(uc, benefit, monthData, benefitIndex);
                                if (nonMon && nonMon.totalImpact > 0) {
                                    // Weighted average: sum of (improvement √ó volume) / sum of volumes
                                    weightedSum += nonMon.improvement * nonMon.volume;
                                    totalVolume += nonMon.volume;
                                }
                            });
                        }
                    });
                });

                return totalVolume > 0 ? weightedSum / totalVolume : 0;
            };

            // Calculate average CSAT improvement percentage (weighted by survey volume)
            const calculateAvgCSAT = () => {
                let weightedSum = 0;
                let totalVolume = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();

                filteredUseCases.forEach(uc => {
                    const filteredBenefits = getFilteredBenefits(uc);
                    filteredBenefits.forEach((benefit, benefitIndex) => {
                        if (benefit.metric.includes('CSAT')) {
                            filteredMonths.forEach(month => {
                                const monthData = uc.data[month.id] || {};
                                const nonMon = calculateNonMonetaryBenefits(uc, benefit, monthData, benefitIndex);
                                if (nonMon && nonMon.totalImpact > 0) {
                                    // Weighted average: sum of (improvement √ó volume) / sum of volumes
                                    weightedSum += nonMon.improvement * nonMon.volume;
                                    totalVolume += nonMon.volume;
                                }
                            });
                        }
                    });
                });

                return totalVolume > 0 ? weightedSum / totalVolume : 0;
            };

            // Financial Analysis Functions (NPV, IRR, Payback Period)
            const calculateNPV = (cashFlows, discountRate = 0.10) => {
                return cashFlows.reduce((npv, cf, index) => {
                    return npv + cf / Math.pow(1 + discountRate / 12, index); // Monthly discount rate
                }, 0);
            };

            const calculateIRR = (cashFlows, guess = 0.1) => {
                const maxIterations = 100;
                const tolerance = 1e-6;
                let rate = guess;
                
                // Newton-Raphson method
                for (let i = 0; i < maxIterations; i++) {
                    let npv = 0;
                    let dnpv = 0;
                    
                    for (let t = 0; t < cashFlows.length; t++) {
                        const pv = Math.pow(1 + rate, -t);
                        npv += cashFlows[t] * pv;
                        dnpv -= t * cashFlows[t] * pv / (1 + rate);
                    }
                    
                    if (Math.abs(npv) < tolerance) {
                        return rate * 12; // Convert to annual rate
                    }
                    
                    if (Math.abs(dnpv) < tolerance) {
                        // Fallback to bisection if derivative is too small
                        return calculateIRRBisection(cashFlows);
                    }
                    
                    const newRate = rate - npv / dnpv;
                    
                    // Bounds checking
                    if (newRate < -0.99) {
                        return calculateIRRBisection(cashFlows);
                    }
                    if (newRate > 10) {
                        return calculateIRRBisection(cashFlows);
                    }
                    
                    rate = newRate;
                }
                
                // If Newton-Raphson doesn't converge, use bisection
                return calculateIRRBisection(cashFlows);
            };

            const calculateIRRBisection = (cashFlows) => {
                let lower = -0.99;
                let upper = 10;
                const tolerance = 1e-6;
                const maxIterations = 100;
                
                for (let i = 0; i < maxIterations; i++) {
                    const mid = (lower + upper) / 2;
                    const npv = cashFlows.reduce((sum, cf, t) => {
                        return sum + cf / Math.pow(1 + mid, t);
                    }, 0);
                    
                    if (Math.abs(npv) < tolerance) {
                        return mid * 12; // Convert to annual rate
                    }
                    
                    if (npv > 0) {
                        lower = mid;
                    } else {
                        upper = mid;
                    }
                }
                
                return ((lower + upper) / 2) * 12; // Convert to annual rate
            };

            // Calculate payback period in months
            const calculatePaybackPeriod = (cashFlows) => {
                let cumulative = 0;
                for (let i = 0; i < cashFlows.length; i++) {
                    cumulative += cashFlows[i];
                    if (cumulative >= 0) {
                        if (i === 0) {
                            // If positive from the start, payback is immediate
                            if (cashFlows[0] >= 0) return 0.01; // Return small positive number instead of 0
                            // Otherwise calculate fraction of first month
                            return -cashFlows[0] / (cumulative);
                        }
                        // Linear interpolation for fractional months
                        const prevCumulative = cumulative - cashFlows[i];
                        const fraction = -prevCumulative / cashFlows[i];
                        return i - 1 + fraction;
                    }
                }
                return null; // No payback within the period
            };

            // Helper to get billing cycle months
            const getBillingCycleMonths = (billingCycle, customMonths) => {
                switch (billingCycle) {
                    case 'monthly': return 1;
                    case 'quarterly': return 3;
                    case 'semiannual': return 6;
                    case 'annual': return 12;
                    case 'custom': return customMonths || 6;
                    default: return 1;
                }
            };

            // Generate cash flow array from monthly savings
            const generateCashFlows = (implementationCost = 0, ongoingMonthlyCost = 0) => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                
                // Initialize cash flows array
                const cashFlows = [];
                
                // If using category-specific billing, track costs by category
                if (financialSettings.useCategoryBilling) {
                    // Track implementation costs by month for each category
                    const implementationByMonth = {};
                    const ongoingByMonth = {};
                    
                    // Only include costs for categories that have filtered use cases
                    const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                    
                    // Calculate category-specific costs
                    activeCategories.forEach(category => {
                        const catSettings = financialSettings.categoryBilling?.[category];
                        if (catSettings) {
                            const implMonth = catSettings.implementationMonth || 0;
                            if (!implementationByMonth[implMonth]) {
                                implementationByMonth[implMonth] = 0;
                            }
                            implementationByMonth[implMonth] += catSettings.implementationCost || 0;
                            
                            // Calculate ongoing costs based on billing cycle
                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                            const monthlyCost = catSettings.ongoingCostMonthly || 0;
                            
                            // Apply ongoing costs at appropriate intervals
                            for (let i = 0; i < filteredMonths.length; i++) {
                                if (i > implMonth && ((i - implMonth - 1) % cycleMonths === 0)) {
                                    if (!ongoingByMonth[i]) {
                                        ongoingByMonth[i] = 0;
                                    }
                                    // Charge for the entire cycle at once
                                    ongoingByMonth[i] += monthlyCost * cycleMonths;
                                }
                            }
                        }
                    });
                    
                    // Build cash flows with category-specific costs
                    // Align with Excel: each month includes its benefits and costs
                    filteredMonths.forEach((month, i) => {
                        let cashFlow = 0;
                        let monthlyBenefit = 0;
                        
                        // Add benefits for this month
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, month.id);
                        });
                        cashFlow = monthlyBenefit;
                        
                        // Subtract implementation costs for this month
                        if (implementationByMonth[i]) {
                            cashFlow -= implementationByMonth[i];
                        }
                        
                        // Subtract ongoing costs for this month
                        if (ongoingByMonth[i]) {
                            cashFlow -= ongoingByMonth[i];
                        }
                        
                        cashFlows.push(cashFlow);
                    });
                } else {
                    // Use simple overall implementation cost with billing cycle support
                    // Get billing cycle for non-category mode
                    const cycleMonths = getBillingCycleMonths(
                        financialSettings.billingCycle || 'monthly',
                        financialSettings.customMonths
                    );
                    
                    // Align with Excel: combine implementation cost with first month's benefits
                    filteredMonths.forEach((month, index) => {
                        let monthTotal = 0;
                        filteredUseCases.forEach(uc => {
                            monthTotal += calculateSavings(uc, month.id);
                        });
                        
                        // Add implementation cost to first month (index 0)
                        let implCost = 0;
                        if (index === 0) {
                            implCost = implementationCost;
                        }
                        
                        // Apply ongoing costs based on billing cycle (starting from month 1, not month 0)
                        let ongoingCost = 0;
                        if (ongoingMonthlyCost > 0 && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = ongoingMonthlyCost * cycleMonths;
                        }
                        
                        cashFlows.push(monthTotal - implCost - ongoingCost);
                    });
                }
                
                return cashFlows;
            };

            // Calculate totals by metric type for analytics
            const calculateTotalSavingsByMetricType = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                const metricTypes = getAvailableMetricTypes();
                const totals = {};
                
                // Initialize totals
                metricTypes.forEach(type => {
                    totals[type] = { total: 0, count: 0 };
                });
                
                filteredUseCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        const metricType = getMetricTypeForMetric(benefit.metric);
                        totals[metricType].count++;
                        
                        filteredMonths.forEach(month => {
                            const monthData = normalizedUC.data[month.id] || {};
                            totals[metricType].total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                        });
                    });
                });
                
                return totals;
            };

            // Get metric type breakdown for charts
            const getMetricTypeBreakdown = () => {
                const totals = calculateTotalSavingsByMetricType();
                
                return Object.entries(totals)
                    .filter(([type, data]) => data.total > 0)
                    .map(([type, data]) => ({
                        label: type,
                        value: Math.round(data.total),
                        count: data.count
                    }));
            };

            // Get filtered months for analytics
            const getFilteredMonths = () => {
                if (activeTab === 'analytics' && analyticsDateRange) {
                    return generateMonthsFromRange(analyticsDateRange.start, analyticsDateRange.end);
                }
                return months;
            };

            // Get filtered use cases based on current view
            const getFilteredUseCases = () => {
                let filtered = useCases;
                
                // Category filter
                if (selectedCategory !== 'all') {
                    filtered = filtered.filter(uc => uc.category === selectedCategory);
                }
                
                // Channel filter
                if (selectedChannel !== 'all') {
                    filtered = filtered.filter(uc => uc.channel === selectedChannel);
                }
                
                // Special Group filter
                if (selectedSpecialGroup !== null) {
                    if (selectedSpecialGroup === 'none') {
                        filtered = filtered.filter(uc => !uc.specialGroup);
                    } else {
                        filtered = filtered.filter(uc => uc.specialGroup === selectedSpecialGroup);
                    }
                }

                // Use Case filter
                if (selectedUseCase !== null) {
                    filtered = filtered.filter(uc => uc.name === selectedUseCase);
                }

                // Metric filter
                if (selectedMetric !== null) {
                    filtered = filtered.filter(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        return normalizedUC.benefits.some(benefit => benefit.metric === selectedMetric);
                    });
                }

                return filtered;
            };

            // Get filtered benefits for a use case (respects metric filter)
            const getFilteredBenefits = (useCase) => {
                const normalizedUC = ensureUseCaseHasBenefits(useCase);

                // If metric filter is active, only return that specific benefit
                if (selectedMetric !== null) {
                    return normalizedUC.benefits.filter(benefit => benefit.metric === selectedMetric);
                }

                // Otherwise return all benefits
                return normalizedUC.benefits;
            };

            // Get unique categories
            const getCategories = () => {
                const categories = new Set(useCases.map(uc => uc.category));
                return Array.from(categories);
            };

            // Get unique channels for analytics (all channels always available)
            const getChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };

            // Chart data preparation
            const getMonthlyTrendData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(monthTotal)
                    };
                });
            };

            // Enhanced monthly trend data with metric type breakdown
            const getEnhancedMonthlyTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const metricTypes = getAvailableMetricTypes();
                
                const datasets = [];
                
                // Add total line
                const totalData = filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    return Math.round(monthTotal);
                });
                
                datasets.push({
                    label: 'Total Value',
                    data: totalData,
                    borderColor: '#1F2937',
                    backgroundColor: 'rgba(31, 41, 55, 0.1)',
                    tension: 0.4,
                    borderWidth: 3,
                    fill: false
                });
                
                // Add lines for each metric type
                metricTypes.forEach(metricType => {
                    const data = filteredMonths.map(month => {
                        let total = 0;
                        filteredUseCases.forEach(uc => {
                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                            const filteredBenefits = getFilteredBenefits(uc);
                            const monthData = normalizedUC.data[month.id] || {};

                            filteredBenefits.forEach((benefit, benefitIndex) => {
                                if (getMetricTypeForMetric(benefit.metric) === metricType) {
                                    total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                }
                            });
                        });
                        return Math.round(total);
                    });
                    
                    // Only add if there's data for this metric type
                    if (data.some(value => value > 0)) {
                        const colors = {
                            'Cost Savings': '#3B82F6',
                            'Quality Improvement': '#10B981', 
                            'Revenue Generation': '#F59E0B',
                            'Cost Avoidance': '#EF4444',
                            'Risk Reduction': '#8B5CF6'
                        };
                        
                        datasets.push({
                            label: metricType,
                            data,
                            borderColor: colors[metricType] || '#6B7280',
                            backgroundColor: (colors[metricType] || '#6B7280') + '20',
                            tension: 0.4,
                            fill: false
                        });
                    }
                });
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets
                };
            };

            const getCumulativeData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                let cumulative = 0;
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    cumulative += monthTotal;
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(cumulative)
                    };
                });
            };

            const getCategoryBreakdown = () => {
                const categories = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!categories[uc.category]) {
                        categories[uc.category] = 0;
                    }
                    filteredMonths.forEach(month => {
                        categories[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(categories).map(([name, value]) => ({
                    label: name,
                    value: Math.round(value)
                }));
            };

            const getChannelBreakdown = () => {
                const channels = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!channels[uc.channel]) {
                        channels[uc.channel] = 0;
                    }
                    filteredMonths.forEach(month => {
                        channels[uc.channel] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(channels).map(([name, value]) => ({
                    label: name.charAt(0).toUpperCase() + name.slice(1),
                    value: Math.round(value)
                }));
            };

            // Get data for specific analytics views
            const getCategoryTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const categories = [...new Set(useCases.map(uc => uc.category))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: categories.map((cat, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.category === cat).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];
                        return {
                            label: cat,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getChannelTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const channels = [...new Set(useCases.map(uc => uc.channel))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: channels.map((ch, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.channel === ch).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444'];
                        return {
                            label: ch.charAt(0).toUpperCase() + ch.slice(1),
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getUseCaseTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const topUseCases = filteredUseCases
                    .map(uc => ({
                        ...uc,
                        total: filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0)
                    }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 5); // Top 5 use cases
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: topUseCases.map((uc, index) => {
                        const data = filteredMonths.map(month => calculateSavings(uc, month.id));
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        // Include category and special group in label
                        const labelParts = [uc.name];
                        if (uc.category) labelParts.push(`(${uc.category})`);
                        if (uc.specialGroup) labelParts.push(`[${uc.specialGroup}]`);
                        return {
                            label: labelParts.join(' '),
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getSpecialGroupTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const groups = [...new Set(useCases.map(uc => uc.specialGroup).filter(Boolean))];
                groups.push('No Special Group');
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: groups.map((group, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => (uc.specialGroup || 'No Special Group') === group).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        return {
                            label: group,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getMetricTypeTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const metricTypes = getAvailableMetricTypes();
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: metricTypes.map((metricType, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            filteredUseCases.forEach(uc => {
                                const normalizedUC = ensureUseCaseHasBenefits(uc);
                                const filteredBenefits = getFilteredBenefits(uc);
                                const monthData = normalizedUC.data[month.id] || {};

                                // Calculate savings only for benefits of this metric type
                                filteredBenefits.forEach((benefit, benefitIndex) => {
                                    if (getMetricTypeForMetric(benefit.metric) === metricType) {
                                        total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                    }
                                });
                            });
                            return Math.round(total);
                        });
                        
                        const colors = {
                            'Cost Savings': '#3B82F6',
                            'Quality Improvement': '#10B981', 
                            'Revenue Generation': '#F59E0B',
                            'Cost Avoidance': '#EF4444',
                            'Risk Reduction': '#8B5CF6'
                        };
                        
                        return {
                            label: metricType,
                            data,
                            borderColor: colors[metricType] || '#6B7280',
                            backgroundColor: (colors[metricType] || '#6B7280') + '20',
                            tension: 0.4
                        };
                    }).filter(dataset => dataset.data.some(value => value > 0)) // Only include metric types with data
                };
            };

            const getSavingsTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();

                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: [{
                        label: 'Cost Savings',
                        data: filteredMonths.map(month => {
                            let total = 0;
                            filteredUseCases.forEach(uc => {
                                const normalizedUC = ensureUseCaseHasBenefits(uc);
                                const filteredBenefits = getFilteredBenefits(uc);
                                const monthData = normalizedUC.data[month.id] || {};

                                filteredBenefits.forEach((benefit, benefitIndex) => {
                                    const metricConfig = METRIC_CONFIG[benefit.metric];
                                    if (metricConfig && metricConfig.valueType === 'savings') {
                                        total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                    }
                                });
                            });
                            return Math.round(total);
                        }),
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                };
            };

            const getRevenueTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();

                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: [{
                        label: 'Revenue Impact',
                        data: filteredMonths.map(month => {
                            let total = 0;
                            filteredUseCases.forEach(uc => {
                                const normalizedUC = ensureUseCaseHasBenefits(uc);
                                const filteredBenefits = getFilteredBenefits(uc);
                                const monthData = normalizedUC.data[month.id] || {};

                                filteredBenefits.forEach((benefit, benefitIndex) => {
                                    const metricConfig = METRIC_CONFIG[benefit.metric];
                                    if (metricConfig && metricConfig.valueType === 'revenue') {
                                        total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                    }
                                });
                            });
                            return Math.round(total);
                        }),
                        borderColor: '#10B981',
                        backgroundColor: 'rgba(16, 185, 129, 0.2)',
                        tension: 0.4,
                        fill: true
                    }]
                };
            };

            // Initialize charts
            useEffect(() => {
                if (activeTab === 'analytics' && window.Chart) {
                    // Destroy existing charts
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                    chartInstances.current = {};

                    if (analyticsView === 'overall') {
                        // Monthly Trend Chart
                        if (chartRefs.monthly.current) {
                            const monthlyData = getMonthlyTrendData();
                            const ctx = chartRefs.monthly.current.getContext('2d');
                            chartInstances.current.monthly = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: monthlyData.map(d => d.label),
                                    datasets: [{
                                        label: 'Monthly Savings',
                                        data: monthlyData.map(d => d.value),
                                        borderColor: '#3B82F6',
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Cumulative Chart
                        if (chartRefs.cumulative.current) {
                            const cumulativeData = getCumulativeData();
                            const ctx = chartRefs.cumulative.current.getContext('2d');
                            chartInstances.current.cumulative = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: cumulativeData.map(d => d.label),
                                    datasets: [{
                                        label: 'Cumulative Savings',
                                        data: cumulativeData.map(d => d.value),
                                        borderColor: '#10B981',
                                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Total: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Pie Chart
                        if (chartRefs.category.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.category.current.getContext('2d');
                                chartInstances.current.category = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: [
                                                '#3B82F6',
                                                '#10B981',
                                                '#F59E0B',
                                                '#EF4444',
                                                '#8B5CF6'
                                            ]
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Channel Bar Chart
                        if (chartRefs.channel.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channel.current.getContext('2d');
                                chartInstances.current.channel = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: '#8B5CF6'
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Savings Trend Chart
                        if (chartRefs.savingsTrend.current) {
                            const savingsData = getSavingsTrendData();
                            const ctx = chartRefs.savingsTrend.current.getContext('2d');
                            chartInstances.current.savingsTrend = new Chart(ctx, {
                                type: 'line',
                                data: savingsData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Cost Savings: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Revenue Trend Chart
                        if (chartRefs.revenueTrend.current) {
                            const revenueData = getRevenueTrendData();
                            const ctx = chartRefs.revenueTrend.current.getContext('2d');
                            chartInstances.current.revenueTrend = new Chart(ctx, {
                                type: 'line',
                                data: revenueData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Revenue Impact: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    } else if (analyticsView === 'category') {
                        // Category Trend Chart
                        if (chartRefs.categoryTrend.current) {
                            const trendData = getCategoryTrendData();
                            const ctx = chartRefs.categoryTrend.current.getContext('2d');
                            chartInstances.current.categoryTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Breakdown Chart
                        if (chartRefs.categoryBreakdown.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.categoryBreakdown.current.getContext('2d');
                                chartInstances.current.categoryBreakdown = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'channel') {
                        // Channel Trend Chart
                        if (chartRefs.channelTrend.current) {
                            const trendData = getChannelTrendData();
                            const ctx = chartRefs.channelTrend.current.getContext('2d');
                            chartInstances.current.channelTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Channel Breakdown Chart
                        if (chartRefs.channelBreakdown.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channelBreakdown.current.getContext('2d');
                                chartInstances.current.channelBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'usecase') {
                        // Use Case Trend Chart (Top 5)
                        if (chartRefs.usecaseTrend.current) {
                            const trendData = getUseCaseTrendData();
                            const ctx = chartRefs.usecaseTrend.current.getContext('2d');
                            chartInstances.current.usecaseTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Use Case Performance Bar Chart
                        if (chartRefs.usecaseBreakdown.current) {
                            const filteredMonths = getFilteredMonths();
                            const filteredUseCases = getFilteredUseCases();
                            const useCaseData = filteredUseCases.map(uc => {
                                const total = filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0);
                                // Include category/group in display name
                                let displayName = uc.name;
                                if (uc.specialGroup) displayName += ` [${uc.specialGroup}]`;
                                else if (uc.category) displayName += ` (${uc.category})`;
                                return { name: displayName, value: total, originalName: uc.name };
                            }).sort((a, b) => b.value - a.value).slice(0, 10);

                            if (useCaseData.length > 0) {
                                const ctx = chartRefs.usecaseBreakdown.current.getContext('2d');
                                chartInstances.current.usecaseBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: useCaseData.map(d => d.name),
                                        datasets: [{
                                            label: 'Use Case Savings',
                                            data: useCaseData.map(d => d.value),
                                            backgroundColor: '#3B82F6'
                                        }]
                                    },
                                    options: {
                                        indexAxis: 'y',
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            x: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.x.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'specialgroup') {
                        // Special Group Trend Chart
                        if (chartRefs.specialgroupTrend.current) {
                            const trendData = getSpecialGroupTrendData();
                            const ctx = chartRefs.specialgroupTrend.current.getContext('2d');
                            chartInstances.current.specialgroupTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Special Group Breakdown Chart
                        if (chartRefs.specialgroupBreakdown.current) {
                            const groupData = {};
                            const filteredMonths = getFilteredMonths();
                            getAllSpecialGroups().forEach(group => {
                                groupData[group] = 0;
                            });
                            groupData['No Special Group'] = 0;

                            useCases.forEach(uc => {
                                const key = uc.specialGroup || 'No Special Group';
                                // Initialize if key doesn't exist (for data consistency)
                                if (!(key in groupData)) {
                                    groupData[key] = 0;
                                }
                                filteredMonths.forEach(month => {
                                    groupData[key] += calculateSavings(uc, month.id);
                                });
                            });

                            const chartData = Object.entries(groupData)
                                .filter(([, value]) => value > 0)
                                .map(([name, value]) => ({ label: name, value }));

                            if (chartData.length > 0) {
                                const ctx = chartRefs.specialgroupBreakdown.current.getContext('2d');
                                chartInstances.current.specialgroupBreakdown = new Chart(ctx, {
                                    type: 'pie',
                                    data: {
                                        labels: chartData.map(d => d.label),
                                        datasets: [{
                                            data: chartData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }

                    // NPS & CSAT Charts (Non-Monetary Benefits) - Render on all analytics views
                    if (hasNonMonetaryBenefits()) {
                        const npsData = [];
                        const csatData = [];
                        const filteredUseCases = getFilteredUseCases();
                        const filteredMonths = getFilteredMonths();

                        filteredUseCases.forEach(uc => {
                            const normalized = ensureUseCaseHasBenefits(uc);
                            const filteredBenefits = getFilteredBenefits(uc);
                            filteredBenefits.forEach((benefit, benefitIndex) => {
                                filteredMonths.forEach(month => {
                                    const monthData = uc.data[month.id] || {};
                                    const nonMon = calculateNonMonetaryBenefits(uc, benefit, monthData, benefitIndex);
                                    if (nonMon && nonMon.totalImpact > 0) {
                                        const dataPoint = {
                                            ...nonMon,
                                            month,
                                            category: uc.category,
                                            channel: uc.channel,
                                            useCase: uc.name
                                        };

                                        // Separate NPS and CSAT data
                                        if (benefit.metric.includes('NPS')) {
                                            npsData.push(dataPoint);
                                        } else if (benefit.metric.includes('CSAT')) {
                                            csatData.push(dataPoint);
                                        }
                                    }
                                });
                            });
                        });

                        // NPS Charts
                        if (npsData.length > 0) {
                            // Group by month for trend chart
                            const npsMonthlyData = {};
                            npsData.forEach(d => {
                                if (!npsMonthlyData[d.month.id]) {
                                    npsMonthlyData[d.month.id] = { surveys: 0, totalImpact: 0 };
                                }
                                npsMonthlyData[d.month.id].surveys += d.volume;
                                npsMonthlyData[d.month.id].totalImpact += d.totalImpact;
                            });

                            // Group by category
                            const npsCategoryData = {};
                            npsData.forEach(d => {
                                if (!npsCategoryData[d.category]) {
                                    npsCategoryData[d.category] = { surveys: 0, totalImpact: 0 };
                                }
                                npsCategoryData[d.category].surveys += d.volume;
                                npsCategoryData[d.category].totalImpact += d.totalImpact;
                            });

                            // Group by channel
                            const npsChannelData = {};
                            npsData.forEach(d => {
                                if (!npsChannelData[d.channel]) {
                                    npsChannelData[d.channel] = { surveys: 0, totalImpact: 0 };
                                }
                                npsChannelData[d.channel].surveys += d.volume;
                                npsChannelData[d.channel].totalImpact += d.totalImpact;
                            });

                            // NPS Trend Chart
                            if (chartRefs.npsTrend.current) {
                                const sortedMonths = Object.keys(npsMonthlyData).sort();
                                const ctx = chartRefs.npsTrend.current.getContext('2d');
                                chartInstances.current.npsTrend = new Chart(ctx, {
                                    type: 'line',
                                    data: {
                                        labels: sortedMonths.map(m => {
                                            const [y, mo] = m.split('-');
                                            return new Date(y, mo - 1).toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                        }),
                                        datasets: [{
                                            label: 'Avg NPS Points',
                                            data: sortedMonths.map(m => npsMonthlyData[m].totalImpact / npsMonthlyData[m].surveys),
                                            borderColor: 'rgb(147, 51, 234)',
                                            backgroundColor: 'rgba(147, 51, 234, 0.1)',
                                            tension: 0.4,
                                            fill: true
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'NPS Points' }
                                            }
                                        }
                                    }
                                });
                            }

                            // NPS Category Chart
                            if (chartRefs.npsCategory.current) {
                                const ctx = chartRefs.npsCategory.current.getContext('2d');
                                chartInstances.current.npsCategory = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: Object.keys(npsCategoryData),
                                        datasets: [{
                                            label: 'Avg NPS Points',
                                            data: Object.keys(npsCategoryData).map(cat =>
                                                npsCategoryData[cat].totalImpact / npsCategoryData[cat].surveys
                                            ),
                                            backgroundColor: 'rgba(59, 130, 246, 0.6)',
                                            borderColor: 'rgb(59, 130, 246)',
                                            borderWidth: 1
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'Avg NPS Points' }
                                            }
                                        }
                                    }
                                });
                            }

                            // NPS Channel Chart
                            if (chartRefs.npsChannel.current) {
                                const ctx = chartRefs.npsChannel.current.getContext('2d');
                                chartInstances.current.npsChannel = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: Object.keys(npsChannelData),
                                        datasets: [{
                                            label: 'Avg NPS Points',
                                            data: Object.keys(npsChannelData).map(ch =>
                                                npsChannelData[ch].totalImpact / npsChannelData[ch].surveys
                                            ),
                                            backgroundColor: 'rgba(16, 185, 129, 0.6)',
                                            borderColor: 'rgb(16, 185, 129)',
                                            borderWidth: 1
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        indexAxis: 'y',
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            x: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'Avg NPS Points' }
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // CSAT Charts
                        if (csatData.length > 0) {
                            // Group by month for trend chart
                            const csatMonthlyData = {};
                            csatData.forEach(d => {
                                if (!csatMonthlyData[d.month.id]) {
                                    csatMonthlyData[d.month.id] = { surveys: 0, totalImpact: 0 };
                                }
                                csatMonthlyData[d.month.id].surveys += d.volume;
                                csatMonthlyData[d.month.id].totalImpact += d.totalImpact;
                            });

                            // Group by category
                            const csatCategoryData = {};
                            csatData.forEach(d => {
                                if (!csatCategoryData[d.category]) {
                                    csatCategoryData[d.category] = { surveys: 0, totalImpact: 0 };
                                }
                                csatCategoryData[d.category].surveys += d.volume;
                                csatCategoryData[d.category].totalImpact += d.totalImpact;
                            });

                            // Group by channel
                            const csatChannelData = {};
                            csatData.forEach(d => {
                                if (!csatChannelData[d.channel]) {
                                    csatChannelData[d.channel] = { surveys: 0, totalImpact: 0 };
                                }
                                csatChannelData[d.channel].surveys += d.volume;
                                csatChannelData[d.channel].totalImpact += d.totalImpact;
                            });

                            // CSAT Trend Chart
                            if (chartRefs.csatTrend.current) {
                                const sortedMonths = Object.keys(csatMonthlyData).sort();
                                const ctx = chartRefs.csatTrend.current.getContext('2d');
                                chartInstances.current.csatTrend = new Chart(ctx, {
                                    type: 'line',
                                    data: {
                                        labels: sortedMonths.map(m => {
                                            const [y, mo] = m.split('-');
                                            return new Date(y, mo - 1).toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                        }),
                                        datasets: [{
                                            label: 'Avg CSAT Points',
                                            data: sortedMonths.map(m => csatMonthlyData[m].totalImpact / csatMonthlyData[m].surveys),
                                            borderColor: 'rgb(251, 146, 60)',
                                            backgroundColor: 'rgba(251, 146, 60, 0.1)',
                                            tension: 0.4,
                                            fill: true
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'CSAT Points' }
                                            }
                                        }
                                    }
                                });
                            }

                            // CSAT Category Chart
                            if (chartRefs.csatCategory.current) {
                                const ctx = chartRefs.csatCategory.current.getContext('2d');
                                chartInstances.current.csatCategory = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: Object.keys(csatCategoryData),
                                        datasets: [{
                                            label: 'Avg CSAT Points',
                                            data: Object.keys(csatCategoryData).map(cat =>
                                                csatCategoryData[cat].totalImpact / csatCategoryData[cat].surveys
                                            ),
                                            backgroundColor: 'rgba(245, 158, 11, 0.6)',
                                            borderColor: 'rgb(245, 158, 11)',
                                            borderWidth: 1
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'Avg CSAT Points' }
                                            }
                                        }
                                    }
                                });
                            }

                            // CSAT Channel Chart
                            if (chartRefs.csatChannel.current) {
                                const ctx = chartRefs.csatChannel.current.getContext('2d');
                                chartInstances.current.csatChannel = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: Object.keys(csatChannelData),
                                        datasets: [{
                                            label: 'Avg CSAT Points',
                                            data: Object.keys(csatChannelData).map(ch =>
                                                csatChannelData[ch].totalImpact / csatChannelData[ch].surveys
                                            ),
                                            backgroundColor: 'rgba(234, 88, 12, 0.6)',
                                            borderColor: 'rgb(234, 88, 12)',
                                            borderWidth: 1
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        indexAxis: 'y',
                                        plugins: {
                                            legend: { display: false }
                                        },
                                        scales: {
                                            x: {
                                                beginAtZero: true,
                                                title: { display: true, text: 'Avg CSAT Points' }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                return () => {
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [activeTab, analyticsView, useCases, months, channelCosts, categoryCosts, selectedCategory, selectedChannel, selectedSpecialGroup, selectedMetric, analyticsDateRange]);
            
            // Calculate financial metrics when on financial tab
            useEffect(() => {
                if (activeTab === 'financial') {
                    // Calculate implementation cost
                    let implCost = financialSettings.implementationCost;
                    
                    if (financialSettings.costType === 'percentage') {
                        // Calculate first year benefits using filtered use cases
                        const filteredUseCases = getFilteredUseCases();
                        const firstYearMonths = months.slice(0, Math.min(12, months.length));
                        let firstYearBenefits = 0;
                        
                        firstYearMonths.forEach(month => {
                            filteredUseCases.forEach(uc => {
                                firstYearBenefits += calculateSavings(uc, month.id);
                            });
                        });
                        
                        implCost = firstYearBenefits * (financialSettings.costPercentage / 100);
                    }
                    
                    // Generate cash flows
                    const ongoingCost = financialSettings.includeOngoingCosts ? financialSettings.ongoingCostMonthly : 0;
                    const cashFlows = generateCashFlows(implCost, ongoingCost);
                    
                    // Calculate metrics
                    const npv = calculateNPV(cashFlows, financialSettings.discountRate);
                    const irr = cashFlows.length > 1 && cashFlows.some(cf => cf > 0) ? calculateIRR(cashFlows) : 0;
                    const paybackPeriod = calculatePaybackPeriod(cashFlows);
                    
                    
                    // Calculate total ROI using same logic as Excel export for consistency
                    // ROI = (Total Benefits - Total Costs) / Total Costs * 100
                    let totalBenefits = 0;
                    let totalImplementationCost = 0;
                    let totalOngoingCosts = 0;
                    
                    const filteredMonths = getFilteredMonths();
                    const filteredUseCases = getFilteredUseCases();
                    
                    // Calculate using the exact same logic as the Excel export
                    filteredMonths.forEach((month, index) => {
                        let monthlyBenefit = 0;
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, month.id);
                        });
                        totalBenefits += monthlyBenefit;
                        
                        if (financialSettings.useCategoryBilling) {
                            categories.forEach(category => {
                                const catSettings = financialSettings.categoryBilling?.[category];
                                if (catSettings) {
                                    if (index === catSettings.implementationMonth) {
                                        totalImplementationCost += catSettings.implementationCost || 0;
                                    }
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                    if (index > catSettings.implementationMonth && 
                                        ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                        totalOngoingCosts += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                }
                            });
                        } else {
                            if (index === 0) {
                                totalImplementationCost = implCost || 0;
                            }
                            const cycleMonths = getBillingCycleMonths(
                                financialSettings.billingCycle || 'monthly',
                                financialSettings.customMonths
                            );
                            if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                totalOngoingCosts += financialSettings.ongoingCostMonthly * cycleMonths;
                            }
                        }
                    });
                    
                    const totalCosts = totalImplementationCost + totalOngoingCosts;
                    const totalROI = totalCosts > 0 ? ((totalBenefits - totalCosts) / totalCosts) * 100 : 0;
                    
                    setFinancialMetrics({
                        npv,
                        irr,
                        paybackPeriod,
                        cashFlows,
                        breakEvenMonth: paybackPeriod !== null ? Math.max(1, Math.ceil(paybackPeriod)) : null,
                        totalROI
                    });
                }
            }, [activeTab, financialSettings, useCases, months, selectedCategory, selectedChannel, selectedSpecialGroup]);
            
            // Create Financial Analysis charts
            useEffect(() => {
                if (activeTab === 'financial' && window.Chart && financialMetrics.cashFlows.length > 0) {
                    // Destroy existing financial charts
                    ['cashFlow', 'breakeven', 'categoryImplementation', 'categoryCostTimeline'].forEach(chartName => {
                        if (chartInstances.current[chartName]) {
                            chartInstances.current[chartName].destroy();
                            delete chartInstances.current[chartName];
                        }
                    });
                    
                    const filteredMonths = getFilteredMonths();
                    // Use actual month names for all labels (no "Month 0")
                    const monthLabels = filteredMonths.map(m => `${m.month} ${m.year}`);
                    
                    // Cash Flow Chart
                    if (chartRefs.cashFlow.current) {
                        const ctx = chartRefs.cashFlow.current.getContext('2d');
                        chartInstances.current.cashFlow = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Monthly Cash Flow',
                                    data: financialMetrics.cashFlows,
                                    backgroundColor: financialMetrics.cashFlows.map(cf => cf < 0 ? '#EF4444' : '#10B981'),
                                    borderColor: financialMetrics.cashFlows.map(cf => cf < 0 ? '#DC2626' : '#059669'),
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            callback: function(value) {
                                                return '$' + value.toLocaleString();
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        callbacks: {
                                            label: (context) => {
                                                const value = context.parsed.y;
                                                if (context.dataIndex === 0) {
                                                    return `Implementation Cost: -$${Math.abs(value).toLocaleString()}`;
                                                }
                                                return `Cash Flow: $${value.toLocaleString()}`;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Break-even / Cumulative Cash Flow Chart
                    if (chartRefs.breakeven.current) {
                        const cumulativeCashFlow = [];
                        let cumulative = 0;
                        financialMetrics.cashFlows.forEach(cf => {
                            cumulative += cf;
                            cumulativeCashFlow.push(cumulative);
                        });
                        
                        const ctx = chartRefs.breakeven.current.getContext('2d');
                        chartInstances.current.breakeven = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Cumulative Cash Flow',
                                    data: cumulativeCashFlow,
                                    borderColor: '#3B82F6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.4,
                                    fill: true
                                }, {
                                    label: 'Break-even Line',
                                    data: Array(financialMetrics.cashFlows.length).fill(0),
                                    borderColor: '#6B7280',
                                    borderDash: [5, 5],
                                    borderWidth: 1,
                                    fill: false,
                                    pointRadius: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            callback: function(value) {
                                                return '$' + value.toLocaleString();
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { 
                                        display: true,
                                        position: 'bottom'
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: (context) => {
                                                if (context.datasetIndex === 0) {
                                                    return `Cumulative: $${context.parsed.y.toLocaleString()}`;
                                                }
                                                return null;
                                            }
                                        }
                                    },
                                    annotation: financialMetrics.paybackPeriod ? {
                                        annotations: {
                                            breakeven: {
                                                type: 'line',
                                                xMin: financialMetrics.paybackPeriod,
                                                xMax: financialMetrics.paybackPeriod,
                                                borderColor: '#10B981',
                                                borderWidth: 2,
                                                label: {
                                                    enabled: true,
                                                    content: `Break-even: ${financialMetrics.paybackPeriod.toFixed(1)} months`,
                                                    position: 'start'
                                                }
                                            }
                                        }
                                    } : {}
                                }
                            }
                        });
                    }
                    
                    // Create category-specific charts when using category billing
                    if (financialSettings.useCategoryBilling) {
                        // Category Implementation Costs Chart
                        if (chartRefs.categoryImplementation.current) {
                            const ctx = chartRefs.categoryImplementation.current.getContext('2d');
                            
                            // Only include categories that have filtered use cases
                            const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                            
                            const categoryData = activeCategories.map(category => {
                                const catSettings = financialSettings.categoryBilling?.[category] || {};
                                return catSettings.implementationCost || 0;
                            });
                            
                            chartInstances.current.categoryImplementation = new Chart(ctx, {
                                type: 'doughnut',
                                data: {
                                    labels: activeCategories,
                                    datasets: [{
                                        data: categoryData,
                                        backgroundColor: [
                                            '#3B82F6', // Blue
                                            '#10B981', // Green
                                            '#F59E0B', // Yellow
                                            '#EF4444', // Red
                                            '#8B5CF6', // Purple
                                            '#EC4899'  // Pink
                                        ],
                                        borderWidth: 2,
                                        borderColor: '#fff'
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                padding: 15,
                                                font: { size: 11 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => {
                                                    const label = context.label || '';
                                                    const value = context.parsed || 0;
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                                    return `${label}: $${value.toLocaleString()} (${percentage}%)`;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Category Cost Timeline Chart
                        if (chartRefs.categoryCostTimeline.current) {
                            const ctx = chartRefs.categoryCostTimeline.current.getContext('2d');
                            
                            // Only include categories that have filtered use cases
                            const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                            
                            // Prepare datasets for each active category
                            const datasets = activeCategories.map((category, index) => {
                                const catSettings = financialSettings.categoryBilling?.[category] || {};
                                const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];
                                const color = colors[index % colors.length];
                                
                                // Create cost data for first 12 months
                                const costData = [];
                                for (let month = 0; month < 12; month++) {
                                    let cost = 0;
                                    // Implementation cost at specified month
                                    if (month === (catSettings.implementationMonth || 0)) {
                                        cost += catSettings.implementationCost || 0;
                                    }
                                    // Ongoing costs based on billing cycle
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                                    if (month > (catSettings.implementationMonth || 0) && 
                                        ((month - (catSettings.implementationMonth || 0) - 1) % cycleMonths === 0)) {
                                        cost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                    costData.push(cost);
                                }
                                
                                return {
                                    label: category,
                                    data: costData,
                                    backgroundColor: color + '33', // Add transparency
                                    borderColor: color,
                                    borderWidth: 2,
                                    fill: true
                                };
                            });
                            
                            chartInstances.current.categoryCostTimeline = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: ['Month 0', 'Month 1', 'Month 2', 'Month 3', 'Month 4', 'Month 5', 
                                            'Month 6', 'Month 7', 'Month 8', 'Month 9', 'Month 10', 'Month 11'],
                                    datasets: datasets
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        mode: 'index',
                                        intersect: false
                                    },
                                    scales: {
                                        x: {
                                            display: true,
                                            title: {
                                                display: true,
                                                text: 'Timeline'
                                            }
                                        },
                                        y: {
                                            display: true,
                                            title: {
                                                display: true,
                                                text: 'Cost ($)'
                                            },
                                            stacked: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                padding: 10,
                                                font: { size: 11 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => {
                                                    const label = context.dataset.label || '';
                                                    const value = context.parsed.y || 0;
                                                    if (value > 0) {
                                                        return `${label}: $${value.toLocaleString()}`;
                                                    }
                                                    return null;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }, [activeTab, financialMetrics, getFilteredMonths, financialSettings, categories]);
            
            // No longer needed - removed channel defaults
            // useEffect(() => {
            //     if (ensureAllChannelsExist()) {
            //         console.log('Added missing channels to channelCosts configuration');
            //     }
            // }, []);

            // CRUD Operations
            const addUseCase = () => {
                if (newUseCase.name) {
                    setUseCases([...useCases, {
                        id: `uc${Date.now()}`,
                        ...newUseCase,
                        data: {}
                    }]);
                    setNewUseCase({
                        category: categories[0] || '',
                        name: '',
                        channel: 'phone',
                        specialGroup: null,
                        benefits: [
                            {
                                metric: 'Deflection Rate (%)',
                                baselineValue: 0
                            }
                        ]
                    });
                    setShowAddUseCase(false);
                }
            };

            const removeUseCase = (id) => {
                setUseCases(useCases.filter(uc => uc.id !== id));
            };

            const updateUseCaseData = (useCaseId, monthId, field, value) => {
                // Validate improvement values for percentage metrics
                let validatedValue = value;
                if (field.includes('improvement_')) {
                    const numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        // Check if this is a percentage metric (not minutes or points)
                        const isPercentageMetric = field.includes('(%)') || 
                            field.includes('Deflection') || 
                            field.includes('Automation') || 
                            field.includes('Self-Service') || 
                            field.includes('Transfer') ||
                            field.includes('Resolution') ||
                            field.includes('FCR') ||
                            field.includes('CSAT') ||
                            field.includes('Conversion') ||
                            field.includes('Retention') ||
                            field.includes('Compliance');
                        
                        if (isPercentageMetric && numValue > 100) {
                            console.warn(`Warning: Improvement value ${numValue} exceeds 100% for ${field}. Capping at 100%.`);
                            validatedValue = '100';
                        } else if (isPercentageMetric && numValue < 0) {
                            validatedValue = '0';
                        }
                        
                        // For AHT (minutes), cap at reasonable values
                        if (field.includes('AHT') && numValue > 60) {
                            console.warn(`Warning: AHT improvement ${numValue} exceeds 60 minutes. Consider if this is correct.`);
                        }
                    }
                }
                
                // Save current state to undo stack before making changes
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]); // Clear redo stack on new change
                setUnsavedChanges(prev => new Set([...prev, `${useCaseId}-${monthId}-${field}`]));
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        return {
                            ...uc,
                            data: {
                                ...uc.data,
                                [monthId]: {
                                    ...uc.data[monthId],
                                    [field]: validatedValue
                                }
                            }
                        };
                    }
                    return uc;
                }));
                
                // Auto-save after a delay
                setTimeout(() => {
                    setUnsavedChanges(prev => {
                        const newSet = new Set(prev);
                        newSet.delete(`${useCaseId}-${monthId}-${field}`);
                        return newSet;
                    });
                }, 1500);
            };
            
            // Helper to create deep copy of use cases for undo/redo
            const deepCopyUseCases = (cases) => {
                return JSON.parse(JSON.stringify(cases));
            };

            // Undo/Redo functions
            const undo = () => {
                if (undoStack.length > 0) {
                    setRedoStack(prev => [...prev, deepCopyUseCases(useCases)]);
                    const previousState = undoStack[undoStack.length - 1];
                    setUndoStack(prev => prev.slice(0, -1));
                    setUseCases(previousState);
                    setUnsavedChanges(new Set());
                }
            };
            
            const redo = () => {
                if (redoStack.length > 0) {
                    setUndoStack(prev => [...prev, deepCopyUseCases(useCases)]);
                    const nextState = redoStack[redoStack.length - 1];
                    setRedoStack(prev => prev.slice(0, -1));
                    setUseCases(nextState);
                    setUnsavedChanges(new Set());
                }
            };
            
            // Bulk operations functions
            const applyToAllMonths = (useCaseId, sourceMonthId) => {
                const useCase = useCases.find(uc => uc.id === useCaseId);
                const sourceData = useCase?.data[sourceMonthId];
                if (!sourceData) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            if (month.id !== sourceMonthId) {
                                newData[month.id] = { ...sourceData };
                            }
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
            };
            
            const copyPreviousMonth = (useCaseId, targetMonthId) => {
                const currentMonthIndex = months.findIndex(m => m.id === targetMonthId);
                if (currentMonthIndex <= 0) return;
                
                const previousMonth = months[currentMonthIndex - 1];
                const useCase = useCases.find(uc => uc.id === useCaseId);
                const previousData = useCase?.data[previousMonth.id];
                if (!previousData) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        return {
                            ...uc,
                            data: {
                                ...uc.data,
                                [targetMonthId]: { ...previousData }
                            }
                        };
                    }
                    return uc;
                }));
            };
            
            const fillDown = (useCaseIds, field, value, clearSelection = true) => {
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (useCaseIds.includes(uc.id)) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            newData[month.id] = {
                                ...newData[month.id],
                                [field]: value
                            };
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
                if (clearSelection) {
                    setSelectedUseCases(new Set());
                }
            };
            
            const batchFillDown = (fillOperations) => {
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    const operations = fillOperations.filter(op => op.useCaseId === uc.id);
                    if (operations.length > 0) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            operations.forEach(op => {
                                newData[month.id] = {
                                    ...newData[month.id],
                                    [op.field]: op.value
                                };
                            });
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const clearAllData = (useCaseIds = null) => {
                if (!confirm('Are you sure you want to clear all data? This cannot be undone.')) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const targetIds = useCaseIds || useCases.map(uc => uc.id);
                setUseCases(useCases.map(uc => {
                    if (targetIds.includes(uc.id)) {
                        return { ...uc, data: {} };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            // Batch operations for selected use cases
            const batchUpdateCategory = (newCategory) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, category: newCategory };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchUpdateChannel = (newChannel) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, channel: newChannel };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchUpdateSpecialGroup = (newSpecialGroup) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, specialGroup: newSpecialGroup || null };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchDelete = () => {
                if (selectedUseCases.size === 0) return;
                if (!confirm(`Are you sure you want to delete ${selectedUseCases.size} selected use cases? This cannot be undone.`)) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.filter(uc => !selectedUseCases.has(uc.id)));
                setSelectedUseCases(new Set());
            };
            
            const batchDuplicate = () => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const newUseCases = [];
                useCases.forEach(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        newUseCases.push({
                            ...uc,
                            id: Date.now() + Math.random(),
                            name: `${uc.name} (Copy)`
                        });
                    }
                });
                
                setUseCases([...useCases, ...newUseCases]);
                setSelectedUseCases(new Set());
            };
            
            // Template functions
            const saveAsTemplate = (templateName) => {
                if (!templateName.trim()) return;
                
                const newTemplates = {
                    ...dataTemplates,
                    [templateName]: {
                        useCases: useCases.map(uc => {
                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                            // Only keep the normalized benefits format, remove old metric/baselineValue fields
                            const { metric, baselineValue, ...cleanUC } = normalizedUC;
                            return {
                                ...cleanUC,
                                id: Date.now() + Math.random(), // New IDs for template
                                data: {} // Clean data for template
                            };
                        }),
                        // Save the current categories configuration with the template
                        categories: [...categories],
                        // Save metric values configuration
                        metricValues: { ...metricValues },
                        savedDate: new Date().toISOString()
                    }
                };
                
                setDataTemplates(newTemplates);
                localStorage.setItem('dataTemplates', JSON.stringify(newTemplates));
            };
            
            const loadTemplate = (templateName) => {
                const template = dataTemplates[templateName];
                if (!template) return;
                
                // Check if template has categories saved
                const hasTemplateCategories = template.categories && Array.isArray(template.categories);
                const hasMetricValues = template.metricValues && typeof template.metricValues === 'object';
                
                let confirmMessage = `Load template "${templateName}"? This will replace all current use cases.`;
                
                if (hasTemplateCategories) {
                    confirmMessage += `\n\nThis template includes ${template.categories.length} categories. Your current categories will be replaced.`;
                }
                
                if (hasMetricValues) {
                    confirmMessage += `\n\nThis template includes configuration values (NPS value, Agent replacement cost, etc.) that will replace your current settings.`;
                }
                
                if (!confirm(confirmMessage)) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                // If template has categories, update them
                if (hasTemplateCategories) {
                    // Handle both array format (new) and string array format
                    const templateCategories = typeof template.categories[0] === 'string' 
                        ? template.categories 
                        : template.categories.map(c => c.name || c);
                    setCategories(templateCategories);
                }
                
                // If template has metric values, update them
                if (hasMetricValues) {
                    setMetricValues(template.metricValues);
                }
                
                // Load use cases and validate their categories
                const currentCategoryNames = hasTemplateCategories 
                    ? (typeof template.categories[0] === 'string' ? template.categories : template.categories.map(c => c.name || c))
                    : categories;
                
                setUseCases(template.useCases.map(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits({
                        ...uc,
                        id: Date.now() + Math.random() // Ensure unique IDs
                    });
                    
                    // Validate category exists, if not assign to first available category
                    if (!currentCategoryNames.includes(normalizedUC.category)) {
                        console.warn(`Category "${normalizedUC.category}" not found, assigning to "${currentCategoryNames[0]}"`);
                        normalizedUC.category = currentCategoryNames[0] || 'Pre-Sales';
                    }
                    
                    return normalizedUC;
                }));
            };
            
            const deleteTemplate = (templateName) => {
                if (!confirm(`Delete template "${templateName}"? This cannot be undone.`)) return;
                
                const newTemplates = { ...dataTemplates };
                delete newTemplates[templateName];
                setDataTemplates(newTemplates);
                localStorage.setItem('dataTemplates', JSON.stringify(newTemplates));
            };
            
            // Handle paste from spreadsheet
            const handlePaste = (e, startUseCaseIndex, startMonthIndex) => {
                e.preventDefault();
                const pastedData = e.clipboardData.getData('text');
                
                // Clean up the data - remove any trailing whitespace and split properly
                const rows = pastedData.trim().split(/\r?\n/).map(row => row.trim()).filter(row => row);
                
                if (rows.length === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const updatedUseCases = deepCopyUseCases(useCases);
                
                // Determine which field was focused by checking the active element
                const activeElement = document.activeElement;
                const fieldKey = activeElement?.getAttribute('data-field-key');
                
                // Check if this is a single cell paste (no tabs or newlines)
                const isSingleCell = rows.length === 1 && !rows[0].includes('\t');
                
                if (isSingleCell) {
                    // Single value paste - put it in the focused field
                    const value = parseFloat(rows[0]) || 0;
                    const monthId = months[startMonthIndex].id;
                    
                    if (startUseCaseIndex < updatedUseCases.length) {
                        if (!updatedUseCases[startUseCaseIndex].data[monthId]) {
                            updatedUseCases[startUseCaseIndex].data[monthId] = {};
                        }
                        
                        // Use the field key from the active element
                        if (fieldKey) {
                            updatedUseCases[startUseCaseIndex].data[monthId][fieldKey] = value;
                        }
                    }
                } else {
                    // Multi-cell/multi-row paste
                    // Iterate through all visible data rows and paste accordingly
                    let currentRowIndex = 0;
                    
                    // Build a flat list of all visible fields (across all use cases and their benefits)
                    const allFields = [];
                    updatedUseCases.forEach((uc, ucIndex) => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        
                        // Add benefit-specific volume and improvement fields
                        normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                            // Volume field for this benefit
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            allFields.push({
                                useCaseIndex: ucIndex,
                                fieldKey: volumeFieldKey,
                                benefitIndex: benefitIndex,
                                isVolume: true
                            });
                            
                            // Improvement field for this benefit
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            allFields.push({
                                useCaseIndex: ucIndex,
                                fieldKey: improvementFieldKey,
                                benefitIndex: benefitIndex,
                                isVolume: false
                            });
                        });
                    });
                    
                    // Starting from the clicked position, map rows to fields
                    const startFieldIndex = allFields.findIndex(f => 
                        f.useCaseIndex === startUseCaseIndex && 
                        (fieldKey ? f.fieldKey === fieldKey : f.isVolume === true)
                    );
                    
                    if (startFieldIndex === -1) return;
                    
                    // Paste data starting from the clicked field
                    rows.forEach((row, rowIndex) => {
                        const cells = row.split('\t').map(cell => cell.trim());
                        const fieldIndex = startFieldIndex + rowIndex;
                        
                        if (fieldIndex < allFields.length) {
                            const field = allFields[fieldIndex];
                            
                            cells.forEach((cell, cellIndex) => {
                                const monthIndex = startMonthIndex + cellIndex;
                                
                                if (monthIndex < months.length && cell) {
                                    const monthId = months[monthIndex].id;
                                    const value = parseFloat(cell) || 0;
                                    const ucIndex = field.useCaseIndex;
                                    
                                    if (!updatedUseCases[ucIndex].data[monthId]) {
                                        updatedUseCases[ucIndex].data[monthId] = {};
                                    }
                                    
                                    updatedUseCases[ucIndex].data[monthId][field.fieldKey] = value;
                                }
                            });
                        }
                    });
                }
                
                setUseCases(updatedUseCases);
            };
            
            // Validate metric configuration on mount
            React.useEffect(() => {
                validateMetricConfig();
            }, []);
            
            // Keyboard shortcuts
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'z':
                                e.preventDefault();
                                if (e.shiftKey) {
                                    redo();
                                } else {
                                    undo();
                                }
                                break;
                            case 'y':
                                e.preventDefault();
                                redo();
                                break;
                            case 'a':
                                if (activeTab === 'data' && bulkEditMode) {
                                    e.preventDefault();
                                    setSelectedUseCases(new Set(useCases.map(uc => uc.id)));
                                }
                                break;
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undoStack, redoStack, activeTab, bulkEditMode, useCases]);

            // Special group functions are now handled within the category-channel structure
            // Functions removed as they're no longer needed with nested structure

            // Helper function to download CSV/Excel files
            const downloadFile = (content, filename, type = 'text/csv') => {
                const blob = new Blob([content], { type });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                window.URL.revokeObjectURL(url);
            };
            
            // Generate Financial Analysis Excel with tab-separated values for proper formula support
            const generateFinancialAnalysisCSV = (filteredUseCases, metrics, settings) => {
                const TAB = '\t';
                let csv = 'FINANCIAL ANALYSIS REPORT WITH EXCEL FORMULAS\n\n';
                
                // Use filtered months consistently throughout
                const filteredMonths = getFilteredMonths();
                
                // Configuration Section
                csv += 'CONFIGURATION\n';
                csv += `Parameter${TAB}Value${TAB}Formula${TAB}Description\n`;
                
                if (settings.useCategoryBilling) {
                    csv += `Category Billing Mode${TAB}ENABLED${TAB}${TAB}Using category-specific implementation costs\n`;
                    csv += `Discount Rate${TAB}${(settings.discountRate).toFixed(4)}${TAB}${TAB}Annual discount rate for NPV (as decimal)\n`;
                    csv += `Monthly Discount Rate${TAB}${(settings.discountRate / 12).toFixed(6)}${TAB}${TAB}Monthly rate for NPV calculations\n`;
                    csv += `Analysis Months${TAB}${filteredMonths.length}${TAB}${TAB}Total months in analysis period\n\n`;
                    
                    // Category-specific configuration
                    csv += 'CATEGORY-SPECIFIC BILLING CONFIGURATION\n';
                    csv += `Category${TAB}Implementation Cost${TAB}Start Month${TAB}Ongoing Cost Monthly${TAB}Billing Cycle${TAB}Cycle Months\n`;
                    categories.forEach(category => {
                        const catSettings = settings.categoryBilling?.[category] || {};
                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                        csv += `${category}${TAB}${catSettings.implementationCost || 0}${TAB}${catSettings.implementationMonth || 0}${TAB}${catSettings.ongoingCostMonthly || 0}${TAB}${catSettings.billingCycle || 'monthly'}${TAB}${cycleMonths}\n`;
                    });
                    csv += '\n';
                } else {
                    csv += `Implementation Cost${TAB}${settings.implementationCost}${TAB}${TAB}One-time implementation cost\n`;
                    csv += `Discount Rate${TAB}${(settings.discountRate).toFixed(4)}${TAB}${TAB}Annual discount rate for NPV (as decimal)\n`;
                    csv += `Monthly Discount Rate${TAB}${(settings.discountRate / 12).toFixed(6)}${TAB}${TAB}Monthly rate for NPV calculations\n`;
                    csv += `Ongoing Cost Monthly${TAB}${settings.includeOngoingCosts ? settings.ongoingCostMonthly : 0}${TAB}${TAB}Monthly ongoing costs\n`;
                    csv += `Analysis Months${TAB}${filteredMonths.length}${TAB}${TAB}Total months in analysis period\n\n`;
                }
                
                // Monthly Cash Flow Table with Excel formulas
                csv += 'MONTHLY CASH FLOW ANALYSIS\n';
                csv += `Month${TAB}Period${TAB}Monthly Benefit${TAB}Implementation Cost${TAB}Ongoing Cost${TAB}Net Cash Flow${TAB}Cumulative Cash Flow${TAB}PV Factor${TAB}NPV Contribution\n`;
                
                // Calculate the actual starting row for cash flow data
                // Row 1: Title "FINANCIAL ANALYSIS REPORT WITH EXCEL FORMULAS"
                // Row 2: Empty
                // Row 3: "CONFIGURATION"
                // Row 4: Header row
                // Rows 5-8: Configuration data (4 rows for non-category, variable for category)
                // Additional rows for category billing configuration if enabled
                // Then empty row, then "MONTHLY CASH FLOW ANALYSIS", then headers
                // Count the actual rows output so far
                let row;
                if (settings.useCategoryBilling) {
                    // Actual row counting from the screenshot:
                    // Rows 1-11: Fixed headers and config (including CATEGORY-SPECIFIC header)
                    // Rows 12-15: 4 category data rows (one per category)
                    // Row 16: Empty line
                    // Row 17: "MONTHLY CASH FLOW ANALYSIS" text
                    // Row 18: Column headers (Month, Period, Monthly Benefit, etc.)
                    // Row 19: First actual data row
                    // So for 4 categories: row 19 = 15 + 4
                    row = 15 + categories.length;
                } else {
                    // Without category billing:
                    // Row 1: Title
                    // Row 2: Empty line
                    // Row 3: CONFIGURATION
                    // Row 4: Parameter headers
                    // Row 5: Implementation Cost row
                    // Row 6: Discount Rate row
                    // Row 7: Monthly Discount Rate row
                    // Row 8: Ongoing Cost Monthly row
                    // Row 9: Analysis Months row
                    // Row 10: Empty line
                    // Row 11: MONTHLY CASH FLOW ANALYSIS
                    // Row 12: Column headers
                    // Row 13: First data row
                    row = 13;
                }
                filteredMonths.forEach((month, index) => {
                    const currentRow = row + index; // Current row number
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    // Calculate actual implementation and ongoing costs for this month
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        // Calculate category-specific costs for this month
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                // Implementation cost at the specified month
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                // Ongoing costs based on billing cycle
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        // Simple implementation cost in first month
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        // Ongoing costs based on billing cycle (not every month)
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    csv += `${month.month} ${month.year}${TAB}${index}${TAB}`;
                    csv += `${monthlyBenefit.toFixed(2)}${TAB}`;
                    csv += `${-implCost}${TAB}`;
                    csv += `${-ongoingCost}${TAB}`;
                    
                    // Net Cash Flow formula
                    csv += `=C${currentRow}+D${currentRow}+E${currentRow}${TAB}`;
                    
                    // Cumulative Cash Flow formula
                    if (index === 0) {
                        csv += `=F${currentRow}${TAB}`;
                    } else {
                        csv += `=G${currentRow-1}+F${currentRow}${TAB}`;
                    }
                    
                    // PV Factor formula - using the actual discount rate value
                    const monthlyRate = settings.discountRate / 12;
                    csv += `=1/POWER(1+${monthlyRate.toFixed(6)},B${currentRow})${TAB}`;
                    
                    // NPV Contribution formula
                    csv += `=F${currentRow}*H${currentRow}\n`;
                });
                
                csv += '\n';
                const lastRow = row + filteredMonths.length - 1;
                
                // Summary Metrics with Excel formulas
                csv += 'FINANCIAL METRICS\n';
                csv += `Metric${TAB}Value${TAB}Formula${TAB}Description\n`;
                
                // Calculate the row where metrics start (after the cash flow data and headers)
                const metricsStartRow = lastRow + 4; // +1 for empty row, +1 for section header, +1 for column headers, +1 for first metric row
                
                csv += `Total Benefits${TAB}=SUM(C${row}:C${lastRow})${TAB}${TAB}Sum of all monthly benefits\n`;
                csv += `Total Investment${TAB}=-SUM(D${row}:D${lastRow})${TAB}${TAB}Total implementation costs\n`;
                csv += `Total Ongoing Costs${TAB}=-SUM(E${row}:E${lastRow})${TAB}${TAB}Sum of all ongoing costs\n`;
                csv += `Net Cash Flow${TAB}=SUM(F${row}:F${lastRow})${TAB}${TAB}Total net cash flow\n`;
                csv += `NPV${TAB}=SUM(I${row}:I${lastRow})${TAB}${TAB}Net Present Value\n`;
                
                // Calculate payback period value directly
                const paybackValue = metrics.paybackPeriod ? Math.ceil(metrics.paybackPeriod) : 'Not reached';
                csv += `Payback Period${TAB}${paybackValue}${TAB}${TAB}Months to break even\n`;
                
                // Calculate ROI using same calculation as elsewhere
                // Get the actual totals for Financial Metrics section
                let metricsTotalBenefits = 0;
                let metricsTotalImplementation = 0;
                let metricsTotalOngoing = 0;
                
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    metricsTotalBenefits += monthlyBenefit;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    metricsTotalImplementation += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    metricsTotalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            metricsTotalImplementation = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            metricsTotalOngoing += settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                });
                
                const metricsTotalCosts = metricsTotalImplementation + metricsTotalOngoing;
                const roiDecimal = metricsTotalCosts > 0 ? ((metricsTotalBenefits - metricsTotalCosts) / metricsTotalCosts) : 0;
                
                csv += `ROI (decimal)${TAB}${roiDecimal.toFixed(4)}${TAB}${TAB}Return on Investment (format as % in Excel)\n`;
                
                // Provide IRR values directly since Excel IRR can be tricky
                const monthlyIRR = metrics.irr ? (metrics.irr / 100 / 12).toFixed(4) : 'N/A';
                const annualIRR = metrics.irr ? (metrics.irr / 100).toFixed(4) : 'N/A';
                csv += `IRR Monthly${TAB}${monthlyIRR}${TAB}${TAB}Monthly Internal Rate of Return\n`;
                csv += `IRR Annual${TAB}${annualIRR}${TAB}${TAB}Annualized IRR\n\n`;
                
                // Category breakdown for category billing
                if (settings.useCategoryBilling) {
                    csv += 'CATEGORY COST BREAKDOWN\n';
                    csv += `Category${TAB}Total Implementation${TAB}First Year Ongoing${TAB}Total First Year Cost\n`;
                    categories.forEach(category => {
                        const catSettings = settings.categoryBilling?.[category] || {};
                        const implCost = catSettings.implementationCost || 0;
                        const monthlyOngoing = catSettings.ongoingCostMonthly || 0;
                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                        // Calculate first year ongoing costs based on billing cycle
                        const monthsAfterImpl = Math.max(0, 12 - (catSettings.implementationMonth || 0));
                        const cyclesInFirstYear = Math.floor(monthsAfterImpl / cycleMonths);
                        const firstYearOngoing = cyclesInFirstYear * monthlyOngoing * cycleMonths;
                        csv += `${category}${TAB}${implCost}${TAB}${firstYearOngoing}${TAB}${implCost + firstYearOngoing}\n`;
                    });
                    csv += '\n';
                }
                
                // Use Cases Detail
                csv += 'USE CASES INCLUDED\n';
                csv += `Category${TAB}Use Case${TAB}Channel${TAB}Special Group${TAB}Monthly Avg Benefit\n`;
                filteredUseCases.forEach(uc => {
                    const totalSavings = filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0);
                    const avgMonthlySavings = totalSavings / filteredMonths.length;
                    csv += `${uc.category}${TAB}${uc.name}${TAB}${uc.channel}${TAB}${uc.specialGroup || 'None'}${TAB}${avgMonthlySavings.toFixed(2)}\n`;
                });
                
                csv += '\n';
                
                // Add Chart Data Section for visualization
                csv += '\n';
                csv += '--- CHART DATA FOR EXCEL VISUALIZATION ---\n';
                csv += 'Instructions: Select data ranges below and use Insert > Charts in Excel\n';
                csv += '\n';
                
                // 1. Cash Flow and Cumulative Chart Data
                csv += '1. CASH FLOW ANALYSIS (For Column/Line Combo Chart)\n';
                csv += `Month${TAB}Monthly Cash Flow${TAB}Cumulative Cash Flow${TAB}Break-Even Line\n`;
                let cumulative = 0;
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    const netCashFlow = monthlyBenefit - implCost - ongoingCost;
                    cumulative += netCashFlow;
                    
                    csv += `${month.month} ${month.year}${TAB}${netCashFlow.toFixed(2)}${TAB}${cumulative.toFixed(2)}${TAB}0\n`;
                });
                
                // Break-even point
                const breakEvenMonth = filteredMonths.findIndex((month, index) => {
                    let cum = 0;
                    for (let i = 0; i <= index; i++) {
                        let monthlyBenefit = 0;
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, filteredMonths[i].id);
                        });
                        
                        let implCost = 0;
                        let ongoingCost = 0;
                        
                        if (settings.useCategoryBilling) {
                            categories.forEach(category => {
                                const catSettings = settings.categoryBilling?.[category];
                                if (catSettings) {
                                    if (i === catSettings.implementationMonth) {
                                        implCost += catSettings.implementationCost || 0;
                                    }
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                    if (i > catSettings.implementationMonth && 
                                        ((i - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                        ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                }
                            });
                        } else {
                            if (i === 0) {
                                implCost = settings.implementationCost || 0;
                            }
                            const cycleMonths = getBillingCycleMonths(
                                settings.billingCycle || 'monthly',
                                settings.customMonths
                            );
                            if (settings.includeOngoingCosts && i > 0 && ((i - 1) % cycleMonths === 0)) {
                                ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                            }
                        }
                        
                        cum += monthlyBenefit - implCost - ongoingCost;
                    }
                    return cum >= 0;
                });
                
                csv += `\nBreak-even Point: ${breakEvenMonth >= 0 ? `Month ${breakEvenMonth + 1} (${filteredMonths[breakEvenMonth].month} ${filteredMonths[breakEvenMonth].year})` : 'Not reached'}\n`;
                csv += '\n';
                
                // 2. Benefits vs Costs Comparison Chart
                csv += '2. BENEFITS VS COSTS COMPARISON (For Stacked Column Chart)\n';
                csv += `Month${TAB}Benefits${TAB}Implementation Costs${TAB}Ongoing Costs\n`;
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    csv += `${month.month} ${month.year}${TAB}${monthlyBenefit.toFixed(2)}${TAB}${implCost}${TAB}${ongoingCost}\n`;
                });
                csv += '\n';
                
                // 3. ROI Metrics Summary (For Pie/Donut Chart)
                // Calculate the same way as UI for consistency
                let totalBenefits = 0;
                let totalImplementation = 0;
                let totalOngoing = 0;
                
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    totalBenefits += monthlyBenefit;
                    
                    if (settings.useCategoryBilling) {
                        // Only include costs for categories that have filtered use cases
                        const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                        activeCategories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    totalImplementation += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            totalImplementation = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            totalOngoing += settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                });
                
                const totalCosts = totalImplementation + totalOngoing;
                const netGain = totalBenefits - totalCosts;
                const roiPercent = totalCosts > 0 ? ((totalBenefits - totalCosts) / totalCosts * 100) : 0;
                
                csv += '3. ROI METRICS SUMMARY (For Pie Chart)\n';
                csv += `Metric${TAB}Value\n`;
                csv += `Total Benefits${TAB}${totalBenefits.toFixed(2)}\n`;
                csv += `Total Implementation${TAB}${totalImplementation.toFixed(2)}\n`;
                csv += `Total Ongoing Costs${TAB}${totalOngoing.toFixed(2)}\n`;
                csv += `Total Costs${TAB}${totalCosts.toFixed(2)}\n`;
                csv += `Net Gain${TAB}${netGain.toFixed(2)}\n`;
                // Export ROI as decimal so Excel can format it as percentage
                csv += `ROI %${TAB}${(roiPercent/100).toFixed(4)}\n`;
                csv += `NPV${TAB}${metrics.npv ? metrics.npv.toFixed(2) : 0}\n`;
                csv += '\n';
                
                // Category-specific chart data when using category billing
                if (settings.useCategoryBilling) {
                    csv += '4. CATEGORY IMPLEMENTATION TIMELINE (For Stacked Area Chart)\n';
                    csv += `Month${TAB}`;
                    // Only include categories that have filtered use cases
                    const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                    activeCategories.forEach(cat => {
                        csv += `${cat}${TAB}`;
                    });
                    csv += '\n';
                    
                    // First 12 months of category costs
                    for (let month = 0; month < 12; month++) {
                        csv += `Month ${month}${TAB}`;
                        activeCategories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category] || {};
                            let cost = 0;
                            
                            if (month === (catSettings.implementationMonth || 0)) {
                                cost += catSettings.implementationCost || 0;
                            }
                            
                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                            if (month > (catSettings.implementationMonth || 0) && 
                                ((month - (catSettings.implementationMonth || 0) - 1) % cycleMonths === 0)) {
                                cost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                            }
                            
                            csv += `${cost}${TAB}`;
                        });
                        csv += '\n';
                    }
                    csv += '\n';
                }
                
                csv += '\n';
                csv += '--- HOW TO CREATE CHARTS IN EXCEL ---\n';
                csv += '\n';
                csv += '1. CASH FLOW CHART:\n';
                csv += '   - Select the "1. CASH FLOW ANALYSIS" data range\n';
                csv += '   - Go to Insert > Charts > Combo Chart\n';
                csv += '   - Set Monthly Cash Flow as Columns\n';
                csv += '   - Set Cumulative Cash Flow as Line with markers\n';
                csv += '   - Add Break-Even Line as a reference line\n\n';
                csv += '2. BENEFITS VS COSTS:\n';
                csv += '   - Select the "2. BENEFITS VS COSTS COMPARISON" data\n';
                csv += '   - Insert > Charts > Stacked Column Chart\n';
                csv += '   - This shows monthly benefits against costs\n\n';
                csv += '3. ROI SUMMARY:\n';
                csv += '   - Select the "3. ROI METRICS SUMMARY" data\n';
                csv += '   - Insert > Charts > Pie or Donut Chart\n';
                csv += '   - Shows proportion of benefits vs investment\n\n';
                if (settings.useCategoryBilling) {
                    csv += '4. CATEGORY TIMELINE:\n';
                    csv += '   - Select the "4. CATEGORY IMPLEMENTATION TIMELINE" data\n';
                    csv += '   - Insert > Charts > Stacked Area Chart\n';
                    csv += '   - Shows phased rollout by category\n\n';
                }
                csv += 'TIPS:\n';
                csv += '- Format currency columns (B, C, D, E, F, G, I) as Currency\n';
                csv += '- Format the ROI % cell as Percentage (it will show correctly as 239% for example)\n';
                csv += '- Use conditional formatting on Cumulative Cash Flow to highlight when positive\n';
                csv += '- Add data labels to charts for key values\n';
                csv += '- Use Excel\'s Chart Design tab to apply professional styles\n';
                
                return csv;
            };
            
            // Import/Export functionality
            const exportAnalyticsExcel = () => {
                // Create context with all necessary functions and state
                const context = ExportUtils.createContext({
                    useCases,
                    months,
                    dateRange,
                    analyticsDateRange,
                    activeTab: 'analytics', // Force analytics mode
                    analyticsView,
                    selectedCategory,
                    selectedChannel,
                    selectedSpecialGroup,
                    selectedMetric,
                    channelCosts,
                    categoryCosts,
                    metricValues,
                    ahtNegotiationMode,
                    categories,
                    ensureUseCaseHasBenefits,
                    getEffectiveCost,
                    getCostSourceDescription,
                    getCostConfiguration,
                    getApplicableAHT,
                    getEffectiveMetricValue,
                    getBenefitVolumeValue,
                    getVolumeLabel,
                    getTotalVolumeForUseCaseMonth,
                    calculateBenefitSavings,
                    calculateSavings,
                    calculateTotalSavings,
                    getFilteredUseCases,
                    getFilteredMonths,
                    getChannelCostValue,
                    calculateSavingsBreakdownByType,
                    calculateCostSavings,
                    calculateRevenueImpact,
                    METRIC_CONFIG,
                    ALL_CHANNELS
                });
                
                // Generate Excel export using ExportUtils
                // Don't force columns - let ExportUtils decide based on analyticsView
                const excel = ExportUtils.generateExcelExport(context, {
                    isAnalytics: true
                });
                
                // Download the file
                ExportUtils.downloadFile(excel, `analytics_${analyticsView}_excel_${new Date().toISOString().split('T')[0]}.xls`, 'application/vnd.ms-excel');
            };
            
            // Excel export with live formulas for full traceability and automatic calculations
            const exportToExcel = () => {
                // Validate we have data to export
                if (!useCases || useCases.length === 0) {
                    alert('No use cases available to export. Please add at least one use case first.');
                    return;
                }
                
                // Check if any categories have costs configured
                let hasCostConfiguration = false;
                for (const uc of useCases) {
                    if (categoryCosts[uc.category]) {
                        hasCostConfiguration = true;
                        break;
                    }
                }
                
                if (!hasCostConfiguration) {
                    alert('Warning: No cost configuration found for any categories. Please configure costs in Cost Settings to see calculated savings. Continuing with export...');
                }
                
                // Create context with all necessary functions and state
                const context = ExportUtils.createContext({
                    useCases,
                    months,
                    dateRange,
                    analyticsDateRange,
                    activeTab,
                    analyticsView,
                    selectedCategory,
                    selectedChannel,
                    selectedSpecialGroup,
                    selectedMetric,
                    channelCosts,
                    categoryCosts,
                    metricValues,
                    ahtNegotiationMode,
                    categories,
                    ensureUseCaseHasBenefits,
                    getEffectiveCost,
                    getCostSourceDescription,
                    getCostConfiguration,
                    getApplicableAHT,
                    getEffectiveMetricValue,
                    getBenefitVolumeValue,
                    getVolumeLabel,
                    getTotalVolumeForUseCaseMonth,
                    calculateBenefitSavings,
                    calculateSavings,
                    calculateTotalSavings,
                    getFilteredUseCases,
                    getFilteredMonths,
                    getChannelCostValue,
                    calculateSavingsBreakdownByType,
                    calculateCostSavings,
                    calculateRevenueImpact,
                    METRIC_CONFIG,
                    ALL_CHANNELS
                });
                
                // Generate Excel export using ExportUtils
                let csv = ExportUtils.generateExcelExport(context, {
                    isAnalytics: false
                });
                
                // Add instructions
                csv += '\n';
                csv += 'INSTRUCTIONS FOR USE\n';
                csv += '1. Save and open this file in Microsoft Excel\n';
                csv += '2. All formulas in columns J (Net Improvement) and L (Savings) are live and will recalculate automatically\n';
                csv += '3. You can modify Volume or Improvement values to see instant updates\n';
                csv += '4. The Effective Cost column shows the actual per-contact cost after all overrides\n';
                csv += '5. Total Savings at the bottom sums all individual savings calculations\n';
                
                // Download the file
                ExportUtils.downloadFile(csv, `roi_calculator_excel_${new Date().toISOString().split('T')[0]}.xls`, 'application/vnd.ms-excel');
            };

            const exportToJSON = () => {
                const dataToExport = {
                    categories,
                    channelCosts,
                    categoryCosts,
                    useCases,
                    dateRange,
                    financialSettings,
                    ahtNegotiationMode,
                    // defaultAHT and agentUtilization removed - now in category config
                    metricValues,
                    dataTemplates,
                    exportDate: new Date().toISOString(),
                    version: '4.1',
                    description: 'Multi-benefit AI ROI calculator backup with quality metrics support',
                    features: {
                        multiBenefitSupport: true,
                        qualityMetrics: true,
                        agentUtilization: true,
                        bulkDataEntry: true,
                        categoryChannelHierarchy: true
                    }
                };
                
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            };
            
            // Debug function to find export discrepancies
            const findExportDiscrepancy = () => {
                console.log('=== Finding Export vs UI Discrepancies ===');
                console.log('AHT Negotiation Mode:', ahtNegotiationMode ? 'ON' : 'OFF');
                
                // First, let's check what the UI total shows
                const displayedUITotal = calculateTotalSavings();
                console.log(`Displayed UI Total: $${displayedUITotal.toFixed(2)}`);
                
                let uiTotal = 0;
                let simulatedExcelTotal = 0;
                const differences = [];
                let rowDetails = [];
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            
                            // UI calculation
                            const uiSavings = calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                            uiTotal += uiSavings;
                            
                            // Simulate what Excel formula would calculate
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            
                            const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                            const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                            const baseline = benefit.baselineValue || 0;
                            const metricConfig = METRIC_CONFIG[benefit.metric];
                            // Calculate net improvement based on metric type
                            let netImprovement;
                            if (metricConfig && metricConfig.inverseMetric) {
                                netImprovement = Math.max(0, baseline - improvement);
                            } else {
                                netImprovement = Math.max(0, improvement - baseline);
                            }
                            const effectiveCost = getEffectiveCost(uc, uc.channel);

                            // Simulate Excel calculation based on benefit type
                            let excelSavings = 0;
                            
                            if (volume > 0 && netImprovement > 0 && metricConfig) {
                                switch (metricConfig.type) {
                                    case 'time_cost': {
                                        const aht = getApplicableAHT(uc) || 10;
                                        const originalAHT = Math.max(0.01, parseFloat(aht) || 10);
                                        const costConfig = getCostConfiguration(uc);
                                        
                                        if (ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                                            // Excel formula: =G*K*(1-MAX(0.01,originalAHT-J)/originalAHT)
                                            const newAHT = Math.max(0.01, originalAHT - netImprovement);
                                            excelSavings = volume * effectiveCost * (1 - newAHT/originalAHT);
                                        } else if (!ahtNegotiationMode && costConfig && costConfig.costType === 'perContact') {
                                            excelSavings = 0;
                                        } else {
                                            // Hourly: =G*MIN(J,aht)*(K/aht)
                                            const cappedMinutes = Math.min(netImprovement, originalAHT);
                                            excelSavings = volume * cappedMinutes * (effectiveCost / originalAHT);
                                        }
                                        break;
                                    }
                                    case 'percentage_cost':
                                        // =G*(J/100)*K
                                        excelSavings = volume * (netImprovement / 100) * effectiveCost;
                                        break;
                                    case 'fcr_special':
                                        // =G*(J/100)*K*0.3
                                        excelSavings = volume * (netImprovement / 100) * effectiveCost * 0.3;
                                        break;
                                    case 'points_value':
                                        const pointValue = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                        // =G*J*value
                                        excelSavings = volume * netImprovement * pointValue;
                                        break;
                                    case 'percentage_value':
                                        const percentValue = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                        // =G*(J/100)*value
                                        excelSavings = volume * (netImprovement / 100) * percentValue;
                                        break;
                                }
                            }
                            
                            simulatedExcelTotal += excelSavings;
                            
                            // Store all row details for inspection
                            if (volume > 0 && netImprovement > 0) {
                                rowDetails.push({
                                    useCase: uc.name,
                                    benefit: benefit.metric,
                                    month: `${month.month} ${month.year}`,
                                    volume: volume,
                                    netImp: netImprovement,
                                    cost: effectiveCost.toFixed(2),
                                    ui: uiSavings.toFixed(2),
                                    excel: excelSavings.toFixed(2)
                                });
                            }
                            
                            // Check for differences
                            const diff = Math.abs(uiSavings - excelSavings);
                            if (diff > 0.001) {
                                differences.push({
                                    useCase: uc.name,
                                    benefit: benefit.metric,
                                    month: `${month.month} ${month.year}`,
                                    ui: uiSavings.toFixed(2),
                                    excel: excelSavings.toFixed(2),
                                    diff: (uiSavings - excelSavings).toFixed(2)
                                });
                            }
                        });
                    });
                });
                
                console.log(`UI Total (sum of calculations): $${uiTotal.toFixed(2)}`);
                console.log(`Simulated Excel Total: $${simulatedExcelTotal.toFixed(2)}`);
                console.log(`Total Difference: $${(uiTotal - simulatedExcelTotal).toFixed(2)}`);
                
                // Check if our calculated total matches what's displayed
                if (Math.abs(displayedUITotal - uiTotal) > 0.01) {
                    console.log(`‚ö†Ô∏è WARNING: Displayed UI total ($${displayedUITotal.toFixed(2)}) differs from calculated sum ($${uiTotal.toFixed(2)})`);
                }
                
                if (differences.length > 0) {
                    console.log('\\nRow-by-row differences:');
                    console.table(differences);
                } else {
                    console.log('No significant differences found in individual rows.');
                }
                
                // Show sample of row details
                console.log(`\\nTotal rows with data: ${rowDetails.length}`);
                if (rowDetails.length > 0) {
                    console.log('Sample rows (first 5):');
                    console.table(rowDetails.slice(0, 5));
                }
                
                return { displayedUITotal, uiTotal, simulatedExcelTotal, differences, rowDetails };
            };
            
            // Make it available globally for debugging
            window.findExportDiscrepancy = findExportDiscrepancy;

            const importJSON = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            // Track what was imported for user feedback
                            const importSummary = [];
                            
                            // Import core data
                            if (importedData.channelCosts) {
                                setChannelCosts(importedData.channelCosts);
                                importSummary.push(`${Object.keys(importedData.channelCosts).length} channel costs`);
                            }
                            if (importedData.categoryCosts) {
                                setCategoryCosts(importedData.categoryCosts);
                                importSummary.push(`${Object.keys(importedData.categoryCosts).length} category configurations`);
                                
                                // Sync categories from both sources
                                const importedCategories = importedData.categories || [];
                                const categoriesFromCosts = Object.keys(importedData.categoryCosts);
                                const allCategories = Array.from(new Set([...importedCategories, ...categoriesFromCosts]));
                                setCategories(allCategories);
                                importSummary.push(`${allCategories.length} total categories`);
                            } else if (importedData.categories) {
                                setCategories(importedData.categories);
                                importSummary.push(`${importedData.categories.length} categories`);
                            }
                            if (importedData.useCases) {
                                // Count total benefits in imported use cases
                                const totalBenefits = importedData.useCases.reduce((sum, uc) => {
                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                    return sum + normalizedUC.benefits.length;
                                }, 0);
                                setUseCases(importedData.useCases);
                                importSummary.push(`${importedData.useCases.length} use cases with ${totalBenefits} total benefits`);
                            }
                            if (importedData.dateRange) {
                                setDateRange(importedData.dateRange);
                                setMonths(generateMonthsFromRange(importedData.dateRange.start, importedData.dateRange.end));
                                const monthCount = generateMonthsFromRange(importedData.dateRange.start, importedData.dateRange.end).length;
                                importSummary.push(`${monthCount} months of analysis period`);
                            }
                            // Global defaults removed - configuration at category-channel level
                            if (importedData.metricValues) {
                                setMetricValues(importedData.metricValues);
                                importSummary.push(`${Object.keys(importedData.metricValues).length} quality metric values`);
                            }
                            if (importedData.dataTemplates) {
                                setDataTemplates(importedData.dataTemplates);
                                importSummary.push(`${Object.keys(importedData.dataTemplates).length} data templates`);
                            }
                            if (importedData.financialSettings) {
                                setFinancialSettings(importedData.financialSettings);
                                const hasCategoryBilling = importedData.financialSettings.useCategoryBilling ? 'category-based' : 'global';
                                importSummary.push(`Financial settings (${hasCategoryBilling} billing)`);
                            }
                            if (typeof importedData.ahtNegotiationMode === 'boolean') {
                                setAhtNegotiationMode(importedData.ahtNegotiationMode);
                                if (importedData.ahtNegotiationMode) {
                                    importSummary.push('AHT negotiation mode enabled');
                                }
                            }
                            
                            // Show detailed import summary
                            const version = importedData.version || 'Unknown';
                            const featureInfo = importedData.features ? 
                                `\n\nFeatures: ${Object.entries(importedData.features).filter(([k,v]) => v).map(([k]) => k).join(', ')}` : '';
                            alert(`Data imported successfully!\n\nVersion: ${version}\nImported: ${importSummary.join(', ')}${featureInfo}`);
                        } catch (error) {
                            alert(`Error importing file: ${error.message}\n\nPlease ensure it's a valid JSON backup file from the AI ROI Calculator.`);
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
                // Reset the file input
                event.target.value = '';
            };

            // Export comprehensive cost configuration including quality metrics
            const exportCostConfigurationCSV = () => {
                let csv = '=== AI ROI CALCULATOR COST & VALUE CONFIGURATION EXPORT ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                // Global defaults removed - configuration at category-channel level
                csv += '\n';
                
                // Quality Metric Values
                csv += '=== QUALITY METRIC VALUES ===\n';
                csv += 'Metric Name,Dollar Value (USD),Unit,Description,Usage\n';
                Object.entries(metricValues).forEach(([key, config]) => {
                    let usage = '';
                    switch(key) {
                        case 'npsImprovement': usage = 'Multiply by NPS points improved'; break;
                        case 'csatImprovement': usage = 'Multiply by CSAT percentage improved'; break;
                        case 'fcrImprovement': usage = 'Multiply by FCR percentage improved'; break;
                        case 'conversionRate': usage = 'Average deal value for conversion improvements'; break;
                        case 'agentRetention': usage = 'Cost to replace one agent'; break;
                        case 'complianceRate': usage = 'Cost per compliance violation avoided'; break;
                        default: usage = 'Per unit improvement value';
                    }
                    csv += `"${config.label}",${config.value},USD,"Quality improvement monetary value","${usage}"\n`;
                });
                
                // Channel Costs
                csv += '\n=== CHANNEL DEFAULT COSTS ===\n';
                csv += 'Channel,Cost Type,Value (USD),AHT (min),Effective $/Contact,Priority Level,Calculation Formula\n';
                Object.entries(channelCosts).forEach(([channel, costData]) => {
                    const normalized = typeof costData === 'object' ? costData : { costType: 'perContact', value: costData, ahtMinutes: defaultAHT };
                    let effectiveCost = normalized.value;
                    let formula = 'Direct per-contact cost';
                    
                    if (normalized.costType === 'hourly') {
                        const aht = normalized.ahtMinutes || defaultAHT;
                        const utilization = normalized.utilization || 75;
                        effectiveCost = (normalized.value * aht / 60) * (100 / utilization);
                        formula = `(Hourly_Rate √ó AHT_Minutes / 60) √ó (100 / Agent_Utilization%)`;
                    }
                    
                    csv += `${channel},${normalized.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${normalized.value},${normalized.ahtMinutes || defaultAHT},${effectiveCost.toFixed(2)},4 (Lowest),"${formula}"\n`;
                });
                
                // Category Costs with detailed hierarchy
                csv += '\n=== CATEGORY COST HIERARCHY ===\n';
                csv += 'Category,Channel,Special Group,Cost Type,Value,AHT (min),Priority Level,Scope\n';
                
                Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                    // Category defaults
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        const aht = typeof defaultCost.ahtMinutes === 'number' ? defaultCost.ahtMinutes : 10;
                        csv += `${category},All Channels,,${defaultCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${defaultCost.value},${aht},3 (Medium),Category default for all channels\n`;
                    }
                    
                    // Category-Channel specifics
                    Object.entries(categoryData).forEach(([channel, channelData]) => {
                        if (channel !== '_default' && channelData && channelData._default) {
                            const channelCost = channelData._default;
                            const aht = typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : 10;
                            csv += `${category},${channel},,${channelCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${channelCost.value},${aht},2 (High),Category-channel specific\n`;
                            
                            // Special groups
                            if (channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = typeof groupData.ahtMinutes === 'number' ? groupData.ahtMinutes : 10;
                                    csv += `${category},${channel},${group},${groupData.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${groupData.value},${aht},1 (Highest),Special group override\n`;
                                });
                            }
                        }
                    });
                });
                
                // Cost Calculation Examples
                csv += '\n=== COST CALCULATION EXAMPLES ===\n';
                csv += 'Scenario,Formula,Example Calculation,Result\n';
                csv += 'Hourly Rate Cost per Contact,"(Hourly Rate √ó AHT) / 60","($30/hr √ó 8 min) / 60","$4.00 per contact"\n';
                csv += 'Hourly Rate Cost per Minute,"Hourly Rate / 60","$30/hr / 60","$0.50 per minute"\n';
                csv += 'Deflection Savings,"Volume √ó (Rate% - Baseline%) √ó Cost","1000 √ó (70% - 10%) √ó $4.00","$2,400"\n';
                csv += 'NPS Value,"Volume √ó Points √ó Value per Point","1000 √ó 2 points √ó $50","$100,000"\n';
                csv += 'CSAT Value,"Volume √ó (Rate% - Baseline%) √ó Value per Point","1000 √ó (85% - 75%) √ó $25","$2,500"\n';
                
                // Configuration Summary
                csv += '\n=== CONFIGURATION SUMMARY ===\n';
                csv += 'Setting,Value,Impact\n';
                csv += `Total Channels,${Object.keys(channelCosts).length},Base cost options\n`;
                csv += `Total Categories,${Object.keys(categoryCosts).length},Category-specific overrides\n`;
                
                // Count special groups
                let totalSpecialGroups = 0;
                Object.values(categoryCosts).forEach(categoryData => {
                    Object.values(categoryData).forEach(channelData => {
                        if (channelData && channelData._specialGroups) {
                            totalSpecialGroups += Object.keys(channelData._specialGroups).length;
                        }
                    });
                });
                csv += `Total Special Groups,${totalSpecialGroups},Highest priority overrides\n`;
                csv += `Quality Metrics,${Object.keys(metricValues).length},Non-cost value drivers\n`;
                
                // Priority explanation
                csv += '\n=== COST PRIORITY EXPLANATION ===\n';
                csv += 'Priority,Source,Description,When Used\n';
                csv += '1 (Highest),Special Group,Agent group-specific costs,When use case has special group assigned\n';
                csv += '2 (High),Category-Channel,Category and channel specific,When category has channel-specific cost\n';
                csv += '3 (Medium),Category Default,Category fallback cost,When category exists but no channel override\n';
                csv += '4 (Lowest),Channel Default,Base channel cost,When no category overrides exist\n';
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cost_configuration_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const clearAllDataAndReset = () => {
                if (window.confirm('Clear all data? This cannot be undone.')) {
                    localStorage.removeItem('aiValueCalculatorData');
                    window.location.reload();
                }
            };

            // Guidance Modal Component
            const GuidanceModal = () => {
                if (!showGuidanceModal || !selectedMetricGuide) return null;
                
                const guide = InputGuidance[selectedMetricGuide];
                if (!guide) return null;
                
                return (
                    <div className="modal-overlay" onClick={() => setShowGuidanceModal(false)}>
                        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                            <div className="modal-close" onClick={() => setShowGuidanceModal(false)}>
                                <Icons.Close />
                            </div>
                            
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">
                                Input Guide: {selectedMetricGuide}
                            </h2>
                            
                            <div className="space-y-4">
                                {/* Calculation Formula */}
                                {guide.improvement && guide.improvement.formula && (
                                    <div className="guidance-card" style={{borderLeftColor: '#10B981', backgroundColor: '#F0FDF4'}}>
                                        <div className="guidance-title">üßÆ How ROI is Calculated</div>
                                        <div className="guidance-content">
                                            <div className="example-box" style={{backgroundColor: '#DCFCE7'}}>
                                                <strong>Formula:</strong> {guide.improvement.formula}
                                            </div>
                                            {selectedMetricGuide && selectedMetricGuide.includes('FCR') && (
                                                <p className="text-sm mt-2 text-green-700">
                                                    FCR improvements prevent repeat calls, saving contact handling costs
                                                </p>
                                            )}
                                            {selectedMetricGuide && selectedMetricGuide.includes('NPS') && (
                                                <p className="text-sm mt-2 text-blue-700">
                                                    NPS improvements increase customer lifetime value and reduce churn
                                                </p>
                                            )}
                                            {selectedMetricGuide && selectedMetricGuide.includes('CSAT') && (
                                                <p className="text-sm mt-2 text-purple-700">
                                                    CSAT improvements drive retention and positive word-of-mouth
                                                </p>
                                            )}
                                            {guide.improvement.dollarConversion && (
                                                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                    <p className="text-sm text-yellow-800">
                                                        {guide.improvement.dollarConversion}
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Volume Warning */}
                                {guide.volume && (guide.volume.warning || guide.volume.note) && (
                                    <div className="guidance-card" style={{borderLeftColor: guide.volume.warning ? '#FBbD23' : '#3B82F6'}}>
                                        <div className="guidance-content">
                                            {guide.volume.warning && (
                                                <div className="p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                    {guide.volume.warning}
                                                </div>
                                            )}
                                            {guide.volume.note && (
                                                <div className="p-3 bg-blue-50 border border-blue-200 rounded mt-2">
                                                    {guide.volume.note}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">üìä Baseline Value</div>
                                    <div className="guidance-content">
                                        <p>{guide.baseline.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.baseline.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.baseline.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">üìà Volume Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.volume.description}</p>
                                        <div className="example-box">
                                            <strong>Calculation:</strong> {guide.volume.calculation}
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.volume.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">‚úÖ Improvement Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.improvement.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.improvement.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.improvement.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">üèÜ Industry Benchmarks</div>
                                    <div className="guidance-content">
                                        <div className="grid grid-cols-2 gap-3">
                                            {Object.entries(guide.industryBenchmarks).map(([useCase, benchmark]) => (
                                                <div key={useCase} className="metric-item">
                                                    <div className="metric-label">{useCase}</div>
                                                    <div className="metric-value">{benchmark}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className={`min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 ${isMobile ? 'p-0' : 'p-2 lg:p-4'}`}>
                    {/* Sponsor Overlay */}
                    {showSponsorOverlay && (
                        <div className={`sponsor-overlay ${isClosingWithHearts ? 'closing' : ''}`} 
                             onClick={() => setShowSponsorOverlay(false)}
                             id="sponsor-overlay">
                            <div className="sponsor-content" onClick={(e) => e.stopPropagation()}>
                                <div className="heart-icon">
                                    <svg className="w-24 h-24 mx-auto mb-6" fill="currentColor" viewBox="0 0 20 20">
                                        <path fillRule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clipRule="evenodd" />
                                    </svg>
                                </div>
                                <h2 className="text-3xl font-bold mb-4">Thank You for Supporting!</h2>
                                <p className="text-lg mb-6 opacity-90">
                                    Your sponsorship helps keep this ROI Calculator free and continuously improved.
                                    Every contribution enables new features and better analytics.
                                </p>
                                <div className="flex gap-4 justify-center">
                                    <a
                                        href="https://github.com/sponsors/Maniwar"
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="px-6 py-3 bg-white text-purple-600 rounded-lg font-semibold hover:bg-gray-100 transition-colors"
                                        onClick={() => setShowSponsorOverlay(false)}
                                    >
                                        Continue to GitHub Sponsors ‚Üí
                                    </a>
                                    <button
                                        onClick={() => {
                                            // Create floating hearts
                                            const overlay = document.getElementById('sponsor-overlay');
                                            for (let i = 0; i < 8; i++) {
                                                setTimeout(() => {
                                                    const heart = document.createElement('div');
                                                    heart.className = 'floating-heart';
                                                    heart.style.left = `${Math.random() * 100}%`;
                                                    heart.style.top = `${50 + Math.random() * 30}%`;
                                                    heart.style.setProperty('--float-x', `${(Math.random() - 0.5) * 100}px`);
                                                    heart.style.fontSize = `${20 + Math.random() * 30}px`;
                                                    heart.innerHTML = '‚ô•';
                                                    overlay.appendChild(heart);
                                                }, i * 100);
                                            }
                                            
                                            // Start fade out animation
                                            setIsClosingWithHearts(true);
                                            setTimeout(() => {
                                                setShowSponsorOverlay(false);
                                                setIsClosingWithHearts(false);
                                            }, 800);
                                        }}
                                        className="px-6 py-3 bg-transparent border-2 border-white text-white rounded-lg font-semibold hover:bg-white hover:bg-opacity-10 transition-colors"
                                    >
                                        Maybe Later
                                    </button>
                                </div>
                                <p className="text-sm mt-6 opacity-75">
                                    Join other businesses saving millions with data-driven ROI insights
                                </p>
                            </div>
                        </div>
                    )}
                    
                    <div className="w-full px-2 lg:px-4">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-3 mb-3">
                            <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex justify-between items-center'} mb-4`}>
                                <div>
                                    <h1 className={`${isMobile ? 'text-2xl' : 'text-3xl'} font-bold flex items-center gap-3`}>
                                        <span className="logo-animated">
                                            <svg width={isMobile ? "30" : "40"} height={isMobile ? "30" : "40"} viewBox="0 0 40 40" className="logo-rotate">
                                                <defs>
                                                    <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                        <stop offset="0%" stopColor="#3B82F6" />
                                                        <stop offset="50%" stopColor="#8B5CF6" />
                                                        <stop offset="100%" stopColor="#EC4899" />
                                                    </linearGradient>
                                                </defs>
                                                <circle cx="20" cy="20" r="18" fill="none" stroke="url(#logoGradient)" strokeWidth="2" strokeDasharray="5 2" />
                                                <circle cx="20" cy="12" r="3" fill="url(#logoGradient)" />
                                                <circle cx="13" cy="23" r="3" fill="url(#logoGradient)" />
                                                <circle cx="27" cy="23" r="3" fill="url(#logoGradient)" />
                                                <path d="M20 12 L13 23 L27 23 Z" fill="none" stroke="url(#logoGradient)" strokeWidth="1.5" />
                                                <circle cx="20" cy="20" r="2" fill="url(#logoGradient)" opacity="0.8">
                                                    <animate attributeName="r" values="2;4;2" dur="2s" repeatCount="indefinite" />
                                                    <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2s" repeatCount="indefinite" />
                                                </circle>
                                            </svg>
                                        </span>
                                        <span className="title-gradient">{isMobile ? 'AI ROI Calculator' : 'AI Contact Center ROI Calculator'}</span>
                                    </h1>
                                    <p className={`text-gray-600 mt-2 flex items-center gap-2 ${isMobile ? 'text-sm' : ''}`}>
                                        <span className="inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                                        {isMobile ? 'Advanced cost modeling' : 'Advanced cost modeling with category and group pricing'}
                                    </p>
                                    {showSaveIndicator && (
                                        <p className="text-green-600 text-sm mt-1 flex items-center gap-1">
                                            <Icons.Save /> Auto-saved
                                        </p>
                                    )}
                                </div>
                                <div className={`${isMobile ? 'grid grid-cols-2 gap-2 w-full' : 'flex gap-3'} no-print`}>
                                    <button
                                        onClick={() => setShowSettings(!showSettings)}
                                        className={`flex items-center ${isMobile ? 'justify-center px-3 py-1.5' : 'px-4 py-2'} gap-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700`}
                                    >
                                        <Icons.Settings /> <span className={isMobile ? 'text-xs' : ''}>Cost Settings</span>
                                    </button>
                                    <button
                                        onClick={clearAllDataAndReset}
                                        className={`flex items-center ${isMobile ? 'justify-center px-3 py-1.5' : 'px-4 py-2'} gap-2 bg-red-600 text-white rounded-lg hover:bg-red-700`}
                                    >
                                        <Icons.Clear /> <span className={isMobile ? 'text-xs' : ''}>Clear All</span>
                                    </button>
                                </div>
                            </div>
                            
                            {/* Tabs */}
                            <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex gap-2 justify-between items-center'} mb-4`}>
                                <div className={`${isMobile ? 'tab-container' : 'flex gap-2'}`}>
                                    <button
                                        onClick={() => setActiveTab('data')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'data' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Data Entry
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('analytics')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'analytics' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Analytics & Reports
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('financial')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'financial' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Financial Analysis
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('guidance')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'guidance' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Input Guidance
                                    </button>
                                </div>
                                {!isMobile && (
                                    <button
                                        onClick={() => setShowSponsorOverlay(true)}
                                        className="flex items-center gap-1 px-3 py-1.5 text-sm bg-gradient-to-r from-pink-500 to-purple-600 text-white rounded-lg hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-sm"
                                        title="Support this free tool with GitHub Sponsors"
                                    >
                                        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clipRule="evenodd" />
                                        </svg>
                                        <span>Sponsor</span>
                                    </button>
                                )}
                            </div>
                            
                            {/* Action Buttons */}
                            {activeTab === 'data' && (
                                <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-3 items-center'}`}>
                                    <button
                                        onClick={exportToExcel}
                                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        title="Export to Excel with live formulas - all calculations are automatic and traceable!"
                                    >
                                        <Icons.Chart /> Export to Excel
                                    </button>
                                    <button
                                        onClick={exportToJSON}
                                        className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                        title="Export complete backup including all data, settings, and use cases (JSON format, importable)"
                                    >
                                        <Icons.FileText /> Full Backup (JSON)
                                    </button>
                                    <button
                                        onClick={exportCostConfigurationCSV}
                                        className="flex items-center gap-2 px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700"
                                        title="Export cost configuration report for documentation (CSV format, read-only)"
                                    >
                                        <Icons.Settings /> Config Report (CSV)
                                    </button>
                                    {(window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === 'file') && (
                                        <button
                                            onClick={() => {
                                                const results = verifyAllExports();
                                                const message = results.failed === 0 
                                                    ? `‚úÖ All ${results.tests.length} export tests PASSED!\n\nUI Total: $${Math.round(results.tests[0].expected).toLocaleString()}`
                                                    : `‚ùå ${results.failed} of ${results.tests.length} tests FAILED\n\n${results.tests.filter(t => !t.passed).map(t => `${t.name}: Expected $${Math.round(t.expected).toLocaleString()}, Got $${Math.round(t.actual).toLocaleString()}`).join('\n')}\n\nCheck console for details.`;
                                                alert(message);
                                            }}
                                            className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                            title="Verify all export totals match UI totals"
                                        >
                                            <Icons.CheckCircle /> Verify Exports
                                        </button>
                                    )}
                                    <button
                                        onClick={() => fileInputRef.current.click()}
                                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        title="Import a previously exported JSON backup file"
                                    >
                                        <Icons.Upload /> Import Backup
                                    </button>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept=".json"
                                        onChange={importJSON}
                                        style={{ display: 'none' }}
                                    />
                                </div>
                            )}
                            
                            {/* Summary Cards */}
                            <div className="mt-4">
                                {/* Stats Cards */}
                                {(() => {
                                    const avgNPS = calculateAvgNPS();
                                    const avgCSAT = calculateAvgCSAT();
                                    const hasQualitative = avgNPS > 0 || avgCSAT > 0;
                                    const gridCols = hasQualitative ? (isMobile ? 'grid-cols-2' : 'grid-cols-7') : (isMobile ? 'grid-cols-2' : 'grid-cols-5');

                                    return (
                                        <div className={`grid ${gridCols} gap-2 lg:gap-4`}>
                                            <div className="bg-blue-50 rounded-lg p-4">
                                                <p className="text-blue-600 text-sm">Use Cases</p>
                                                <p className="text-2xl font-bold">{getFilteredUseCases().length}</p>
                                            </div>
                                            <div className="bg-green-50 rounded-lg p-4">
                                                <p className="text-green-600 text-sm">Months</p>
                                                <p className="text-2xl font-bold">{getFilteredMonths().length}</p>
                                            </div>
                                            <div className="bg-blue-50 rounded-lg p-4">
                                                <p className="text-blue-600 text-sm">Cost Savings</p>
                                                <p className="text-xl font-bold">
                                                    ${Math.round(calculateCostSavings()).toLocaleString()}
                                                </p>
                                            </div>
                                            <div className="bg-green-50 rounded-lg p-4">
                                                <p className="text-green-600 text-sm">Revenue Impact</p>
                                                <p className="text-xl font-bold">
                                                    ${Math.round(calculateRevenueImpact()).toLocaleString()}
                                                </p>
                                            </div>
                                            <div className="bg-purple-50 rounded-lg p-4">
                                                <p className="text-purple-600 text-sm">Total Value</p>
                                                <p className="text-xl font-bold">
                                                    ${Math.round(calculateTotalSavings()).toLocaleString()}
                                                </p>
                                            </div>
                                            {avgNPS > 0 && (
                                                <div className="bg-indigo-50 rounded-lg p-4">
                                                    <p className="text-indigo-600 text-sm">Avg NPS Œî</p>
                                                    <p className="text-xl font-bold">
                                                        +{avgNPS.toFixed(1)} pts
                                                    </p>
                                                </div>
                                            )}
                                            {avgCSAT > 0 && (
                                                <div className="bg-amber-50 rounded-lg p-4">
                                                    <p className="text-amber-600 text-sm">Avg CSAT Œî</p>
                                                    <p className="text-xl font-bold">
                                                        +{avgCSAT.toFixed(1)}%
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })()}

                                {/* Date Range Selector - Below Stats */}
                                <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center justify-center gap-2'} bg-gray-50 rounded-lg p-3 mt-3`}>
                                    <div className="flex items-center gap-2">
                                        <Icons.Calendar className="text-gray-500" />
                                        <span className="text-sm font-medium text-gray-700">Date Range:</span>
                                    </div>
                                    <div className={`${isMobile ? 'flex flex-col gap-2 w-full' : 'flex items-center gap-2'}`}>
                                        <input
                                            type="month"
                                            value={dateRange.start}
                                            onChange={(e) => setDateRange({ ...dateRange, start: e.target.value })}
                                            className={`px-2 py-1 text-sm border rounded bg-white ${isMobile ? 'w-full' : ''}`}
                                            title="Start Month"
                                        />
                                        <span className={`text-sm text-gray-500 ${isMobile ? 'text-center' : ''}`}>to</span>
                                        <input
                                            type="month"
                                            value={dateRange.end}
                                            onChange={(e) => setDateRange({ ...dateRange, end: e.target.value })}
                                            className={`px-2 py-1 text-sm border rounded bg-white ${isMobile ? 'w-full' : ''}`}
                                            title="End Month"
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Advanced Settings Panel */}
                        {showSettings && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Advanced Settings</h2>
                                {/* Global defaults removed - all configuration at category level including quality metrics */}
                                
                                {/* Category Manager */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Plus /> Manage Categories
                                    </h3>
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>üìÅ Categories:</strong> Add, edit, or remove business categories. Categories organize your use cases and cost configurations.
                                    </div>
                                    
                                    <div className="space-y-3">
                                        {/* Add new category */}
                                        <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex gap-2'}`}>
                                            <input
                                                type="text"
                                                value={newCategoryName}
                                                onChange={(e) => setNewCategoryName(e.target.value)}
                                                placeholder="Enter new category name..."
                                                className="flex-1 px-3 py-2 border rounded"
                                                onKeyPress={(e) => {
                                                    if (e.key === 'Enter' && newCategoryName.trim()) {
                                                        addCategory(newCategoryName.trim());
                                                        setNewCategoryName('');
                                                    }
                                                }}
                                            />
                                            <button
                                                onClick={() => {
                                                    if (newCategoryName.trim()) {
                                                        addCategory(newCategoryName.trim());
                                                        setNewCategoryName('');
                                                    }
                                                }}
                                                className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                            >
                                                <Icons.Plus /> Add Category
                                            </button>
                                        </div>
                                        
                                        {/* List existing categories */}
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-2 gap-2'}`}>
                                            {categories.map(category => (
                                                <div key={category} className="flex items-center justify-between p-2 bg-white border rounded">
                                                    {editingCategory === category ? (
                                                        <input
                                                            type="text"
                                                            defaultValue={category}
                                                            className="flex-1 px-2 py-1 border rounded mr-2"
                                                            autoFocus
                                                            onBlur={(e) => {
                                                                if (e.target.value.trim() && e.target.value !== category) {
                                                                    editCategory(category, e.target.value.trim());
                                                                }
                                                                setEditingCategory(null);
                                                            }}
                                                            onKeyPress={(e) => {
                                                                if (e.key === 'Enter') {
                                                                    if (e.target.value.trim() && e.target.value !== category) {
                                                                        editCategory(category, e.target.value.trim());
                                                                    }
                                                                    setEditingCategory(null);
                                                                }
                                                            }}
                                                        />
                                                    ) : (
                                                        <>
                                                            <span className="font-medium">{category}</span>
                                                            <div className="flex gap-1">
                                                                <button
                                                                    onClick={() => setEditingCategory(category)}
                                                                    className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                                                                    title="Edit category"
                                                                >
                                                                    ‚úèÔ∏è
                                                                </button>
                                                                <button
                                                                    onClick={() => removeCategory(category)}
                                                                    className="p-1 text-red-600 hover:bg-red-50 rounded"
                                                                    title="Delete category"
                                                                >
                                                                    üóëÔ∏è
                                                                </button>
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                        
                                        {categories.length === 0 && (
                                            <div className="text-gray-500 italic">No categories defined. Add your first category above.</div>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Category-Specific Metric Values */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Chart /> Category-Specific Metric Values
                                    </h3>
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>üí° Category Metric Values:</strong> Set NPS values, agent retention costs, etc. for each category.
                                        These values are required for quality metric calculations to work.
                                    </div>
                                    
                                    {categories.length === 0 ? (
                                        <div className="text-gray-500 italic">No categories defined. Add categories above to configure metric values.</div>
                                    ) : (
                                        <div className="space-y-4">
                                            {categories.map(category => (
                                                <div key={category} className="border rounded-lg p-4">
                                                    <h4 className="font-medium mb-3 text-blue-700 text-sm">{category}</h4>
                                                    <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-2 gap-4'}`}>
                                                        {Object.entries(METRIC_DEFINITIONS).map(([key, def]) => {
                                                            const categoryMetricValue = categoryCosts[category]?.metricValues?.[key];

                                                            // Special handling for NPS and CSAT - skip them here, we have dedicated config panels below
                                                            if (key === 'npsImprovement' || key === 'csatImprovement') return null;

                                                            return (
                                                                <div key={key} className="flex items-center gap-2">
                                                                    <label className="text-xs flex-1">{def.label}:</label>
                                                                    <input
                                                                        type="number"
                                                                        placeholder="Required"
                                                                        value={categoryMetricValue?.value || ''}
                                                                        onChange={(e) => {
                                                                            const newValue = e.target.value ? parseFloat(e.target.value) : 0;
                                                                            setCategoryCosts(prev => ({
                                                                                ...prev,
                                                                                [category]: {
                                                                                    ...prev[category],
                                                                                    metricValues: {
                                                                                        ...(prev[category]?.metricValues || {}),
                                                                                        [key]: { ...def, value: newValue }
                                                                                    }
                                                                                }
                                                                            }));
                                                                        }}
                                                                        className="settings-input w-28"
                                                                        step="0.01"
                                                                        min="0"
                                                                    />
                                                                </div>
                                                            );
                                                        })}
                                                    </div>

                                                    {/* NPS Configuration - Special Section */}
                                                    {(() => {
                                                        const npsConfig = categoryCosts[category]?.metricValues?.npsImprovement || getDefaultNPSConfig();
                                                        const mode = npsConfig.mode || 'monetary';
                                                        const calcMethod = npsConfig.calculationMethod || 'retention_based';

                                                        return (
                                                            <div className="mt-4 pt-4 border-t">
                                                                <h5 className="font-semibold text-xs mb-3 flex items-center gap-2">
                                                                    <span>üìä</span> NPS Improvement Configuration
                                                                </h5>

                                                                {/* Mode Selection */}
                                                                <div className="mb-3 p-2 bg-gray-50 rounded">
                                                                    <div className="text-xs font-medium mb-2">Tracking Mode:</div>
                                                                    <label className="flex items-center gap-2 mb-1.5 cursor-pointer">
                                                                        <input
                                                                            type="radio"
                                                                            checked={mode === 'monetary'}
                                                                            onChange={() => {
                                                                                setCategoryCosts(prev => ({
                                                                                    ...prev,
                                                                                    [category]: {
                                                                                        ...prev[category],
                                                                                        metricValues: {
                                                                                            ...(prev[category]?.metricValues || {}),
                                                                                            npsImprovement: {
                                                                                                ...npsConfig,
                                                                                                mode: 'monetary',
                                                                                                calculationMethod: npsConfig.calculationMethod || 'retention_based'
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }));
                                                                            }}
                                                                        />
                                                                        <span className="text-xs">Include in Financial ROI ($ value)</span>
                                                                    </label>
                                                                    <label className="flex items-center gap-2 cursor-pointer">
                                                                        <input
                                                                            type="radio"
                                                                            checked={mode === 'non-monetary'}
                                                                            onChange={() => {
                                                                                setCategoryCosts(prev => ({
                                                                                    ...prev,
                                                                                    [category]: {
                                                                                        ...prev[category],
                                                                                        metricValues: {
                                                                                            ...(prev[category]?.metricValues || {}),
                                                                                            npsImprovement: {
                                                                                                ...npsConfig,
                                                                                                mode: 'non-monetary',
                                                                                                calculationMethod: npsConfig.calculationMethod || 'retention_based'
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }));
                                                                            }}
                                                                        />
                                                                        <span className="text-xs">Track Separately (Non-monetary)</span>
                                                                    </label>
                                                                </div>

                                                                {/* Monetary Configuration */}
                                                                {mode === 'monetary' && (
                                                                    <div className="space-y-3">
                                                                        {/* Business Context */}
                                                                        <div className="grid grid-cols-2 gap-2">
                                                                            <div>
                                                                                <label className="block text-xs text-gray-600 mb-1">Industry:</label>
                                                                                <select
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    value={npsConfig.industry || 'Other'}
                                                                                    onChange={(e) => {
                                                                                        setCategoryCosts(prev => ({
                                                                                            ...prev,
                                                                                            [category]: {
                                                                                                ...prev[category],
                                                                                                metricValues: {
                                                                                                    ...(prev[category]?.metricValues || {}),
                                                                                                    npsImprovement: {
                                                                                                        ...npsConfig,
                                                                                                        mode: npsConfig.mode || 'monetary',
                                                                                                        calculationMethod: npsConfig.calculationMethod || 'retention_based',
                                                                                                        industry: e.target.value
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }));
                                                                                    }}
                                                                                >
                                                                                    <option>E-commerce</option>
                                                                                    <option>SaaS</option>
                                                                                    <option>Healthcare</option>
                                                                                    <option>Financial Services</option>
                                                                                    <option>Retail</option>
                                                                                    <option>Manufacturing</option>
                                                                                    <option>Professional Services</option>
                                                                                    <option>Other</option>
                                                                                </select>
                                                                            </div>

                                                                            <div>
                                                                                <label className="block text-xs text-gray-600 mb-1">Annual Customers:</label>
                                                                                <input
                                                                                    type="number"
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    placeholder="10000"
                                                                                    value={npsConfig.annualCustomers || ''}
                                                                                    onChange={(e) => {
                                                                                        setCategoryCosts(prev => ({
                                                                                            ...prev,
                                                                                            [category]: {
                                                                                                ...prev[category],
                                                                                                metricValues: {
                                                                                                    ...(prev[category]?.metricValues || {}),
                                                                                                    npsImprovement: {
                                                                                                        ...npsConfig,
                                                                                                        mode: npsConfig.mode || 'monetary',
                                                                                                        calculationMethod: npsConfig.calculationMethod || 'retention_based',
                                                                                                        annualCustomers: parseFloat(e.target.value) || 0
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }));
                                                                                    }}
                                                                                />
                                                                            </div>
                                                                        </div>

                                                                        <div>
                                                                            <label className="block text-xs text-gray-600 mb-1">Avg Customer Value/Year ($):</label>
                                                                            <input
                                                                                type="number"
                                                                                className="w-full px-2 py-1 text-xs border rounded"
                                                                                placeholder="100"
                                                                                value={npsConfig.avgCustomerValue || ''}
                                                                                onChange={(e) => {
                                                                                    setCategoryCosts(prev => ({
                                                                                        ...prev,
                                                                                        [category]: {
                                                                                            ...prev[category],
                                                                                            metricValues: {
                                                                                                ...(prev[category]?.metricValues || {}),
                                                                                                npsImprovement: {
                                                                                                    ...npsConfig,
                                                                                                    mode: npsConfig.mode || 'monetary',
                                                                                                    calculationMethod: npsConfig.calculationMethod || 'retention_based',
                                                                                                    avgCustomerValue: parseFloat(e.target.value) || 0
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }));
                                                                                }}
                                                                            />
                                                                        </div>

                                                                        {/* Retention Impact */}
                                                                        <div className="p-2 bg-blue-50 border border-blue-200 rounded">
                                                                            <div className="text-xs font-medium mb-2 text-blue-900">
                                                                                üéØ Retention Impact (Key Assumption)
                                                                            </div>

                                                                            <div className="mb-2">
                                                                                <label className="block text-xs text-gray-700 mb-1 font-medium">
                                                                                    Retention improvement per 10 NPS points (%):
                                                                                </label>
                                                                                <div className="flex items-center gap-2">
                                                                                    <input
                                                                                        type="number"
                                                                                        step="0.1"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded font-semibold"
                                                                                        placeholder="1.5"
                                                                                        value={npsConfig.retentionImpactPer10Points || ''}
                                                                                        onChange={(e) => {
                                                                                            setCategoryCosts(prev => ({
                                                                                                ...prev,
                                                                                                [category]: {
                                                                                                    ...prev[category],
                                                                                                    metricValues: {
                                                                                                        ...(prev[category]?.metricValues || {}),
                                                                                                        npsImprovement: {
                                                                                                            ...npsConfig,
                                                                                                            mode: npsConfig.mode || 'monetary',
                                                                                                            calculationMethod: npsConfig.calculationMethod || 'retention_based',
                                                                                                            retentionImpactPer10Points: parseFloat(e.target.value) || 0
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }));
                                                                                        }}
                                                                                    />
                                                                                    <span className="text-xs">%</span>
                                                                                    <div className="text-xs text-gray-600 ml-1">
                                                                                        (Typical for {npsConfig.industry || 'Other'}: {getTypicalRetention(npsConfig.industry || 'Other')}%)
                                                                                    </div>
                                                                                </div>
                                                                            </div>

                                                                            {/* Live Preview */}
                                                                            {npsConfig.annualCustomers > 0 && npsConfig.avgCustomerValue > 0 && npsConfig.retentionImpactPer10Points > 0 && (
                                                                                <div className="text-xs bg-white p-2 rounded border border-blue-200 mt-2">
                                                                                    <div className="font-medium mb-1">Calculated Value (per 10 NPS points):</div>
                                                                                    <div className="text-gray-700 space-y-0.5">
                                                                                        <div>‚Ä¢ {npsConfig.annualCustomers.toLocaleString()} customers √ó {npsConfig.retentionImpactPer10Points}% = {(npsConfig.annualCustomers * npsConfig.retentionImpactPer10Points / 100).toFixed(0)} retained</div>
                                                                                        <div>‚Ä¢ {(npsConfig.annualCustomers * npsConfig.retentionImpactPer10Points / 100).toFixed(0)} customers √ó ${npsConfig.avgCustomerValue} = ${((npsConfig.annualCustomers * npsConfig.retentionImpactPer10Points / 100) * npsConfig.avgCustomerValue).toLocaleString()}/year</div>
                                                                                        <div className="font-semibold text-blue-700 mt-1">
                                                                                            ‚Ä¢ Monthly value: ${(((npsConfig.annualCustomers * npsConfig.retentionImpactPer10Points / 100) * npsConfig.avgCustomerValue) / 12).toLocaleString()}
                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                )}

                                                                {/* Non-Monetary Info */}
                                                                {mode === 'non-monetary' && (
                                                                    <div className="p-2 bg-purple-50 border border-purple-200 rounded text-xs">
                                                                        NPS will be tracked as qualitative benefit (points improved) and displayed separately from financial ROI.
                                                                    </div>
                                                                )}
                                                            </div>
                                                        );
                                                    })()}

                                                    {/* CSAT Configuration - Special Section */}
                                                    {(() => {
                                                        const csatConfig = categoryCosts[category]?.metricValues?.csatImprovement || getDefaultCSATConfig();
                                                        const mode = csatConfig.mode || 'monetary';
                                                        const calcMethod = csatConfig.calculationMethod || 'retention_based';

                                                        return (
                                                            <div className="mt-4 pt-4 border-t">
                                                                <h5 className="font-semibold text-xs mb-3 flex items-center gap-2">
                                                                    <span>‚≠ê</span> CSAT Improvement Configuration
                                                                </h5>

                                                                {/* Mode Selection */}
                                                                <div className="mb-3 p-2 bg-gray-50 rounded">
                                                                    <div className="text-xs font-medium mb-2">Tracking Mode:</div>
                                                                    <label className="flex items-center gap-2 mb-1.5 cursor-pointer">
                                                                        <input
                                                                            type="radio"
                                                                            checked={mode === 'monetary'}
                                                                            onChange={() => {
                                                                                setCategoryCosts(prev => ({
                                                                                    ...prev,
                                                                                    [category]: {
                                                                                        ...prev[category],
                                                                                        metricValues: {
                                                                                            ...(prev[category]?.metricValues || {}),
                                                                                            csatImprovement: {
                                                                                                ...csatConfig,
                                                                                                mode: 'monetary',
                                                                                                calculationMethod: csatConfig.calculationMethod || 'retention_based'
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }));
                                                                            }}
                                                                        />
                                                                        <span className="text-xs">Include in Financial ROI ($ value)</span>
                                                                    </label>
                                                                    <label className="flex items-center gap-2 cursor-pointer">
                                                                        <input
                                                                            type="radio"
                                                                            checked={mode === 'non-monetary'}
                                                                            onChange={() => {
                                                                                setCategoryCosts(prev => ({
                                                                                    ...prev,
                                                                                    [category]: {
                                                                                        ...prev[category],
                                                                                        metricValues: {
                                                                                            ...(prev[category]?.metricValues || {}),
                                                                                            csatImprovement: {
                                                                                                ...csatConfig,
                                                                                                mode: 'non-monetary',
                                                                                                calculationMethod: csatConfig.calculationMethod || 'retention_based'
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }));
                                                                            }}
                                                                        />
                                                                        <span className="text-xs">Track Separately (Non-monetary)</span>
                                                                    </label>
                                                                </div>

                                                                {/* Monetary Configuration */}
                                                                {mode === 'monetary' && (
                                                                    <div className="space-y-3">
                                                                        {/* Business Context */}
                                                                        <div className="grid grid-cols-2 gap-2">
                                                                            <div>
                                                                                <label className="block text-xs text-gray-600 mb-1">Industry:</label>
                                                                                <select
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    value={csatConfig.industry || 'Other'}
                                                                                    onChange={(e) => {
                                                                                        setCategoryCosts(prev => ({
                                                                                            ...prev,
                                                                                            [category]: {
                                                                                                ...prev[category],
                                                                                                metricValues: {
                                                                                                    ...(prev[category]?.metricValues || {}),
                                                                                                    csatImprovement: {
                                                                                                        ...csatConfig,
                                                                                                        mode: csatConfig.mode || 'monetary',
                                                                                                        calculationMethod: csatConfig.calculationMethod || 'retention_based',
                                                                                                        industry: e.target.value
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }));
                                                                                    }}
                                                                                >
                                                                                    <option>E-commerce</option>
                                                                                    <option>SaaS</option>
                                                                                    <option>Healthcare</option>
                                                                                    <option>Financial Services</option>
                                                                                    <option>Retail</option>
                                                                                    <option>Manufacturing</option>
                                                                                    <option>Professional Services</option>
                                                                                    <option>Other</option>
                                                                                </select>
                                                                            </div>

                                                                            <div>
                                                                                <label className="block text-xs text-gray-600 mb-1">Annual Customers:</label>
                                                                                <input
                                                                                    type="number"
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    placeholder="10000"
                                                                                    value={csatConfig.annualCustomers || ''}
                                                                                    onChange={(e) => {
                                                                                        setCategoryCosts(prev => ({
                                                                                            ...prev,
                                                                                            [category]: {
                                                                                                ...prev[category],
                                                                                                metricValues: {
                                                                                                    ...(prev[category]?.metricValues || {}),
                                                                                                    csatImprovement: {
                                                                                                        ...csatConfig,
                                                                                                        mode: csatConfig.mode || 'monetary',
                                                                                                        calculationMethod: csatConfig.calculationMethod || 'retention_based',
                                                                                                        annualCustomers: parseFloat(e.target.value) || 0
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }));
                                                                                    }}
                                                                                />
                                                                            </div>
                                                                        </div>

                                                                        <div>
                                                                            <label className="block text-xs text-gray-600 mb-1">Avg Customer Value/Year ($):</label>
                                                                            <input
                                                                                type="number"
                                                                                className="w-full px-2 py-1 text-xs border rounded"
                                                                                placeholder="100"
                                                                                value={csatConfig.avgCustomerValue || ''}
                                                                                onChange={(e) => {
                                                                                    setCategoryCosts(prev => ({
                                                                                        ...prev,
                                                                                        [category]: {
                                                                                            ...prev[category],
                                                                                            metricValues: {
                                                                                                ...(prev[category]?.metricValues || {}),
                                                                                                csatImprovement: {
                                                                                                    ...csatConfig,
                                                                                                    mode: csatConfig.mode || 'monetary',
                                                                                                    calculationMethod: csatConfig.calculationMethod || 'retention_based',
                                                                                                    avgCustomerValue: parseFloat(e.target.value) || 0
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }));
                                                                                }}
                                                                            />
                                                                        </div>

                                                                        {/* Retention Impact */}
                                                                        <div className="p-2 bg-blue-50 border border-blue-200 rounded">
                                                                            <div className="text-xs font-medium mb-2 text-blue-900">
                                                                                üéØ Retention Impact (Key Assumption)
                                                                            </div>

                                                                            <div className="mb-2">
                                                                                <label className="block text-xs text-gray-700 mb-1 font-medium">
                                                                                    Retention improvement per 1 CSAT point (%):
                                                                                </label>
                                                                                <div className="flex items-center gap-2">
                                                                                    <input
                                                                                        type="number"
                                                                                        step="0.01"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded font-semibold"
                                                                                        placeholder="0.3"
                                                                                        value={csatConfig.retentionImpactPerCSATPoint || ''}
                                                                                        onChange={(e) => {
                                                                                            setCategoryCosts(prev => ({
                                                                                                ...prev,
                                                                                                [category]: {
                                                                                                    ...prev[category],
                                                                                                    metricValues: {
                                                                                                        ...(prev[category]?.metricValues || {}),
                                                                                                        csatImprovement: {
                                                                                                            ...csatConfig,
                                                                                                            mode: csatConfig.mode || 'monetary',
                                                                                                            calculationMethod: csatConfig.calculationMethod || 'retention_based',
                                                                                                            retentionImpactPerCSATPoint: parseFloat(e.target.value) || 0
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }));
                                                                                        }}
                                                                                    />
                                                                                    <span className="text-xs">%</span>
                                                                                    <div className="text-xs text-gray-600 ml-1">
                                                                                        (Typical for {csatConfig.industry || 'Other'}: {getTypicalCSATRetention(csatConfig.industry || 'Other')}%)
                                                                                    </div>
                                                                                </div>
                                                                            </div>

                                                                            {/* Live Preview */}
                                                                            {csatConfig.annualCustomers > 0 && csatConfig.avgCustomerValue > 0 && csatConfig.retentionImpactPerCSATPoint > 0 && (
                                                                                <div className="text-xs bg-white p-2 rounded border border-blue-200 mt-2">
                                                                                    <div className="font-medium mb-1">Calculated Value (per 1 CSAT point):</div>
                                                                                    <div className="text-gray-700 space-y-0.5">
                                                                                        <div>‚Ä¢ {csatConfig.annualCustomers.toLocaleString()} customers √ó {csatConfig.retentionImpactPerCSATPoint}% = {(csatConfig.annualCustomers * csatConfig.retentionImpactPerCSATPoint / 100).toFixed(0)} retained</div>
                                                                                        <div>‚Ä¢ {(csatConfig.annualCustomers * csatConfig.retentionImpactPerCSATPoint / 100).toFixed(0)} customers √ó ${csatConfig.avgCustomerValue} = ${((csatConfig.annualCustomers * csatConfig.retentionImpactPerCSATPoint / 100) * csatConfig.avgCustomerValue).toLocaleString()}/year</div>
                                                                                        <div className="font-semibold text-blue-700 mt-1">
                                                                                            ‚Ä¢ Monthly value: ${(((csatConfig.annualCustomers * csatConfig.retentionImpactPerCSATPoint / 100) * csatConfig.avgCustomerValue) / 12).toLocaleString()}
                                                                                        </div>
                                                                                    </div>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                )}

                                                                {/* Non-Monetary Info */}
                                                                {mode === 'non-monetary' && (
                                                                    <div className="p-2 bg-purple-50 border border-purple-200 rounded text-xs">
                                                                        CSAT will be tracked as qualitative benefit (points improved) and displayed separately from financial ROI.
                                                                    </div>
                                                                )}
                                                            </div>
                                                        );
                                                    })()}
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Category-Channel Cost Matrix */}
                                <div className="settings-section">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Category-Channel Cost Matrix (overrides channel defaults)
                                        </h3>
                                        {needsMigration() && (
                                            <button
                                                onClick={migrateCategoryCosts}
                                                className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                                            >
                                                Migrate to New Structure
                                            </button>
                                        )}
                                    </div>
                                    
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>üí° Cost Configuration:</strong> Set different costs for each category-channel combination.
                                        <div className="mt-2">
                                            <strong>Blue checkmarks (‚úì):</strong> Indicate channels that have active use cases in that category. This helps you see which configurations are actually being used.
                                        </div>
                                        <div className="mt-2">
                                            <strong>For Hourly Costs:</strong>
                                            <ul className="ml-4 mt-1">
                                                <li>‚Ä¢ <strong>AHT (Average Handle Time):</strong> Minutes per contact</li>
                                                <li>‚Ä¢ <strong>Utilization %:</strong> Agent productive time (typically 60-85%)</li>
                                                <li>‚Ä¢ <strong>Formula:</strong> (Hourly Rate √ó AHT √∑ 60) √ó (100 √∑ Utilization%)</li>
                                                <li>‚Ä¢ <strong>Example:</strong> $30/hr √ó 10min √∑ 60 √ó (100√∑75%) = $6.67/contact</li>
                                            </ul>
                                        </div>
                                        <div className="mt-2">
                                            <strong>For Per-Contact Costs:</strong> Fixed cost per interaction (utilization not applicable)
                                        </div>
                                    </div>
                                    
                                    {Object.keys(categoryCosts).length === 0 ? (
                                        <div className="text-gray-500 italic">No categories configured. Add use cases to see category cost options.</div>
                                    ) : (
                                        <div className="space-y-6">
                                            {Object.entries(categoryCosts).map(([category, categoryData]) => {
                                                const isNewFormat = categoryData._default || Object.keys(categoryData).some(key => !['costType', 'value', 'ahtMinutes'].includes(key));
                                                const defaultCost = isNewFormat ? (categoryData._default || {}) : categoryData;
                                                const channels = getUniqueChannels();
                                                
                                                return (
                                                    <div key={category} className="border rounded-lg p-4 bg-gray-50">
                                                        <h4 className="font-semibold text-lg mb-3">{category}</h4>
                                                        
                                                        {/* Channel-Specific Costs - Now Required for Each Category */}
                                                        <div className="space-y-2">
                                                            <h5 className="font-medium text-sm text-gray-700">Channel Costs for {category}:</h5>
                                                            {channels.map(channel => {
                                                                // Get channel cost from category configuration
                                                                const channelSpecificData = categoryData[channel];
                                                                
                                                                // Use category-channel cost if exists, otherwise default empty
                                                                const channelCost = (channelSpecificData && typeof channelSpecificData === 'object') 
                                                                    ? channelSpecificData 
                                                                    : { costType: 'perContact', value: 0, ahtMinutes: 10 };
                                                                    
                                                                const hasUseCases = useCases.some(uc => uc.channel === channel && uc.category === category);
                                                                const isOverride = channelSpecificData && typeof channelSpecificData === 'object';
                                                                
                                                                return (
                                                                    <div key={channel} className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-3'} p-2 bg-white rounded border`}>
                                                                        <span className={`${isMobile ? 'text-xs' : 'w-20 text-sm'} font-medium ${hasUseCases ? 'text-blue-600' : 'text-gray-500'}`} 
                                                                              title={hasUseCases ? 'This channel has active use cases in this category' : 'No use cases for this channel in this category'}>
                                                                            {getChannelConfig(channel).label}{hasUseCases ? ' ‚úì' : ''}:
                                                                        </span>
                                                                        
                                                                        {(
                                                                            <div className={`${isMobile ? 'w-full space-y-2' : 'flex items-center gap-2 flex-1'}`}>
                                                                                <div className="cost-type-toggle">
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'perContact' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/contact
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'hourly' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/hr
                                                                                    </button>
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-blue-600 font-medium">üí∞</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={channelCost.value || 0}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, value: parseFloat(e.target.value) || 0 } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-20'}`}
                                                                                        step="0.01"
                                                                                        placeholder="Cost"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-green-600 font-medium">‚è±Ô∏è</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : 10}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, ahtMinutes: Math.max(0, parseFloat(e.target.value) || 0) } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-16'}`}
                                                                                        step="0.1"
                                                                                        placeholder="AHT min"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-blue-600 font-medium" title="Agent Utilization %">Util:</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={typeof channelCost.utilization === 'number' ? channelCost.utilization : 75}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, utilization: Math.max(0, Math.min(100, parseFloat(e.target.value) || 75)) } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-16'}`}
                                                                                        step="1"
                                                                                        placeholder="75"
                                                                                        title="Agent Utilization % (only affects hourly costs)"
                                                                                        min="0"
                                                                                        max="100"
                                                                                    />
                                                                                    <span className="text-xs text-gray-500">%</span>
                                                                                </div>
                                                                                <div className="text-xs text-gray-600">
                                                                                    {channelCost.costType === 'hourly' ? (
                                                                                        <span title="Effective cost calculation for hourly rate">
                                                                                            ${channelCost.value}/hr √ó {channelCost.ahtMinutes || 10}min √∑ 60 √ó {(100/(channelCost.utilization || 75)).toFixed(2)} = 
                                                                                            <strong> ${((channelCost.value * (channelCost.ahtMinutes || 10) / 60) * (100/(channelCost.utilization || 75))).toFixed(2)}/contact</strong>
                                                                                        </span>
                                                                                    ) : (
                                                                                        <span>${channelCost.value}/contact (utilization N/A)</span>
                                                                                    )}
                                                                                </div>
                                                                                <button
                                                                                    onClick={() => removeChannelCostFromCategory(category, channel)}
                                                                                    className="px-2 py-1 text-xs bg-red-100 text-red-600 rounded hover:bg-red-200"
                                                                                >
                                                                                    Remove
                                                                                </button>
                                                                                
                                                                                {/* Special Groups for this Category-Channel */}
                                                                                <div className="mt-3 pl-4 border-l-2 border-blue-200">
                                                                                    <div className="text-xs font-medium text-gray-600 mb-2">Special Groups:</div>
                                                                                    {channelCost._specialGroups && Object.entries(channelCost._specialGroups).map(([groupName, groupData]) => (
                                                                                        <div key={groupName} className="mb-2 bg-gray-50 p-2 rounded">
                                                                                            <div className="flex items-center gap-2 mb-1">
                                                                                                <span className="text-xs font-medium">{groupName}:</span>
                                                                                                <button
                                                                                                    onClick={() => {
                                                                                                        const newSpecialGroups = { ...channelCost._specialGroups };
                                                                                                        delete newSpecialGroups[groupName];
                                                                                                        setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: newSpecialGroups
                                                                                                                }
                                                                                                            }
                                                                                                        });
                                                                                                    }}
                                                                                                    className="text-xs text-red-600 hover:text-red-800 ml-auto"
                                                                                                >
                                                                                                    ‚úï
                                                                                                </button>
                                                                                            </div>
                                                                                            <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-2'}`}>
                                                                                                <div className="cost-type-toggle">
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'perContact' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/contact
                                                                                                    </button>
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'hourly' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/hr
                                                                                                    </button>
                                                                                                </div>
                                                                                                <div className={`flex items-center gap-1 ${isMobile ? 'w-full' : ''}`}>
                                                                                                    <span className="text-xs text-blue-600 font-medium" title="Cost Value">üí∞</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.value || 0}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, value: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input flex-1 min-w-0 text-xs"
                                                                                                        step="0.01"
                                                                                                        placeholder="Cost"
                                                                                                        title="Cost Value"
                                                                                                    />
                                                                                                </div>
                                                                                                <div className={`flex items-center gap-1 ${isMobile ? 'w-full' : ''}`}>
                                                                                                    <span className="text-xs text-green-600 font-medium" title="AHT (minutes)">‚è±Ô∏è</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.ahtMinutes || 10}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, ahtMinutes: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-14 text-xs"
                                                                                                        step="0.1"
                                                                                                        placeholder="AHT"
                                                                                                        title="Average Handle Time (minutes)"
                                                                                                    />
                                                                                                    <span className="text-xs text-gray-500">min</span>
                                                                                                </div>
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <span className="text-xs text-blue-600 font-medium" title="Agent Utilization %">Util:</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.utilization || 75}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, utilization: Math.max(0, Math.min(100, parseFloat(e.target.value) || 75)) }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-14 text-xs"
                                                                                                        step="1"
                                                                                                        placeholder="75"
                                                                                                        title="Agent Utilization % (only affects hourly costs)"
                                                                                                        min="0"
                                                                                                        max="100"
                                                                                                    />
                                                                                                    <span className="text-xs text-gray-500">%</span>
                                                                                                </div>
                                                                                                <div className="text-xs text-gray-600 col-span-2">
                                                                                                    {groupData.costType === 'hourly' ? (
                                                                                                        <span title="Effective cost calculation for hourly rate">
                                                                                                            ${groupData.value}/hr √ó {groupData.ahtMinutes || 10}min √∑ 60 √ó {(100/(groupData.utilization || 75)).toFixed(2)} = 
                                                                                                            <strong> ${((groupData.value * (groupData.ahtMinutes || 10) / 60) * (100/(groupData.utilization || 75))).toFixed(2)}/contact</strong>
                                                                                                        </span>
                                                                                                    ) : (
                                                                                                        <span>${groupData.value}/contact (utilization N/A)</span>
                                                                                                    )}
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    ))}
                                                                                    <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-2'}`}>
                                                                                        <input
                                                                                            type="text"
                                                                                            placeholder="Group name"
                                                                                            className={`settings-input ${isMobile ? 'w-full' : 'w-24'} text-xs`}
                                                                                            id={`newGroup-${category}-${channel}`}
                                                                                        />
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                const input = document.getElementById(`newGroup-${category}-${channel}`);
                                                                                                const groupName = input.value.trim();
                                                                                                if (groupName) {
                                                                                                    setCategoryCosts({
                                                                                                        ...categoryCosts,
                                                                                                        [category]: {
                                                                                                            ...categoryData,
                                                                                                            [channel]: {
                                                                                                                ...channelCost,
                                                                                                                _specialGroups: {
                                                                                                                    ...(channelCost._specialGroups || {}),
                                                                                                                    [groupName]: {
                                                                                                                        costType: channelCost.costType || 'perContact',
                                                                                                                        value: channelCost.value || 0,
                                                                                                                        ahtMinutes: channelCost.ahtMinutes || 10,
                                                                                                                        utilization: channelCost.utilization || 75
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    });
                                                                                                    input.value = '';
                                                                                                }
                                                                                            }}
                                                                                            className={`${isMobile ? 'w-full px-3 py-2' : 'px-2 py-1'} text-xs bg-blue-100 text-blue-600 rounded hover:bg-blue-200`}
                                                                                        >
                                                                                            + Add Group
                                                                                        </button>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                        
                        {/* Data Entry Tab */}
                        {activeTab === 'data' && (
                            <>
                                {/* Templates Panel - Conditionally Rendered */}
                                {showTemplates && (
                                <div className="bg-white rounded-lg shadow-lg p-4 mb-6">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.FileText /> Data Templates
                                        </h3>
                                        <button
                                            onClick={() => setShowTemplates(false)}
                                            className="text-gray-500 hover:text-gray-700"
                                            title="Close templates"
                                        >
                                            √ó
                                        </button>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                        {/* Save Template */}
                                        <div>
                                            <h4 className="font-medium mb-2">Save Current Data</h4>
                                            <div className="flex gap-2">
                                                <input
                                                    type="text"
                                                    placeholder="Template name..."
                                                    className="flex-1 px-3 py-2 text-sm border rounded"
                                                    onKeyDown={(e) => {
                                                        if (e.key === 'Enter' && e.target.value.trim()) {
                                                            saveAsTemplate(e.target.value.trim());
                                                            e.target.value = '';
                                                        }
                                                    }}
                                                />
                                                <button
                                                    onClick={(e) => {
                                                        const input = e.target.parentElement.querySelector('input');
                                                        if (input.value.trim()) {
                                                            saveAsTemplate(input.value.trim());
                                                            input.value = '';
                                                        }
                                                    }}
                                                    className="px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700"
                                                >
                                                    Save
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-600 mt-1">Saves all use cases without data values</p>
                                        </div>
                                        
                                        {/* Load Template */}
                                        <div>
                                            <h4 className="font-medium mb-2">Load Template</h4>
                                            <div className="space-y-2">
                                                {Object.keys(dataTemplates).map(templateName => (
                                                    <div key={templateName} className="flex items-center gap-2 p-2 bg-gray-50 rounded">
                                                        <span className="flex-1 text-sm font-medium">{templateName}</span>
                                                        <span className="text-xs text-gray-500">
                                                            {dataTemplates[templateName]?.useCases?.length || 0} use cases
                                                        </span>
                                                        <button
                                                            onClick={() => loadTemplate(templateName)}
                                                            className="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700"
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            onClick={() => deleteTemplate(templateName)}
                                                            className="px-2 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
                                                        >
                                                            √ó
                                                        </button>
                                                    </div>
                                                ))}
                                                {Object.keys(dataTemplates).length === 0 && (
                                                    <p className="text-sm text-gray-500 italic">No templates saved yet</p>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                )}
                                
                                {/* Bulk Edit Help Panel */}
                                {bulkEditMode && (
                                    <div className="bg-blue-50 rounded-lg p-4 mb-6 border border-blue-200">
                                        <h3 className="font-semibold mb-3 text-blue-800 flex items-center gap-2">
                                            <Icons.Help /> Bulk Edit Mode - Quick Reference
                                        </h3>
                                        
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Keyboard Shortcuts</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+Z</kbd> Undo</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+Shift+Z</kbd> Redo</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+A</kbd> Select All</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Enter</kbd> Next Field</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Tab</kbd> Navigate</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Esc</kbd> Finish Editing</li>
                                                </ul>
                                            </div>
                                            
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Copy & Paste</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li>‚Ä¢ Copy from Excel/Google Sheets</li>
                                                    <li>‚Ä¢ Paste with <kbd className="bg-gray-200 px-1 rounded">Ctrl+V</kbd></li>
                                                    <li>‚Ä¢ Data fills automatically</li>
                                                    <li>‚Ä¢ First column = Volume</li>
                                                    <li>‚Ä¢ Other columns = Improvement</li>
                                                </ul>
                                            </div>
                                            
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Quick Actions</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li>‚Ä¢ <strong>‚ÜíAll:</strong> Apply to all months</li>
                                                    <li>‚Ä¢ <strong>‚ÜêCopy:</strong> Copy previous month</li>
                                                    <li>‚Ä¢ <strong>Fill Down:</strong> Apply to selected</li>
                                                    <li>‚Ä¢ <strong>Batch Update:</strong> Change multiple</li>
                                                    <li>‚Ä¢ Visual feedback for unsaved changes</li>
                                                </ul>
                                            </div>
                                        </div>
                                        
                                        <div className="mt-3 p-2 bg-yellow-100 rounded text-xs text-yellow-800">
                                            <strong>üí° Pro Tip:</strong> Select multiple use cases with checkboxes to perform batch operations. 
                                            Hover over data cells to see quick action buttons. All changes are automatically tracked for undo/redo.
                                        </div>
                                    </div>
                                )}
                                
                                {/* Bulk Operations Panel */}
                                {bulkEditMode && (
                                    <div className="bg-white rounded-lg shadow p-2 mb-3">
                                        <h3 className="font-semibold mb-4 flex items-center gap-2">
                                            <Icons.Settings /> Bulk Operations
                                            {selectedUseCases.size > 0 && (
                                                <span className="text-sm text-blue-600">({selectedUseCases.size} selected)</span>
                                            )}
                                        </h3>
                                        
                                        <div className="grid grid-cols-1 lg:grid-cols-2 items-start gap-6">
                                            {/* Quick Actions */}
                                            <div>
                                                <h4 className="font-medium mb-3">Quick Actions</h4>
                                                <div className="space-y-2">
                                                    <button
                                                        onClick={() => clearAllData(Array.from(selectedUseCases))}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Clear Selected Data
                                                    </button>
                                                    <button
                                                        onClick={batchDuplicate}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Duplicate Selected
                                                    </button>
                                                    <button
                                                        onClick={batchDelete}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Delete Selected
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            {/* Batch Updates */}
                                            <div>
                                                <h4 className="font-medium mb-3">Batch Updates</h4>
                                                <div className="space-y-3">
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Category</label>
                                                        <select
                                                            onChange={(e) => e.target.value && batchUpdateCategory(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select category...</option>
                                                            {categories.map(cat => (
                                                                <option key={cat} value={cat}>{cat}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Channel</label>
                                                        <select
                                                            onChange={(e) => e.target.value && batchUpdateChannel(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select channel...</option>
                                                            {ALL_CHANNELS.map(channel => (
                                                                <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Special Group</label>
                                                        <select
                                                            onChange={(e) => batchUpdateSpecialGroup(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select special group...</option>
                                                            <option value="">Remove Special Group</option>
                                                            {/* Add available special groups based on selected use cases */}
                                                            {Array.from(new Set(
                                                                useCases
                                                                    .filter(uc => selectedUseCases.has(uc.id))
                                                                    .flatMap(uc => getAvailableSpecialGroups(uc.category, uc.channel))
                                                            )).map(group => (
                                                                <option key={group} value={group}>{group}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Fill Down - full width row */}
                                            <div className="lg:col-span-2">
                                                {/* Fill Down Controls */}
                                                {selectedUseCases.size > 0 && (() => {
                                                    // Collect all unique benefits from selected use cases
                                                    const fillDownInputs = {};
                                                    const allBenefits = new Map();
                                                    
                                                    Array.from(selectedUseCases).forEach(ucId => {
                                                        const uc = useCases.find(u => u.id === ucId);
                                                        if (uc) {
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            normalizedUC.benefits.forEach((benefit, index) => {
                                                                if (!allBenefits.has(benefit.metric)) {
                                                                    allBenefits.set(benefit.metric, []);
                                                                }
                                                                allBenefits.get(benefit.metric).push({
                                                                    ucId,
                                                                    ucName: uc.name,
                                                                    benefitIndex: index,
                                                                    fieldKey: normalizedUC.benefits.length === 1 
                                                                        ? `improvement_${benefit.metric}`
                                                                        : `improvement_${index}_${benefit.metric}`
                                                                });
                                                            });
                                                        }
                                                    });
                                                    
                                                    const handleApplyIndividualMetric = (metric, type, instances) => {
                                                        // Save current state to undo stack before making changes
                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                        setRedoStack([]);
                                                        
                                                        const updatedUseCases = deepCopyUseCases(useCases);
                                                        
                                                        if (fillMode === 'constant' || fillMode === 'adjust') {
                                                            // Constant or Adjust mode
                                                            instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                if (ucIndex >= 0) {
                                                                    const uc = updatedUseCases[ucIndex];
                                                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                    
                                                                    // Apply volume if requested
                                                                    if (type === 'volume' || type === 'both') {
                                                                        const volumeInput = document.getElementById(`filldown-volume-${metric}`);
                                                                        if (volumeInput && volumeInput.value) {
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            
                                                                            const adjustment = parseFloat(volumeInput.value);
                                                                            
                                                                            months.forEach(month => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                if (fillMode === 'adjust') {
                                                                                    // Add/subtract from existing value
                                                                                    const currentValue = parseFloat(updatedUseCases[ucIndex].data[month.id][volumeFieldKey]) || 0;
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = Math.max(0, currentValue + adjustment).toString();
                                                                                } else {
                                                                                    // Replace with new value
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = volumeInput.value;
                                                                                }
                                                                            });
                                                                        }
                                                                    }
                                                                    
                                                                    // Apply improvement if requested
                                                                    if (type === 'improvement' || type === 'both') {
                                                                        const improvementInput = document.getElementById(`filldown-${metric}`);
                                                                        if (improvementInput && improvementInput.value) {
                                                                            const adjustment = parseFloat(improvementInput.value);
                                                                            
                                                                            months.forEach(month => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                if (fillMode === 'adjust') {
                                                                                    // Add/subtract from existing value
                                                                                    const currentValue = parseFloat(updatedUseCases[ucIndex].data[month.id][fieldKey]) || 0;
                                                                                    const newValue = currentValue + adjustment;
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                        metric.includes('min') ? newValue.toFixed(1) : newValue.toString();
                                                                                } else {
                                                                                    // Replace with new value
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = improvementInput.value;
                                                                                }
                                                                            });
                                                                        }
                                                                    }
                                                                }
                                                            });
                                                        } else {
                                                            // Gradual increase mode
                                                            const totalMonths = months.length;
                                                            
                                                            instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                if (ucIndex >= 0) {
                                                                    const uc = updatedUseCases[ucIndex];
                                                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                    
                                                                    months.forEach((month, monthIndex) => {
                                                                        if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                            updatedUseCases[ucIndex].data[month.id] = {};
                                                                        }
                                                                        
                                                                        const progress = totalMonths > 1 ? monthIndex / (totalMonths - 1) : 0;
                                                                        
                                                                        // Apply volume if requested
                                                                        if (type === 'volume' || type === 'both') {
                                                                            const volumeStartInput = document.getElementById(`filldown-volume-start-${metric}`);
                                                                            const volumeEndInput = document.getElementById(`filldown-volume-end-${metric}`);
                                                                            
                                                                            if (volumeStartInput?.value && volumeEndInput?.value) {
                                                                                const startVal = parseFloat(volumeStartInput.value);
                                                                                const endVal = parseFloat(volumeEndInput.value);
                                                                                const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                    ? `volume_${metric}`
                                                                                    : `volume_${benefitIndex}_${metric}`;
                                                                                
                                                                                const interpolatedVolume = Math.round(interpolateValue(startVal, endVal, progress, curveType));
                                                                                updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = interpolatedVolume;
                                                                            }
                                                                        }
                                                                        
                                                                        // Apply improvement if requested
                                                                        if (type === 'improvement' || type === 'both') {
                                                                            const improvementStartInput = document.getElementById(`filldown-start-${metric}`);
                                                                            const improvementEndInput = document.getElementById(`filldown-end-${metric}`);
                                                                            
                                                                            if (improvementStartInput?.value && improvementEndInput?.value) {
                                                                                const startVal = parseFloat(improvementStartInput.value);
                                                                                const endVal = parseFloat(improvementEndInput.value);
                                                                                const interpolatedImprovement = interpolateValue(startVal, endVal, progress, curveType);
                                                                                
                                                                                updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                    metric.includes('min') ? interpolatedImprovement.toFixed(1) : Math.round(interpolatedImprovement);
                                                                            }
                                                                        }
                                                                    });
                                                                }
                                                            });
                                                        }
                                                        
                                                        setUseCases(updatedUseCases);
                                                    };
                                                    
                                                    const handleApplyAll = () => {
                                                        if (fillMode === 'constant') {
                                                            // Original constant value logic
                                                            const operations = [];
                                                            
                                                            allBenefits.forEach((instances, metric) => {
                                                                const volumeInput = document.getElementById(`filldown-volume-${metric}`);
                                                                if (volumeInput && volumeInput.value) {
                                                                    instances.forEach(({ucId, benefitIndex}) => {
                                                                        const uc = useCases.find(u => u.id === ucId);
                                                                        if (uc) {
                                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            operations.push({
                                                                                useCaseId: ucId,
                                                                                field: volumeFieldKey,
                                                                                value: volumeInput.value
                                                                            });
                                                                        }
                                                                    });
                                                                }
                                                                
                                                                const improvementInput = document.getElementById(`filldown-${metric}`);
                                                                if (improvementInput && improvementInput.value) {
                                                                    instances.forEach(({ucId, fieldKey}) => {
                                                                        operations.push({
                                                                            useCaseId: ucId,
                                                                            field: fieldKey,
                                                                            value: improvementInput.value
                                                                        });
                                                                    });
                                                                }
                                                            });
                                                            
                                                            if (operations.length > 0) {
                                                                batchFillDown(operations);
                                                            }
                                                        } else {
                                                            // Gradual increase logic
                                                            // Save current state to undo stack BEFORE making changes
                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                            setRedoStack([]);
                                                            
                                                            const updatedUseCases = deepCopyUseCases(useCases);
                                                            const totalMonths = months.length;
                                                            
                                                            allBenefits.forEach((instances, metric) => {
                                                                // Get start and end values for volumes
                                                                const volumeStartInput = document.getElementById(`filldown-volume-start-${metric}`);
                                                                const volumeEndInput = document.getElementById(`filldown-volume-end-${metric}`);
                                                                const hasVolumeGradual = volumeStartInput?.value && volumeEndInput?.value;
                                                                
                                                                // Get start and end values for improvements
                                                                const improvementStartInput = document.getElementById(`filldown-start-${metric}`);
                                                                const improvementEndInput = document.getElementById(`filldown-end-${metric}`);
                                                                const hasImprovementGradual = improvementStartInput?.value && improvementEndInput?.value;
                                                                
                                                                if (hasVolumeGradual || hasImprovementGradual) {
                                                                    instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                        const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                        if (ucIndex >= 0) {
                                                                            const uc = updatedUseCases[ucIndex];
                                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            
                                                                            months.forEach((month, monthIndex) => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                // Calculate interpolated values
                                                                                const progress = totalMonths > 1 ? monthIndex / (totalMonths - 1) : 0;
                                                                                
                                                                                if (hasVolumeGradual) {
                                                                                    const startVal = parseFloat(volumeStartInput.value);
                                                                                    const endVal = parseFloat(volumeEndInput.value);
                                                                                    const interpolatedVolume = Math.round(interpolateValue(startVal, endVal, progress, curveType));
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = interpolatedVolume;
                                                                                }
                                                                                
                                                                                if (hasImprovementGradual) {
                                                                                    const startVal = parseFloat(improvementStartInput.value);
                                                                                    const endVal = parseFloat(improvementEndInput.value);
                                                                                    const interpolatedImprovement = interpolateValue(startVal, endVal, progress, curveType);
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                        metric.includes('min') ? interpolatedImprovement.toFixed(1) : Math.round(interpolatedImprovement);
                                                                                }
                                                                            });
                                                                        }
                                                                    });
                                                                }
                                                            });
                                                            
                                                            // Don't save to undo stack here - we already saved before making changes
                                                            setUseCases(updatedUseCases);
                                                        }
                                                        
                                                        // Clear all inputs
                                                        document.querySelectorAll('[id^="filldown-"]').forEach(input => {
                                                            input.value = '';
                                                        });
                                                    };
                                                    
                                                    return (
                                                        <div className="mt-4 p-3 bg-blue-50 rounded">
                                                            <h5 className="font-medium text-sm mb-2">Bulk Fill Operations</h5>
                                                            <p className="text-[10px] text-gray-600 mb-2">Apply values to all selected use cases across all months. For individual benefit fills, use the ‚Üí and ‚Üê buttons next to each benefit.</p>
                                                            
                                                            {/* Mode Toggle */}
                                                            <div className="mb-3">
                                                                <label className="block text-[10px] text-gray-600 mb-1">Fill Mode</label>
                                                                <div className="grid grid-cols-3 gap-1">
                                                                    <button
                                                                        onClick={() => setFillMode('constant')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'constant' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Replace all values with a constant"
                                                                    >
                                                                        Replace
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setFillMode('adjust')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'adjust' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Add or subtract from existing values"
                                                                    >
                                                                        Adjust ¬±
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setFillMode('gradual')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'gradual' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Gradual increase from start to end"
                                                                    >
                                                                        Gradual
                                                                    </button>
                                                                </div>
                                                                {fillMode === 'adjust' && (
                                                                    <div className="mt-2 p-2 bg-yellow-50 rounded">
                                                                        <p className="text-[10px] text-yellow-800">
                                                                            <strong>Adjust Mode:</strong> Enter positive values to add, negative to subtract from existing values
                                                                        </p>
                                                                    </div>
                                                                )}
                                                            </div>
                                                            
                                                            {/* Curve Type Selector - Only show when in gradual mode */}
                                                            {fillMode === 'gradual' && (
                                                                <div className="mb-3">
                                                                    <label className="block text-[10px] text-gray-600 mb-1">Curve Type</label>
                                                                    <select
                                                                        value={curveType}
                                                                        onChange={(e) => setCurveType(e.target.value)}
                                                                        className="w-full px-2 py-1 text-xs border rounded bg-white"
                                                                    >
                                                                        <option value="linear">Linear (Steady Growth)</option>
                                                                        <option value="exponential">Exponential (Slow Start, Rapid End)</option>
                                                                        <option value="scurve">S-Curve (Slow-Fast-Slow)</option>
                                                                        <option value="logarithmic">Logarithmic (Fast Start, Slow End)</option>
                                                                        <option value="custom">Custom (Fine Control)</option>
                                                                    </select>
                                                                    <div className="mt-2 p-2 bg-blue-50 rounded text-[10px] text-gray-700">
                                                                        {curveType === 'linear' && (
                                                                            <div>
                                                                                <strong>Linear Growth:</strong> Values increase uniformly across all months.
                                                                                <div className="text-[10px] mt-1">Example: 10% ‚Üí 60% over 12 months = +4.5% each month</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'exponential' && (
                                                                            <div>
                                                                                <strong>Exponential Growth:</strong> Slow initial adoption, rapid acceleration near end.
                                                                                <div className="text-[10px] mt-1">Ideal for: Technology adoption, viral growth patterns</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'scurve' && (
                                                                            <div>
                                                                                <strong>S-Curve (Sigmoid):</strong> Classic adoption curve with three phases.
                                                                                <div className="text-[10px] mt-1">Phase 1: Slow start | Phase 2: Rapid growth | Phase 3: Plateau</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'logarithmic' && (
                                                                            <div>
                                                                                <strong>Logarithmic Growth:</strong> Quick initial gains, then diminishing returns.
                                                                                <div className="text-[10px] mt-1">Ideal for: Quick wins, immediate impact scenarios</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'custom' && (
                                                                            <div>
                                                                                <strong>Custom Control:</strong> Set specific percentages for key milestones.
                                                                                <div className="text-[10px] mt-1">Define values at Month 3, 6, 9 for fine-grained control</div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    
                                                                    {/* Custom milestone controls */}
                                                                    {curveType === 'custom' && (
                                                                        <div className="mt-2 p-2 bg-gray-50 rounded">
                                                                            <div className="text-[10px] font-medium mb-2">Milestone Percentages</div>
                                                                            <div className="grid grid-cols-3 gap-2">
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 3 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-3"
                                                                                        placeholder="25"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 6 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-6"
                                                                                        placeholder="50"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 9 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-9"
                                                                                        placeholder="75"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                            <div className="text-[8px] text-gray-500 mt-1">
                                                                                Percentages represent progress from start to end value
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}
                                                            
                                                            {/* Benefit-specific Volume and Improvement Inputs - Responsive Grid */}
                                                            <div className="grid gap-3 mb-3 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]">
                                                                {Array.from(allBenefits.entries()).map(([metric, instances]) => {
                                                                    const volumeLabel = getVolumeLabel(metric);
                                                                    const improvementLabel = getImprovementLabel(metric);
                                                                    return (
                                                                        <div key={metric} className="p-2 bg-white rounded border border-gray-200">
                                                                            <div className="text-[11px] font-semibold text-blue-700 mb-2 flex items-center justify-between">
                                                                                <span>{metric}</span>
                                                                                <span className="text-[10px] text-gray-500">({instances.length} use case{instances.length > 1 ? 's' : ''})</span>
                                                                            </div>

                                                                            {/* Volume Input for this metric */}
                                                                            <div className="mb-1.5">
                                                                                <label className="block text-[10px] text-gray-600 mb-0.5 font-medium">
                                                                                    üìä {volumeLabel} {fillMode === 'gradual' && '(Start ‚Üí End)'} {fillMode === 'adjust' && '(¬± Adjustment)'}
                                                                                </label>
                                                                            {fillMode === 'constant' || fillMode === 'adjust' ? (
                                                                                <input
                                                                                    id={`filldown-volume-${metric}`}
                                                                                    type="number"
                                                                                    placeholder={fillMode === 'adjust' ? `¬± ${volumeLabel.toLowerCase()} adjustment` : `Number of ${volumeLabel.toLowerCase()}`}
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    title={fillMode === 'adjust' ? `Add/subtract ${volumeLabel} for ${metric}` : `Volume of ${volumeLabel} for ${metric}`}
                                                                                />
                                                                            ) : (
                                                                                <div className="flex gap-1">
                                                                                    <input
                                                                                        id={`filldown-volume-start-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="Start"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Starting volume for ${metric}`}
                                                                                    />
                                                                                    <span className="text-xs self-center">‚Üí</span>
                                                                                    <input
                                                                                        id={`filldown-volume-end-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="End"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Ending volume for ${metric}`}
                                                                                    />
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                        
                                                                            {/* Improvement Input for this metric */}
                                                                            <div className="mb-1.5">
                                                                                <label className="block text-[10px] text-gray-600 mb-0.5 font-medium">
                                                                                    üéØ {improvementLabel} {fillMode === 'gradual' && '(Start ‚Üí End)'} {fillMode === 'adjust' && '(¬± Adjustment)'}
                                                                                </label>
                                                                            {fillMode === 'constant' || fillMode === 'adjust' ? (
                                                                                <input
                                                                                    id={`filldown-${metric}`}
                                                                                    type="number"
                                                                                    placeholder={fillMode === 'adjust' 
                                                                                        ? (metric.includes('min') ? '¬± Minutes' : metric.includes('points') ? '¬± Points' : '¬± Percentage')
                                                                                        : (metric.includes('min') ? 'Minutes' : metric.includes('points') ? 'Points' : 'Percentage')}
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    title={fillMode === 'adjust' 
                                                                                        ? `Add/subtract to: ${instances.map(i => i.ucName).join(', ')}`
                                                                                        : `Apply to: ${instances.map(i => i.ucName).join(', ')}`}
                                                                                />
                                                                            ) : (
                                                                                <div className="flex gap-1">
                                                                                    <input
                                                                                        id={`filldown-start-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="Start"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Starting improvement for ${metric}`}
                                                                                    />
                                                                                    <span className="text-xs self-center">‚Üí</span>
                                                                                    <input
                                                                                        id={`filldown-end-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="End"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Ending improvement for ${metric}`}
                                                                                    />
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                        
                                                                            {/* Individual Apply Buttons - Compact */}
                                                                            <div className="flex gap-1 mt-1.5">
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'volume', instances)}
                                                                                    className="flex-1 px-1.5 py-0.5 bg-green-600 text-white text-[10px] rounded hover:bg-green-700 transition-colors"
                                                                                    title={`Apply only ${volumeLabel} values for ${metric}`}
                                                                                >
                                                                                    üìä {volumeLabel}
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'improvement', instances)}
                                                                                    className="flex-1 px-1.5 py-0.5 bg-blue-600 text-white text-[10px] rounded hover:bg-blue-700 transition-colors"
                                                                                    title={`Apply only improvement values for ${metric}`}
                                                                                >
                                                                                    üéØ Improvement
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'both', instances)}
                                                                                    className="px-1.5 py-0.5 bg-purple-600 text-white text-[10px] rounded hover:bg-purple-700 transition-colors"
                                                                                    title={`Apply both volume and improvement for ${metric}`}
                                                                                >
                                                                                    ‚úÖ Both
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                            
                                                            {/* Apply All Button with warning */}
                                                            <div className="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded">
                                                                <p className="text-[10px] text-yellow-800 mb-2">
                                                                    ‚ö†Ô∏è <strong>Apply All:</strong> This will overwrite ALL volume and improvement values for ALL benefits
                                                                </p>
                                                                <button
                                                                    onClick={handleApplyAll}
                                                                    className="w-full px-3 py-1 bg-orange-600 text-white text-xs rounded hover:bg-orange-700"
                                                                >
                                                                    Apply All Values (Overwrites Everything)
                                                                </button>
                                                            </div>
                                                            
                                                            <p className="text-[10px] text-gray-500 mt-2">
                                                                üí° Tip: Use individual Apply buttons above to update specific metrics without overwriting others
                                                            </p>
                                                        </div>
                                                    );
                                                })()}
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* Table Controls */}
                                <div className="bg-white rounded-lg shadow p-3 mb-4">
                                    {isMobile ? (
                                        // Mobile layout - stack controls vertically
                                        <div className="flex flex-col gap-3">
                                            {/* Bulk Edit Row */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <div className="flex items-center justify-center gap-2 bg-gray-50 rounded p-2 min-h-[44px]">
                                                    <input
                                                        type="checkbox"
                                                        id="bulkEditMode"
                                                        checked={bulkEditMode}
                                                        onChange={(e) => {
                                                            setBulkEditMode(e.target.checked);
                                                            setSelectedUseCases(new Set());
                                                        }}
                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                    />
                                                    <label htmlFor="bulkEditMode" className="text-sm font-medium text-gray-700">
                                                        Bulk Edit
                                                    </label>
                                                </div>
                                                
                                                {/* AHT Mode for mobile - simplified */}
                                                {hasAHTWithPerContactBilling() && (
                                                    <div className="flex items-center justify-center gap-2 bg-gray-50 rounded p-2 min-h-[44px]">
                                                        <input
                                                            type="checkbox"
                                                            id="ahtMode"
                                                            checked={ahtNegotiationMode}
                                                            onChange={(e) => setAhtNegotiationMode(e.target.checked)}
                                                            className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                        />
                                                        <label htmlFor="ahtMode" className="text-sm font-medium text-gray-700">
                                                            AHT Mode
                                                        </label>
                                                    </div>
                                                )}
                                            </div>
                                            
                                            {/* Undo/Redo Row */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <button
                                                    onClick={undo}
                                                    disabled={undoStack.length === 0}
                                                    className={`px-2 py-1 rounded text-sm flex items-center justify-center gap-1 min-h-[32px] ${undoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    title="Undo (Ctrl+Z)"
                                                >
                                                    ‚Ü∂ Undo
                                                </button>
                                                <button
                                                    onClick={redo}
                                                    disabled={redoStack.length === 0}
                                                    className={`px-2 py-1 rounded text-sm flex items-center justify-center gap-1 min-h-[32px] ${redoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    title="Redo (Ctrl+Shift+Z)"
                                                >
                                                    ‚Ü∑ Redo
                                                </button>
                                            </div>
                                            
                                            {/* Unsaved changes indicator for mobile */}
                                            {unsavedChanges.size > 0 && (
                                                <div className="bg-yellow-100 text-yellow-800 px-3 py-2 rounded text-sm text-center">
                                                    {unsavedChanges.size} unsaved change{unsavedChanges.size > 1 ? 's' : ''}
                                                </div>
                                            )}
                                            
                                            {/* Templates and Add Use Case Row - moved to bottom on mobile */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <button
                                                    onClick={() => setShowTemplates(!showTemplates)}
                                                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 flex items-center justify-center gap-2 text-sm min-h-[44px]"
                                                >
                                                    <Icons.FileText /> <span>{showTemplates ? 'Hide' : 'Templates'}</span>
                                                </button>
                                                <button
                                                    onClick={() => setShowAddUseCase(!showAddUseCase)}
                                                    className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center justify-center gap-2 text-sm min-h-[44px]"
                                                >
                                                    <span className="text-lg">+</span> <span>Add Use Case</span>
                                                </button>
                                            </div>
                                        </div>
                                    ) : (
                                        // Desktop layout - horizontal arrangement
                                        <div className="flex gap-3 items-center justify-between">
                                            <div className="flex gap-3 items-center">
                                                {/* Bulk Edit Mode Toggle */}
                                                <div className="flex items-center gap-2">
                                                    <input
                                                        type="checkbox"
                                                        id="bulkEditMode"
                                                        checked={bulkEditMode}
                                                        onChange={(e) => {
                                                            setBulkEditMode(e.target.checked);
                                                            setSelectedUseCases(new Set());
                                                        }}
                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                    />
                                                    <label htmlFor="bulkEditMode" className="text-sm font-medium text-gray-700">
                                                        Bulk Edit Mode
                                                    </label>
                                                </div>
                                                
                                                {/* Undo/Redo Buttons */}
                                                <div className="flex gap-1">
                                                    <button
                                                        onClick={undo}
                                                        disabled={undoStack.length === 0}
                                                        className={`px-3 py-2 rounded text-sm ${undoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                        title="Undo (Ctrl+Z)"
                                                    >
                                                        ‚Ü∂ Undo
                                                    </button>
                                                    <button
                                                        onClick={redo}
                                                        disabled={redoStack.length === 0}
                                                        className={`px-3 py-2 rounded text-sm ${redoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                        title="Redo (Ctrl+Shift+Z)"
                                                    >
                                                        ‚Ü∑ Redo
                                                    </button>
                                                </div>
                                                
                                                {/* Show Unsaved Changes Indicator */}
                                                {unsavedChanges.size > 0 && (
                                                    <div className="bg-yellow-100 text-yellow-800 px-3 py-1 rounded text-sm">
                                                        {unsavedChanges.size} unsaved change{unsavedChanges.size > 1 ? 's' : ''}
                                                    </div>
                                                )}
                                                
                                                {/* AHT Negotiation Mode Toggle */}
                                                {hasAHTWithPerContactBilling() && (
                                                    <div className="flex items-center gap-2 ml-4">
                                                        <label className="flex items-center gap-2 cursor-pointer" title="When enabled, calculates potential savings from AHT reductions even with per-contact billing (for contract negotiations)">
                                                            <input
                                                                type="checkbox"
                                                                checked={ahtNegotiationMode}
                                                                onChange={(e) => setAhtNegotiationMode(e.target.checked)}
                                                                className="form-checkbox h-4 w-4 text-blue-600"
                                                            />
                                                            <span className="text-sm font-medium">AHT Negotiation Mode</span>
                                                        </label>
                                                        {ahtNegotiationMode ? (
                                                            <span className="text-xs text-green-600 bg-green-50 px-2 py-1 rounded">
                                                                Calculating negotiation leverage
                                                            </span>
                                                        ) : (
                                                            <span className="text-xs text-amber-600 bg-amber-50 px-2 py-1 rounded">
                                                                ‚ö†Ô∏è AHT savings benefit vendor (per-contact billing)
                                                            </span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            
                                            {/* Action buttons on the right */}
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => setShowTemplates(!showTemplates)}
                                                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 flex items-center gap-2 text-sm"
                                                >
                                                    <Icons.FileText /> {showTemplates ? 'Hide' : 'Show'} Templates
                                                </button>
                                                <button
                                                    onClick={() => setShowAddUseCase(!showAddUseCase)}
                                                    className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center gap-2 text-sm"
                                                >
                                                    <span className="text-lg">+</span> Add Use Case
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Add Use Case Form */}
                                {showAddUseCase && (
                                    <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
                                        <div className="bg-blue-50 px-6 py-4 rounded">
                                            {/* Basic Use Case Info */}
                                            <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-4 gap-3'} mb-4`}>
                                                <select
                                                    value={newUseCase.category}
                                                    onChange={(e) => setNewUseCase({...newUseCase, category: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    {categories.map(cat => (
                                                        <option key={cat} value={cat}>{cat}</option>
                                                    ))}
                                                </select>
                                                <input
                                                    type="text"
                                                    placeholder="Use Case Name"
                                                    value={newUseCase.name}
                                                    onChange={(e) => setNewUseCase({...newUseCase, name: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                />
                                                <select
                                                    value={newUseCase.channel}
                                                    onChange={(e) => setNewUseCase({...newUseCase, channel: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    {ALL_CHANNELS.map(channel => (
                                                        <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                    ))}
                                                </select>
                                                <select
                                                    value={newUseCase.specialGroup || ''}
                                                    onChange={(e) => setNewUseCase({...newUseCase, specialGroup: e.target.value || null})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    <option value="">No Special Group</option>
                                                    {getAvailableSpecialGroups(newUseCase.category, newUseCase.channel).map(group => (
                                                        <option key={group} value={group}>{group}</option>
                                                    ))}
                                                </select>
                                            </div>

                                            {/* Benefits Section */}
                                            <div className="mb-4">
                                                <h4 className="font-medium mb-2">Benefits (Value Drivers)</h4>
                                                {newUseCase.benefits.map((benefit, index) => (
                                                    <div key={index} className="mb-3">
                                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-6 gap-2'} mb-1 items-center`}>
                                                            <select
                                                                value={benefit.metric}
                                                                onChange={(e) => {
                                                                    const updatedBenefits = [...newUseCase.benefits];
                                                                    updatedBenefits[index].metric = e.target.value;
                                                                    setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                }}
                                                                className={`px-2 py-1 border rounded text-sm ${isMobile ? 'w-full' : 'col-span-3'}`}
                                                            >
                                                                {getAvailableMetrics().map(metric => (
                                                                    <option key={metric} value={metric} disabled={newUseCase.benefits.some((b, idx) => idx !== index && b.metric === metric)}>{metric}</option>
                                                                ))}
                                                            </select>
                                                            <div className={`${isMobile ? 'w-full' : 'col-span-2'}`}>
                                                                <label className="text-xs text-gray-600 block mb-1">
                                                                    Baseline {benefit.metric.includes('min') ? '(minutes)' : benefit.metric.includes('points') ? '(points)' : '(%)'}
                                                                </label>
                                                                <input
                                                                    type="number"
                                                                    placeholder={
                                                                        benefit.metric.includes('min') ? 'Minutes' : 
                                                                        benefit.metric.includes('points') ? 'Points' : 
                                                                        'Percent'
                                                                    }
                                                                    value={benefit.baselineValue}
                                                                    onChange={(e) => {
                                                                        const updatedBenefits = [...newUseCase.benefits];
                                                                        updatedBenefits[index].baselineValue = parseFloat(e.target.value) || 0;
                                                                        setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                    }}
                                                                    className="px-2 py-1 border rounded text-sm w-full"
                                                                    step="0.01"
                                                                />
                                                            </div>
                                                            <button
                                                                onClick={() => {
                                                                    if (newUseCase.benefits.length > 1) {
                                                                        const updatedBenefits = newUseCase.benefits.filter((_, i) => i !== index);
                                                                        setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                    }
                                                                }}
                                                                className="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                                disabled={newUseCase.benefits.length === 1}
                                                            >
                                                                Remove
                                                            </button>
                                                        </div>
                                                    </div>
                                                ))}
                                                <button
                                                    onClick={() => {
                                                        // Find a metric that isn't already used
                                                        const availableMetrics = getAvailableMetrics().filter(m => 
                                                            !newUseCase.benefits.some(b => b.metric === m)
                                                        );
                                                        if (availableMetrics.length > 0) {
                                                            setNewUseCase({
                                                                ...newUseCase, 
                                                                benefits: [...newUseCase.benefits, {metric: availableMetrics[0], baselineValue: 0}]
                                                            });
                                                        } else {
                                                            alert('All available metrics have been added.');
                                                        }
                                                    }}
                                                    className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                                                    disabled={newUseCase.benefits.length >= getAvailableMetrics().length}
                                                >
                                                    Add Benefit
                                                </button>
                                            </div>

                                            <div className="flex justify-end gap-2">
                                                <button
                                                    onClick={() => setShowAddUseCase(false)}
                                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={addUseCase}
                                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                                >
                                                    Add Use Case
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                <div className="bg-white rounded-lg shadow-lg overflow-hidden">
                                    <div className="overflow-x-auto relative max-h-[80vh] overflow-y-auto">
                                        <table className="w-full">
                                            <thead className="bg-gradient-to-r from-blue-700 to-indigo-700 text-white sticky top-0 z-20 shadow-lg">
                                                <tr>
                                                    {bulkEditMode && (
                                                        <th className={`px-2 py-2 text-center sticky left-0 z-30 bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg`}>
                                                            <input
                                                                type="checkbox"
                                                                checked={getFilteredUseCases().length > 0 && selectedUseCases.size === getFilteredUseCases().length}
                                                                onChange={(e) => {
                                                                    if (e.target.checked) {
                                                                        setSelectedUseCases(new Set(getFilteredUseCases().map(uc => uc.id)));
                                                                    } else {
                                                                        setSelectedUseCases(new Set());
                                                                    }
                                                                }}
                                                                className="w-4 h-4 rounded"
                                                            />
                                                        </th>
                                                    )}
                                                    <th className={`px-2 py-2 text-left text-xs sticky left-0 z-30 bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[120px]`}>Category</th>
                                                    <th className={`px-2 py-2 text-left text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-36' : 'left-28'} z-30` : ''} bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[200px]`}>Use Case</th>
                                                    <th className={`px-2 py-2 text-left text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-80' : 'left-72'} z-30` : ''} bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[140px]`}>Channel & Group</th>
                                                    {getFilteredMonths().map(month => (
                                                        <th key={month.id} className="px-1 py-1.5 text-center min-w-[140px] max-w-[160px]">
                                                            <div className="text-xs font-semibold">{month.month.substring(0, 3)} '{String(month.year).substring(2)}</div>
                                                        </th>
                                                    ))}
                                                    <th className="px-2 py-2 text-center text-xs">Total</th>
                                                    <th className="px-2 py-2 text-center text-xs">Actions</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {getFilteredUseCases().map((useCase, index) => {
                                                    const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                                                    const totalSavings = getFilteredMonths().reduce((sum, month) => 
                                                        sum + calculateSavings(normalizedUseCase, month.id), 0
                                                    );

                                                    // Per-benefit totals across all shown months (no new calc functions)
                                                    const totalsByBenefit = new Map();
                                                    getFilteredMonths().forEach(month => {
                                                        const monthData = normalizedUseCase.data[month.id] || {};
                                                        normalizedUseCase.benefits.forEach((benefit, benefitIndex) => {
                                                            const s = calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                                                            totalsByBenefit.set(benefit.metric, (totalsByBenefit.get(benefit.metric) || 0) + s);
                                                        });
                                                    });
                                                    const perBenefitTotals = Array.from(totalsByBenefit.entries()).sort((a, b) => b[1] - a[1]);

                                                    return (
                                                        <tr key={useCase.id} className={`${selectedUseCases.has(useCase.id) ? 'row-selected ring-2 ring-blue-300' : (index % 2 === 0 ? 'row-even' : 'row-odd')} transition-colors`} style={{borderBottom: '2px solid rgba(147, 197, 253, 0.5)'}}>
                                                            {bulkEditMode && (
                                                                <td className={`px-2 py-1.5 text-center sticky left-0 z-10 ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}`}>
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={selectedUseCases.has(useCase.id)}
                                                                        onChange={(e) => {
                                                                            const newSelected = new Set(selectedUseCases);
                                                                            if (e.target.checked) {
                                                                                newSelected.add(useCase.id);
                                                                            } else {
                                                                                newSelected.delete(useCase.id);
                                                                            }
                                                                            setSelectedUseCases(newSelected);
                                                                        }}
                                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                                    />
                                                                </td>
                                                            )}
                                                            <td className={`px-2 py-1.5 text-xs sticky left-0 z-10 min-w-[120px] ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}`}>
                                                                {isMobile ? (
                                                                    // Mobile: Use a basic select with no styling classes
                                                                    <select
                                                                        value={useCase.category}
                                                                        onChange={(e) => {
                                                                            // Save to undo stack before making changes
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            
                                                                            setUseCases(useCases.map(uc => 
                                                                                uc.id === useCase.id 
                                                                                    ? {...uc, category: e.target.value}
                                                                                    : uc
                                                                            ));
                                                                        }}
                                                                        style={{
                                                                            width: '100%',
                                                                            fontSize: '16px',
                                                                            padding: '8px',
                                                                            border: '1px solid #d1d5db',
                                                                            borderRadius: '4px',
                                                                            backgroundColor: 'white'
                                                                            // Don't set any appearance properties - let browser use native
                                                                        }}
                                                                    >
                                                                        {categories.map(cat => (
                                                                            <option key={cat} value={cat}>{cat}</option>
                                                                        ))}
                                                                    </select>
                                                                ) : (
                                                                    // Desktop: Keep the styled select
                                                                    <select
                                                                        value={useCase.category}
                                                                        onChange={(e) => {
                                                                            // Save to undo stack before making changes
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            
                                                                            setUseCases(useCases.map(uc => 
                                                                                uc.id === useCase.id 
                                                                                    ? {...uc, category: e.target.value}
                                                                                    : uc
                                                                            ));
                                                                        }}
                                                                        className="text-[11px] border rounded px-1 py-0.5 w-full"
                                                                    >
                                                                        {categories.map(cat => (
                                                                            <option key={cat} value={cat}>{cat}</option>
                                                                        ))}
                                                                    </select>
                                                                )}
                                                            </td>
                                                            <td className={`px-2 py-1.5 text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-36' : 'left-28'} z-10` : ''} min-w-[200px]`}>
                                                                <div title={useCase.name} className="font-medium truncate max-w-[180px]">{useCase.name}</div>
                                                                {normalizedUseCase.benefits.length > 0 && (
                                                                    <div className="mt-1 space-y-0.5">
                                                                        {normalizedUseCase.benefits.map((b, idx) => {
                                                                            const baseline = b.baselineValue || 0;
                                                                            const metricName = b.metric.split('(')[0].trim();
                                                                            const unit = b.metric.includes('min') ? 'min' : 
                                                                                        b.metric.includes('points') ? 'pts' : '%';
                                                                            
                                                                            // Calculate total for this benefit across all months
                                                                            let benefitTotal = 0;
                                                                            getFilteredMonths().forEach(month => {
                                                                                const monthData = normalizedUseCase.data[month.id] || {};
                                                                                benefitTotal += calculateBenefitSavings(normalizedUseCase, b, monthData, idx);
                                                                            });
                                                                            
                                                                            const hasBaseline = baseline > 0;
                                                                            const tagColor = hasBaseline 
                                                                                ? 'bg-blue-100 text-blue-800 border-blue-200' 
                                                                                : 'bg-green-100 text-green-800 border-green-200';
                                                                            
                                                                            return (
                                                                                <div key={idx} className={`inline-block ${tagColor} border rounded px-2 py-0.5 text-[10px] mr-1 mb-1`}>
                                                                                    <div className="font-medium">{metricName}</div>
                                                                                    {baseline > 0 && (
                                                                                        <div className="text-[9px] opacity-80">Base: {baseline}{unit}</div>
                                                                                    )}
                                                                                    {benefitTotal > 0 && (
                                                                                        <div className="text-[9px] font-bold">
                                                                                            Total: ${benefitTotal >= 1000000 
                                                                                                ? `${(benefitTotal / 1000000).toFixed(1)}M`
                                                                                                : `${Math.round(benefitTotal / 1000)}k`}
                                                                                        </div>
                                                                                    )}
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>
                                                                )}
                                                            </td>
                                                            <td className={`px-2 py-1.5 text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-80' : 'left-72'} z-10` : ''} min-w-[140px]`}>
                                                                <select
                                                                    value={useCase.channel}
                                                                    onChange={(e) => {
                                                                        // Save to undo stack before making changes
                                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                        setRedoStack([]);
                                                                        
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, channel: e.target.value}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="text-[11px] border rounded px-1 py-0.5 w-full capitalize"
                                                                >
                                                                    {ALL_CHANNELS.map(channel => (
                                                                        <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                                    ))}
                                                                </select>
                                                                <div className="text-[10px] text-gray-600 mt-0.5">
                                                                    Cost: ${getEffectiveCost(useCase, useCase.channel).toFixed(2)}/contact
                                                                </div>
                                                                <select
                                                                    value={useCase.specialGroup || ''}
                                                                    onChange={(e) => {
                                                                        // Save to undo stack before making changes
                                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                        setRedoStack([]);
                                                                        
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, specialGroup: e.target.value || null}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="text-[10px] border rounded px-1 py-0.5 mt-0.5 w-full min-w-[120px]"
                                                                >
                                                                    <option value="">No Special Group</option>
                                                                    {getAvailableSpecialGroups(useCase.category, useCase.channel).map(group => (
                                                                        <option key={group} value={group}>{group}</option>
                                                                    ))}
                                                                </select>
                                                            </td>
                                                            {getFilteredMonths().map(month => {
                                                                const monthData = normalizedUseCase.data[month.id] || {};
                                                                const savings = calculateSavings(normalizedUseCase, month.id);
                                                                
                                                                return (
                                                                    <td 
                                                                        key={month.id} 
                                                                        className="px-2 py-1.5 relative min-w-[140px] max-w-[160px]"
                                                                        onPaste={(e) => bulkEditMode && handlePaste(e, index, getFilteredMonths().findIndex(m => m.id === month.id))}
                                                                    >
                                                                        <div className="space-y-2">
                                                                            {/* Benefit-specific Volume and Improvement Inputs */}
                                                                            {normalizedUseCase.benefits.length === 0 ? (
                                                                                <div className="text-xs text-gray-400 italic p-2">
                                                                                    No benefits defined
                                                                                </div>
                                                                            ) : (
                                                                                normalizedUseCase.benefits.map((benefit, benefitIndex) => {
                                                                                    const volumeFieldKey = normalizedUseCase.benefits.length === 1
                                                                                        ? `volume_${benefit.metric}`
                                                                                        : `volume_${benefitIndex}_${benefit.metric}`;
                                                                                    const improvementFieldKey = normalizedUseCase.benefits.length === 1
                                                                                        ? `improvement_${benefit.metric}`
                                                                                        : `improvement_${benefitIndex}_${benefit.metric}`;
                                                                                    const volumeLabel = getVolumeLabel(benefit.metric);
                                                                                    const improvementLabel = getImprovementLabel(benefit.metric);
                                                                                    
                                                                                    return (
                                                                                        <div key={`${benefit.metric}-${benefitIndex}`} className="p-2 bg-white/70 rounded border border-gray-200 mb-3">
                                                                                            <div className="text-[10px] font-semibold text-blue-600 mb-1 flex justify-between items-start">
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <span className="truncate pr-1">{benefit.metric}</span>
                                                                                                    {/* Quick benefit-level actions */}
                                                                                                    {bulkEditMode && (
                                                                                                    <div className="flex gap-0.5">
                                                                                                        <button
                                                                                                            onClick={() => {
                                                                                                                // Fill this benefit's values across all months
                                                                                                                const currentVolume = monthData[volumeFieldKey] || 0;
                                                                                                                const currentImprovement = monthData[improvementFieldKey] || 0;
                                                                                                                const updatedUseCases = deepCopyUseCases(useCases);
                                                                                                                getFilteredMonths().forEach(m => {
                                                                                                                    if (!updatedUseCases[index].data[m.id]) {
                                                                                                                        updatedUseCases[index].data[m.id] = {};
                                                                                                                    }
                                                                                                                    updatedUseCases[index].data[m.id][volumeFieldKey] = currentVolume;
                                                                                                                    updatedUseCases[index].data[m.id][improvementFieldKey] = currentImprovement;
                                                                                                                });
                                                                                                                setUseCases(updatedUseCases);
                                                                                                            }}
                                                                                                            className="px-1 py-0.5 text-[9px] bg-blue-100 hover:bg-blue-200 rounded"
                                                                                                            title="Fill this benefit's values across all months"
                                                                                                        >
                                                                                                            ‚Üí
                                                                                                        </button>
                                                                                                        <button
                                                                                                            onClick={() => {
                                                                                                                // Copy previous month's values for this benefit
                                                                                                                const currentMonthIndex = getFilteredMonths().findIndex(m => m.id === month.id);
                                                                                                                if (currentMonthIndex > 0) {
                                                                                                                    const prevMonth = getFilteredMonths()[currentMonthIndex - 1];
                                                                                                                    const prevData = useCase.data[prevMonth.id] || {};
                                                                                                                    const updatedUseCases = deepCopyUseCases(useCases);
                                                                                                                    if (!updatedUseCases[index].data[month.id]) {
                                                                                                                        updatedUseCases[index].data[month.id] = {};
                                                                                                                    }
                                                                                                                    updatedUseCases[index].data[month.id][volumeFieldKey] = prevData[volumeFieldKey] || 0;
                                                                                                                    updatedUseCases[index].data[month.id][improvementFieldKey] = prevData[improvementFieldKey] || 0;
                                                                                                                    setUseCases(updatedUseCases);
                                                                                                                }
                                                                                                            }}
                                                                                                            className="px-1 py-0.5 text-[9px] bg-green-100 hover:bg-green-200 rounded"
                                                                                                            title="Copy previous month's values for this benefit"
                                                                                                        >
                                                                                                            ‚Üê
                                                                                                        </button>
                                                                                                    </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            </div>
                                                                                            <div className="space-y-1">
                                                                                                {/* Volume Input for this benefit */}
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <label className="text-[10px] text-gray-600 min-w-[45px] flex-shrink-0" title={volumeLabel}>{volumeLabel}:</label>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        placeholder="0"
                                                                                                        value={monthData[volumeFieldKey] || ''}
                                                                                                        data-field-key={volumeFieldKey}
                                                                                                        onChange={(e) => updateUseCaseData(useCase.id, month.id, volumeFieldKey, e.target.value)}
                                                                                                        className={`flex-1 min-w-0 px-2 py-1 text-xs border rounded ${
                                                                                                            unsavedChanges.has(`${useCase.id}-${month.id}-${volumeFieldKey}`) ? 'border-yellow-400 bg-yellow-50' : 'border-gray-200'
                                                                                                        }`}
                                                                                                        title={`Number of ${volumeLabel} for ${benefit.metric}`}
                                                                                                    />
                                                                                                </div>

                                                                                                {/* NPS Sample Size Validation */}
                                                                                                {benefit.metric.includes('NPS') && (() => {
                                                                                                    const config = getCategoryMetricConfig(useCase.category, 'npsImprovement');
                                                                                                    if (!config || !config.annualCustomers) return null;

                                                                                                    const sampleSize = parseFloat(monthData[volumeFieldKey]) || 0;
                                                                                                    const validation = getNPSSampleValidation(sampleSize, config.annualCustomers / 12); // Monthly population

                                                                                                    if (sampleSize === 0) return null;

                                                                                                    const colorClasses = {
                                                                                                        green: 'text-green-600 bg-green-50 border-green-200',
                                                                                                        yellow: 'text-yellow-700 bg-yellow-50 border-yellow-200',
                                                                                                        red: 'text-red-600 bg-red-50 border-red-200',
                                                                                                        gray: 'text-gray-600 bg-gray-50 border-gray-200'
                                                                                                    };

                                                                                                    return (
                                                                                                        <div className={`text-[9px] px-1.5 py-0.5 rounded border ${colorClasses[validation.color]} mt-0.5`}>
                                                                                                            {validation.message}
                                                                                                        </div>
                                                                                                    );
                                                                                                })()}

                                                                                                {/* Improvement Input for this benefit */}
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <label className="text-[10px] text-gray-600 min-w-[45px] flex-shrink-0" title={improvementLabel}>{improvementLabel}:</label>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        placeholder={benefit.metric.includes('min') ? '0 min' : benefit.metric.includes('points') ? '0 pts' : '0%'}
                                                                                                        value={monthData[improvementFieldKey] || ''}
                                                                                                        data-field-key={improvementFieldKey}
                                                                                                        onChange={(e) => updateUseCaseData(useCase.id, month.id, improvementFieldKey, e.target.value)}
                                                                                                        className={`flex-1 min-w-0 px-2 py-1 text-xs border rounded ${
                                                                                                            unsavedChanges.has(`${useCase.id}-${month.id}-${improvementFieldKey}`) ? 'border-yellow-400 bg-yellow-50' : 'border-gray-200'
                                                                                                        }`}
                                                                                                        title={`${improvementLabel} for ${benefit.metric}`}
                                                                                                    />
                                                                                                </div>
                                                                                                {/* Monthly savings for this benefit */}
                                                                                                {(() => {
                                                                                                    const monthSavings = calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                                                                                                    return monthSavings > 0 ? (
                                                                                                        <div className="text-right text-[10px] text-green-600 font-semibold mt-1">
                                                                                                            ${monthSavings >= 1000000 
                                                                                                                ? `${(monthSavings / 1000000).toFixed(1)}M`
                                                                                                                : monthSavings >= 1000
                                                                                                                ? `${Math.round(monthSavings / 1000)}k`
                                                                                                                : Math.round(monthSavings).toLocaleString()}
                                                                                                        </div>
                                                                                                    ) : null;
                                                                                                })()}
                                                                                            </div>
                                                                                        </div>
                                                                                    );
                                                                                })
                                                                            )}
                                                                            
                                                                            {/* Monthly Savings Total */}
                                                                            {(savings > 0 || (normalizedUseCase.benefits.length > 0 && Object.keys(monthData).some(k => k.includes('volume') || k.includes('improvement')))) && (
                                                                                <div className="text-xs font-bold text-green-600 text-center mt-1 pt-1 border-t border-gray-300">
                                                                                    Total: ${Math.round(savings).toLocaleString()}
                                                                                </div>
                                                                            )}
                                                                            
                                                                            {/* Quick Action Buttons - Always visible in bulk mode */}
                                                                            {bulkEditMode && (
                                                                                <div className="mt-3 pt-2 border-t border-gray-200 flex gap-1 justify-center">
                                                                                    <button
                                                                                        onClick={() => applyToAllMonths(useCase.id, month.id)}
                                                                                        className="px-2 py-1 text-xs bg-blue-500 text-white hover:bg-blue-600 rounded"
                                                                                        title={`Copy all ${normalizedUseCase.benefits.length} benefit${normalizedUseCase.benefits.length > 1 ? 's' : ''} data (volumes & improvements) from ${month.month} to all other months`}
                                                                                    >
                                                                                        Fill‚Üí
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => copyPreviousMonth(useCase.id, month.id)}
                                                                                        className="px-2 py-1 text-xs bg-gray-500 text-white hover:bg-gray-600 rounded"
                                                                                        title={`Copy all benefit data from previous month to ${month.month}`}
                                                                                        disabled={getFilteredMonths().findIndex(m => m.id === month.id) === 0}
                                                                                    >
                                                                                        ‚ÜêCopy
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </td>
                                                                );
                                                            })}
                                                            <td className="px-3 py-2 text-center">
                                                                <div className="font-bold text-green-600 text-lg">
                                                                    ${Math.round(totalSavings).toLocaleString()}
                                                                </div>
                                                            </td>
                                                            <td className="px-2 py-1.5">
                                                                <div className="flex gap-0.5">
                                                                    {/* Edit Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            const normalizedUC = ensureUseCaseHasBenefits(useCase);
                                                                            setEditingUseCase({...normalizedUC});
                                                                            setShowEditModal(true);
                                                                        }}
                                                                        className="text-green-600 hover:text-green-800 p-1"
                                                                        title="Edit use case benefits"
                                                                    >
                                                                        <Icons.Edit />
                                                                    </button>
                                                                    
                                                                    {/* Duplicate Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            const duplicated = {
                                                                                ...useCase,
                                                                                id: Date.now() + Math.random(),
                                                                                name: `${useCase.name} (Copy)`
                                                                            };
                                                                            setUseCases([...useCases, duplicated]);
                                                                        }}
                                                                        className="text-blue-600 hover:text-blue-800 p-1"
                                                                        title="Duplicate use case"
                                                                    >
                                                                        <Icons.Copy />
                                                                    </button>
                                                                    
                                                                    {/* Clear Data for this Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            if (confirm('Clear all data for this use case?')) {
                                                                                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                                setRedoStack([]);
                                                                                setUseCases(useCases.map(uc => 
                                                                                    uc.id === useCase.id ? {...uc, data: {}} : uc
                                                                                ));
                                                                            }
                                                                        }}
                                                                        className="text-yellow-600 hover:text-yellow-800 p-1"
                                                                        title="Clear all data for this use case"
                                                                    >
                                                                        <Icons.RefreshCw />
                                                                    </button>
                                                                    
                                                                    {/* Delete Use Case */}
                                                                    <button
                                                                        onClick={() => removeUseCase(useCase.id)}
                                                                        className="text-red-600 hover:text-red-800 p-1"
                                                                        title="Delete use case"
                                                                    >
                                                                        <Icons.Trash />
                                                                    </button>
                                                                </div>
                                                            </td>
                                                        </tr>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </>
                        )}

                        {/* Analytics Tab */}
                        {activeTab === 'analytics' && (
                            <div className="space-y-6">
                                {/* Analytics Controls */}
                                <div className="bg-white rounded-lg shadow-lg p-4">
                                    {/* First Row: View Title and Tabs */}
                                    <div className="flex justify-between items-center mb-3">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Analytics View
                                        </h3>
                                        <div className={`${isMobile ? 'grid grid-cols-3 gap-1' : 'flex gap-1'}`}>
                                            <button onClick={() => setAnalyticsView('overall')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'overall' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Overall</button>
                                            <button onClick={() => setAnalyticsView('category')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'category' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Category</button>
                                            <button onClick={() => setAnalyticsView('channel')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'channel' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Channel</button>
                                            <button onClick={() => setAnalyticsView('benefit')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'benefit' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Benefit</button>
                                            <button onClick={() => setAnalyticsView('usecase')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'usecase' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Use Case</button>
                                            <button onClick={() => setAnalyticsView('specialgroup')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'specialgroup' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Special Group</button>
                                        </div>
                                    </div>

                                    {/* Second Row: Filters on same line */}
                                    <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-4'} pt-3 border-t`}>
                                        <span className={`text-xs font-medium text-gray-600 ${isMobile ? 'mb-2' : ''}`}>Filters:</span>
                                        
                                        <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-4 items-center'}`}>
                                            {/* Category Filter - Available in all views */}
                                            <select value={selectedCategory} onChange={(e) => setSelectedCategory(e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                <option value="all">All Categories</option>
                                                {getCategories().map(cat => (<option key={cat} value={cat}>{cat}</option>))}
                                            </select>

                                            {/* Channel Filter - Available in all views */}
                                            <select value={selectedChannel} onChange={(e) => setSelectedChannel(e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                <option value="all">All Channels</option>
                                                {ALL_CHANNELS.map(ch => (<option key={ch.id} value={ch.id} className="capitalize">{ch.label}</option>))}
                                            </select>

                                            {/* Special Group Filter - Available in all views */}
                                            <select value={selectedSpecialGroup || 'all'} onChange={(e) => setSelectedSpecialGroup(e.target.value === 'all' ? null : e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                <option value="all">All Groups</option>
                                                <option value="none">No Special Group</option>
                                                {getAllSpecialGroups().map(sg => (<option key={sg} value={sg}>{sg}</option>))}
                                            </select>

                                            {/* Use Case Filter - Available in all views */}
                                            <select value={selectedUseCase || 'all'} onChange={(e) => setSelectedUseCase(e.target.value === 'all' ? null : e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                <option value="all">All Use Cases</option>
                                                {useCases.map(uc => (<option key={uc.id} value={uc.name}>{uc.name}</option>))}
                                            </select>

                                            {/* Metric/Benefit Filter - Available in all views */}
                                            <select value={selectedMetric || 'all'} onChange={(e) => setSelectedMetric(e.target.value === 'all' ? null : e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                <option value="all">All Benefits</option>
                                                {[...new Set(useCases.flatMap(uc => {
                                                        const normalized = ensureUseCaseHasBenefits(uc);
                                                        return normalized.benefits.map(benefit => benefit.metric);
                                                    }))].map(metric => (<option key={metric} value={metric}>{metric}</option>))}
                                            </select>
                                        </div>
                                        
                                        {/* Clear Filters Button */}
                                        <button
                                            onClick={() => {
                                                setSelectedCategory('all');
                                                setSelectedChannel('all');
                                                setSelectedSpecialGroup(null);
                                                setSelectedUseCase(null);
                                                setSelectedMetric(null);
                                            }}
                                            className={`px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded hover:bg-gray-200 ${isMobile ? 'col-span-2 mt-2' : 'ml-auto'}`}
                                            title="Clear all filters"
                                        >
                                            ‚úï Clear
                                        </button>
                                        
                                        {/* Active Filters Count */}
                                        <div className="flex items-center text-xs text-blue-600">
                                            {(() => {
                                                let activeFilters = 0;
                                                if (selectedCategory !== 'all') activeFilters++;
                                                if (selectedChannel !== 'all') activeFilters++;
                                                if (selectedSpecialGroup) activeFilters++;
                                                if (selectedUseCase) activeFilters++;
                                                if (selectedMetric) activeFilters++;
                                                return activeFilters > 0 ? `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active` : 'No filters applied';
                                            })()} ‚Ä¢ {getFilteredUseCases().length} of {useCases.length} use cases
                                        </div>
                                    </div>

                                    {/* Date Range Selector */}
                                    <div className={`mt-4 ${isMobile ? 'space-y-3' : 'date-range-picker'}`}>
                                        <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex gap-4'}`}>
                                            <div className="date-input-group flex-1">
                                                <label className="date-label text-xs">Start Month</label>
                                                <input type="month" value={analyticsDateRange.start} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, start: e.target.value })} className="date-input w-full" />
                                            </div>
                                            <div className="date-input-group flex-1">
                                                <label className="date-label text-xs">End Month</label>
                                                <input type="month" value={analyticsDateRange.end} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, end: e.target.value })} className="date-input w-full" />
                                            </div>
                                        </div>
                                        <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-end'}`}>
                                            <div className={`px-4 py-2 bg-blue-100 text-blue-700 rounded ${isMobile ? 'text-center' : ''}`}>Analyzing {getFilteredMonths().length} months</div>
                                            <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'ml-auto flex gap-2'}`}>
                                                <button onClick={exportAnalyticsExcel} className="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm">Export Excel</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Overall View - Charts */}
                                {analyticsView === 'overall' && (
                                    <>
                                        {hasNonMonetaryBenefits() && (
                                            <div className="bg-purple-50 border border-purple-200 rounded-lg p-3 mb-4">
                                                <div className="text-sm text-purple-800">
                                                    <strong>üìä Note:</strong> Financial charts combine <strong>Cost Savings</strong> (deflection, automation, AHT reduction, etc.) and <strong>Revenue Impact</strong> (NPS, CSAT, conversion improvements). Non-monetary benefits are tracked separately below.
                                                </div>
                                            </div>
                                        )}
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'}`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Monthly Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.monthly}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Cumulative Savings</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.cumulative}></canvas></div>
                                            </div>
                                        </div>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'}`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Savings by Category</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.category}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channel}></canvas></div>
                                            </div>
                                        </div>

                                        {/* Savings vs Revenue Breakdown */}
                                        <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                            <h3 className="text-lg font-semibold mb-4">Value Breakdown: Cost Savings vs Revenue Impact</h3>
                                            <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'}`}>
                                                <div>
                                                    <h4 className="text-md font-semibold mb-2 text-blue-600">Cost Savings Trend</h4>
                                                    <p className="text-xs text-gray-600 mb-3">Operational efficiency improvements (deflection, automation, AHT reduction, etc.)</p>
                                                    <div className="chart-container"><canvas ref={chartRefs.savingsTrend}></canvas></div>
                                                </div>
                                                <div>
                                                    <h4 className="text-md font-semibold mb-2 text-green-600">Revenue Impact Trend</h4>
                                                    <p className="text-xs text-gray-600 mb-3">Revenue-generating improvements (NPS, CSAT, conversion rate, etc.)</p>
                                                    <div className="chart-container"><canvas ref={chartRefs.revenueTrend}></canvas></div>
                                                </div>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* Category View - Charts and Table */}
                                {analyticsView === 'category' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Category Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Savings = Volume √ó (Improvement - Baseline) √ó Effective Cost per Contact. 
                                                Effective cost is determined by hierarchy: Special Group {'>'} Category {'>'} Channel defaults. 
                                                For AHT metrics, costs are converted to per-minute rates.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Category</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Avg Savings/Contact<br /><small>($/contact)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const categoryStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        if (!categoryStats[uc.category]) categoryStats[uc.category] = { useCases: [], volume: 0, savings: 0 };
                                                        categoryStats[uc.category].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            categoryStats[uc.category].volume += getTotalVolumeForUseCaseMonth(uc, md);
                                                            categoryStats[uc.category].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(categoryStats).map(([category, stats]) => (
                                                        <tr key={category}>
                                                            <td className="font-semibold">{category}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{stats.volume > 0 ? (stats.savings / stats.volume).toFixed(2) : '0.00'}</td>
                                                            <td>{(() => {
                                                                if (totalSavingsAll <= 0) return '0%';
                                                                const percentage = (stats.savings / totalSavingsAll * 100);
                                                                
                                                                // Check if there are other categories with non-zero savings
                                                                const otherCategoriesHaveSavings = Object.values(categoryStats).some(
                                                                    otherStats => otherStats !== stats && otherStats.savings > 0
                                                                );
                                                                
                                                                if (percentage > 0 && percentage < 0.1) {
                                                                    return '<0.1%';
                                                                } else if (percentage > 99.9 && percentage < 100 && otherCategoriesHaveSavings) {
                                                                    return '>99.9%';
                                                                }
                                                                return `${percentage.toFixed(1)}%`;
                                                            })()}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Channel View - Charts and Table */}
                                {analyticsView === 'channel' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Channel Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Shows performance across communication channels. 
                                                Default costs can be overridden by category settings or special group pricing. 
                                                Improvement values shown are the average across all use cases in each channel.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Channel</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Default Cost<br /><small>($/contact)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const channelStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        if (!channelStats[uc.channel]) channelStats[uc.channel] = { useCases: [], volume: 0, savings: 0, improvements: [] };
                                                        channelStats[uc.channel].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            channelStats[uc.channel].volume += getTotalVolumeForUseCaseMonth(normalizedUC, md);
                                                            channelStats[uc.channel].savings += calculateSavings(uc, month.id);
                                                            // Collect improvements across benefits for averaging
                                                            (normalizedUC.benefits || []).forEach((benefit, i) => {
                                                                const fieldKey = (normalizedUC.benefits.length === 1)
                                                                    ? `improvement_${benefit.metric}`
                                                                    : `improvement_${i}_${benefit.metric}`;
                                                                if (md[fieldKey] != null) {
                                                                    channelStats[uc.channel].improvements.push(parseFloat(md[fieldKey]) || 0);
                                                                }
                                                            });
                                                        });
                                                    });
                                                    return Object.entries(channelStats).map(([channel, stats]) => {
                                                        const avgImprovement = stats.improvements.length ? (stats.improvements.reduce((a,b)=>a+b,0)/stats.improvements.length) : 0;
                                                        return (
                                                            <tr key={channel}>
                                                                <td className="font-semibold capitalize">{channel}</td>
                                                                <td>{stats.useCases.length}</td>
                                                                <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                                <td>{`$${getChannelCostValue(channel)}`}</td>
                                                                <td>{avgImprovement.toFixed(1)}%</td>
                                                                <td>{(() => {
                                                                    if (totalSavingsAll <= 0) return '0%';
                                                                    const percentage = (stats.savings / totalSavingsAll * 100);
                                                                    
                                                                    // Check if there are other channels with non-zero savings
                                                                    const otherChannelsHaveSavings = Object.values(channelStats).some(
                                                                        otherStats => otherStats !== stats && otherStats.savings > 0
                                                                    );
                                                                    
                                                                    if (percentage > 0 && percentage < 0.1) {
                                                                        return '<0.1%';
                                                                    } else if (percentage > 99.9 && percentage < 100 && otherChannelsHaveSavings) {
                                                                        return '>99.9%';
                                                                    }
                                                                    return `${percentage.toFixed(1)}%`;
                                                                })()}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                    </div>
                                    </>
                                )}

                                {/* Benefit View - Shows all benefits across use cases */}
                                {analyticsView === 'benefit' && (
                                    <>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Benefit Type Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>View Benefits Across All Use Cases:</strong> This view aggregates all benefits by type, showing which specific improvements drive the most value across your entire AI implementation.
                                                <div className="mt-2 text-xs">
                                                    <strong>Note on Percentages:</strong> The "% of Total Value" shows each benefit type's contribution to the overall savings. 
                                                    Since use cases can have multiple benefits, percentages may sum to more than 100%. For example, if one use case saves $1000 through 
                                                    both AHT reduction ($600) and deflection ($400), both benefits are credited with their respective contributions.
                                                </div>
                                            </div>
                                            <table className="analytics-table">
                                                <thead>
                                                    <tr>
                                                        <th>Benefit Type</th>
                                                        <th>Use Cases<br /><small>Using This Benefit</small></th>
                                                        <th>Total Volume<br /><small>(varies by type)</small></th>
                                                        <th>Avg Improvement<br /><small>(net of baseline)</small></th>
                                                        <th>Total Value<br /><small>($)</small></th>
                                                        <th>% of Total<br /><small>Value</small></th>
                                                        <th>Top Use Case<br /><small>(by value)</small></th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {(() => {
                                                        const filteredMonths = getFilteredMonths();
                                                        const benefitStats = {};
                                                        const totalSavingsAll = calculateTotalSavings();
                                                        
                                                        // Aggregate data by benefit type
                                                        const filteredUseCases = getFilteredUseCases();
                                                        filteredUseCases.forEach(uc => {
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            
                                                            normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                                                                const metric = benefit.metric;
                                                                
                                                                // Skip if metric filter is set and doesn't match
                                                                if (selectedMetric && metric !== selectedMetric) {
                                                                    return;
                                                                }
                                                                
                                                                if (!benefitStats[metric]) {
                                                                    benefitStats[metric] = {
                                                                        useCases: [],
                                                                        volumes: [],
                                                                        improvements: [],
                                                                        savings: 0,
                                                                        useCaseValues: {}
                                                                    };
                                                                }
                                                                
                                                                benefitStats[metric].useCases.push(uc.name);
                                                                
                                                                // Calculate savings and collect data for this benefit
                                                                filteredMonths.forEach(month => {
                                                                    const md = uc.data[month.id] || {};
                                                                    const breakdown = calculateSavingsBreakdown(uc, month.id);
                                                                    
                                                                    // Find this specific benefit's contribution
                                                                    breakdown.breakdown.forEach(item => {
                                                                        if (item.metric === metric) {
                                                                            benefitStats[metric].savings += item.savings;
                                                                            
                                                                            if (!benefitStats[metric].useCaseValues[uc.name]) {
                                                                                benefitStats[metric].useCaseValues[uc.name] = 0;
                                                                            }
                                                                            benefitStats[metric].useCaseValues[uc.name] += item.savings;
                                                                        }
                                                                    });
                                                                    
                                                                    // Collect volume and improvement data
                                                                    const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                        ? `volume_${metric}`
                                                                        : `volume_${benefitIndex}_${metric}`;
                                                                    const improvementFieldKey = normalizedUC.benefits.length === 1 
                                                                        ? `improvement_${metric}`
                                                                        : `improvement_${benefitIndex}_${metric}`;
                                                                    
                                                                    const volume = parseFloat(md[volumeFieldKey]) || 0;
                                                                    const improvement = parseFloat(md[improvementFieldKey]) || 0;
                                                                    
                                                                    if (volume > 0) benefitStats[metric].volumes.push(volume);
                                                                    if (improvement !== 0) benefitStats[metric].improvements.push(improvement);
                                                                });
                                                            });
                                                        });
                                                        
                                                        // Sort by total savings
                                                        const sortedBenefits = Object.entries(benefitStats)
                                                            .sort((a, b) => b[1].savings - a[1].savings);
                                                        
                                                        return sortedBenefits.map(([metric, stats]) => {
                                                            const uniqueUseCases = [...new Set(stats.useCases)];
                                                            const avgImprovement = stats.improvements.length 
                                                                ? stats.improvements.reduce((a, b) => a + b, 0) / stats.improvements.length 
                                                                : 0;
                                                            const totalVolume = stats.volumes.reduce((a, b) => a + b, 0);
                                                            
                                                            // Find top contributing use case
                                                            const topUseCase = Object.entries(stats.useCaseValues)
                                                                .sort((a, b) => b[1] - a[1])[0];
                                                            
                                                            // Format improvement display
                                                            let improvementStr = '';
                                                            if (metric.includes('min')) {
                                                                improvementStr = `${avgImprovement.toFixed(1)} minutes`;
                                                            } else if (metric.includes('points')) {
                                                                improvementStr = `${avgImprovement.toFixed(1)} points`;
                                                            } else {
                                                                improvementStr = `${avgImprovement.toFixed(1)}%`;
                                                            }
                                                            
                                                            // Get volume label
                                                            const volumeLabel = getVolumeLabel(metric);
                                                            
                                                            return (
                                                                <tr key={metric}>
                                                                    <td className="font-semibold">{metric}</td>
                                                                    <td title={uniqueUseCases.join(', ')}>
                                                                        {uniqueUseCases.length} use case{uniqueUseCases.length !== 1 ? 's' : ''}
                                                                    </td>
                                                                    <td>
                                                                        {Math.round(totalVolume).toLocaleString()}
                                                                        <br />
                                                                        <small className="text-gray-500">{volumeLabel}</small>
                                                                    </td>
                                                                    <td>{improvementStr}</td>
                                                                    <td className="font-bold text-green-600">
                                                                        ${Math.round(stats.savings).toLocaleString()}
                                                                    </td>
                                                                    <td>
                                                                        {totalSavingsAll > 0 
                                                                            ? `${(stats.savings / totalSavingsAll * 100).toFixed(1)}%`
                                                                            : '0%'}
                                                                    </td>
                                                                    <td className="text-sm">
                                                                        {topUseCase ? (
                                                                            <>
                                                                                {topUseCase[0]}
                                                                                <br />
                                                                                <small className="text-gray-500">
                                                                                    (${Math.round(topUseCase[1]).toLocaleString()})
                                                                                </small>
                                                                            </>
                                                                        ) : '-'}
                                                                    </td>
                                                                </tr>
                                                            );
                                                        });
                                                    })()}
                                                </tbody>
                                            </table>
                                        </div>
                                    </>
                                )}

                                {/* Use Case View - Charts and Table */}
                                {analyticsView === 'usecase' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Top 5 Use Cases Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Use Case Performance Ranking</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Individual Use Case Performance</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Each use case's savings are calculated using its specific cost hierarchy. 
                                                Improvement values are net of baseline (e.g., if current deflection is 70% and baseline is 10%, net improvement is 60%). 
                                                For AHT metrics, improvements shown in minutes are converted to hourly cost savings.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Use Case</th><th>Category</th><th>Channel</th><th>Benefits</th><th>Special Group</th><th>Total Volume<br /><small>(contacts)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>Total Savings<br /><small>($)</small></th><th>Top Contributor<br /><small>(% of UC savings)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    return filteredUseCases.map(uc => {
                                                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                        const filteredBenefits = getFilteredBenefits(uc);
                                                        let totalVolume = 0, totalSavings = 0;
                                                        const benefitImprovements = {};
                                                        const benefitSavingsByMonth = {};

                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};

                                                            // Calculate volume only for filtered benefits
                                                            filteredBenefits.forEach((benefit, filteredIdx) => {
                                                                const originalIndex = normalizedUC.benefits.findIndex(b => b.metric === benefit.metric);
                                                                const actualIndex = originalIndex >= 0 ? originalIndex : filteredIdx;
                                                                const volumeFieldKey = normalizedUC.benefits.length === 1
                                                                    ? `volume_${benefit.metric}`
                                                                    : `volume_${actualIndex}_${benefit.metric}`;
                                                                totalVolume += parseFloat(md[volumeFieldKey] || md.volume) || 0;
                                                            });

                                                            totalSavings += calculateSavings(uc, month.id);

                                                            // Get detailed breakdown for this month
                                                            const breakdown = calculateSavingsBreakdown(uc, month.id);
                                                            breakdown.breakdown.forEach(item => {
                                                                // Only include if this benefit is in the filtered list
                                                                if (filteredBenefits.some(b => b.metric === item.metric)) {
                                                                    if (!benefitSavingsByMonth[item.metric]) {
                                                                        benefitSavingsByMonth[item.metric] = 0;
                                                                    }
                                                                    benefitSavingsByMonth[item.metric] += item.savings;
                                                                }
                                                            });

                                                            // Collect improvements for each FILTERED benefit
                                                            filteredBenefits.forEach((benefit, filteredIdx) => {
                                                                const originalIndex = normalizedUC.benefits.findIndex(b => b.metric === benefit.metric);
                                                                const actualIndex = originalIndex >= 0 ? originalIndex : filteredIdx;
                                                                const fieldKey = normalizedUC.benefits.length === 1
                                                                    ? `improvement_${benefit.metric}`
                                                                    : `improvement_${actualIndex}_${benefit.metric}`;
                                                                if (!benefitImprovements[benefit.metric]) {
                                                                    benefitImprovements[benefit.metric] = [];
                                                                }
                                                                if (md[fieldKey] != null) {
                                                                    benefitImprovements[benefit.metric].push(parseFloat(md[fieldKey]) || 0);
                                                                }
                                                            });
                                                        });
                                                        
                                                        // Find top contributing benefit
                                                        let topContributor = { metric: '-', percentage: 0 };
                                                        if (totalSavings > 0) {
                                                            Object.entries(benefitSavingsByMonth).forEach(([metric, savings]) => {
                                                                const percentage = (savings / totalSavings * 100);
                                                                if (percentage > topContributor.percentage) {
                                                                    topContributor = { metric, percentage };
                                                                }
                                                            });
                                                        }
                                                        
                                                        // Format benefits and average improvements for display with metric names (FILTERED)
                                                        const benefitSummary = filteredBenefits.map(b => b.metric).join(', ');
                                                        let avgImprovementStr = '';
                                                        let avgImprovementTitle = '';
                                                        if (filteredBenefits.length === 1) {
                                                            // Single benefit - show just the value
                                                            const benefit = filteredBenefits[0];
                                                            const improvements = benefitImprovements[benefit.metric] || [];
                                                            const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                            if (benefit.metric.includes('min')) avgImprovementStr = `${avg.toFixed(1)} min`;
                                                            else if (benefit.metric.includes('points')) avgImprovementStr = `${avg.toFixed(1)} pts`;
                                                            else avgImprovementStr = `${avg.toFixed(1)}%`;
                                                        } else {
                                                            // Multiple benefits - create mini tags for display
                                                            const breakdownParts = filteredBenefits.slice(0, 3).map(benefit => {
                                                                const improvements = benefitImprovements[benefit.metric] || [];
                                                                const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                                const shortName = benefit.metric.split('(')[0].trim();
                                                                
                                                                // Pick a color based on metric type
                                                                let bgColor = 'bg-blue-100 text-blue-800';
                                                                if (benefit.metric.includes('AHT')) bgColor = 'bg-green-100 text-green-800';
                                                                else if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) bgColor = 'bg-purple-100 text-purple-800';
                                                                else if (benefit.metric.includes('Conversion') || benefit.metric.includes('Revenue')) bgColor = 'bg-yellow-100 text-yellow-800';
                                                                else if (benefit.metric.includes('Compliance')) bgColor = 'bg-red-100 text-red-800';
                                                                
                                                                let value = '';
                                                                if (benefit.metric.includes('min')) value = `${avg.toFixed(1)}min`;
                                                                else if (benefit.metric.includes('points')) value = `${avg.toFixed(1)}pts`;
                                                                else value = `${avg.toFixed(1)}%`;
                                                                
                                                                return { shortName, value, bgColor };
                                                            });
                                                            
                                                            // If more than 3 benefits, add a "+X more" indicator
                                                            const hasMore = filteredBenefits.length > 3;
                                                            const moreCount = filteredBenefits.length - 3;

                                                            avgImprovementStr = breakdownParts;
                                                            avgImprovementTitle = filteredBenefits.map(benefit => {
                                                                const improvements = benefitImprovements[benefit.metric] || [];
                                                                const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                                const shortName = benefit.metric.split('(')[0].trim();
                                                                if (benefit.metric.includes('min')) return `${shortName}: ${avg.toFixed(1)}min`;
                                                                if (benefit.metric.includes('points')) return `${shortName}: ${avg.toFixed(1)}pts`;
                                                                return `${shortName}: ${avg.toFixed(1)}%`;
                                                            }).join(', ');
                                                            
                                                            if (hasMore) {
                                                                avgImprovementStr.moreCount = moreCount;
                                                            }
                                                        }
                                                        
                                                        // Format top contributor display
                                                        const topContributorStr = topContributor.metric !== '-' 
                                                            ? `${topContributor.metric.split('(')[0].trim()} (${topContributor.percentage.toFixed(0)}%)`
                                                            : '-';
                                                        
                                                        return (
                                                            <tr key={uc.id}>
                                                                <td className="font-semibold">{uc.name}</td>
                                                                <td>{uc.category}</td>
                                                                <td className="capitalize">{uc.channel}</td>
                                                                <td title={benefitSummary}>{filteredBenefits.length} benefit{filteredBenefits.length !== 1 ? 's' : ''}</td>
                                                                <td>{uc.specialGroup || '-'}</td>
                                                                <td>{Math.round(totalVolume).toLocaleString()}</td>
                                                                <td title={avgImprovementTitle || null}>
                                                                    {typeof avgImprovementStr === 'string' ? (
                                                                        avgImprovementStr
                                                                    ) : (
                                                                        <div className="flex flex-wrap gap-1">
                                                                            {avgImprovementStr.map((item, idx) => (
                                                                                <span key={idx} className={`inline-block px-1.5 py-0.5 text-[10px] rounded ${item.bgColor}`}>
                                                                                    {item.shortName}: {item.value}
                                                                                </span>
                                                                            ))}
                                                                            {avgImprovementStr.moreCount && (
                                                                                <span className="inline-block px-1.5 py-0.5 text-[10px] rounded bg-gray-100 text-gray-600">
                                                                                    +{avgImprovementStr.moreCount} more
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                </td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(totalSavings).toLocaleString()}`}</td>
                                                                <td className="text-sm">{topContributorStr}</td>
                                                                <td>{(() => {
                                                                    if (totalSavingsAll <= 0) return '0%';
                                                                    const percentage = (totalSavings / totalSavingsAll * 100);
                                                                    
                                                                    // Check if there are other use cases with non-zero savings
                                                                    const otherUseCasesHaveSavings = useCases.some(otherUC => {
                                                                        if (otherUC.id === uc.id) return false;
                                                                        let otherSavings = 0;
                                                                        filteredMonths.forEach(month => {
                                                                            otherSavings += calculateSavings(otherUC, month.id);
                                                                        });
                                                                        return otherSavings > 0;
                                                                    });
                                                                    
                                                                    if (percentage > 0 && percentage < 0.1) {
                                                                        return '<0.1%';
                                                                    } else if (percentage > 99.9 && percentage < 100 && otherUseCasesHaveSavings) {
                                                                        return '>99.9%';
                                                                    }
                                                                    return `${percentage.toFixed(1)}%`;
                                                                })()}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Special Group View - Charts and Table */}
                                {analyticsView === 'specialgroup' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Special Group Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Special groups have the highest priority in cost calculations, overriding both category and channel defaults. 
                                                Hourly rates are converted to per-contact costs using the group's configured AHT. 
                                                "No Special Group" shows use cases using category or channel default costs.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Special Group</th><th>Cost Type</th><th>Rate<br /><small>($/hr or $/contact)</small></th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const groupStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    // Initialize No Special Group
                                                    groupStats['No Special Group'] = { costType: 'varies', value: '-', useCases: [], volume: 0, savings: 0 };
                                                    
                                                    // Initialize all special groups with their cost info
                                                    getAllSpecialGroups().forEach(group => {
                                                        let groupFound = false;
                                                        let groupCostType = 'perContact';
                                                        let groupValue = 0;
                                                        
                                                        // Search through all category-channel combinations for this special group
                                                        Object.values(categoryCosts).forEach(categoryData => {
                                                            if (!groupFound) {
                                                                Object.values(categoryData).forEach(channelData => {
                                                                    if (!groupFound && channelData && channelData._specialGroups && channelData._specialGroups[group]) {
                                                                        const groupCost = channelData._specialGroups[group];
                                                                        groupCostType = groupCost.costType || 'perContact';
                                                                        groupValue = groupCost.value || 0;
                                                                        groupFound = true;
                                                                    }
                                                                });
                                                            }
                                                        });
                                                        
                                                        groupStats[group] = { 
                                                            costType: groupCostType,
                                                            value: groupValue,
                                                            useCases: [], 
                                                            volume: 0, 
                                                            savings: 0 
                                                        };
                                                    });
                                                    
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        const key = uc.specialGroup || 'No Special Group';
                                                        
                                                        // Ensure the group exists in stats (in case of data inconsistency)
                                                        if (!groupStats[key]) {
                                                            groupStats[key] = { costType: 'perContact', value: 0, useCases: [], volume: 0, savings: 0 };
                                                        }
                                                        
                                                        groupStats[key].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            groupStats[key].volume += getTotalVolumeForUseCaseMonth(uc, md);
                                                            groupStats[key].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(groupStats).map(([group, stats]) => (
                                                        <tr key={group}>
                                                            <td className="font-semibold">{group}</td>
                                                            <td className="capitalize">{stats.costType}</td>
                                                            <td>{stats.value !== '-' ? `$${stats.value} ${stats.costType === 'hourly' ? '/hr' : '/contact'}` : '-'}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{(() => {
                                                                if (totalSavingsAll <= 0) return '0%';
                                                                const percentage = (stats.savings / totalSavingsAll * 100);
                                                                
                                                                // Check if there are other groups with non-zero savings
                                                                const otherGroupsHaveSavings = Object.values(groupStats).some(
                                                                    otherStats => otherStats !== stats && otherStats.savings > 0
                                                                );
                                                                
                                                                if (percentage > 0 && percentage < 0.1) {
                                                                    return '<0.1%';
                                                                } else if (percentage > 99.9 && percentage < 100 && otherGroupsHaveSavings) {
                                                                    return '>99.9%';
                                                                }
                                                                return `${percentage.toFixed(1)}%`;
                                                            })()}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Qualitative Benefits Section - Non-Monetary NPS Tracking */}
                                {hasNonMonetaryBenefits() && (
                                    <div className="mt-8 pt-6 border-t-2 border-gray-200">
                                        <div className="bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg p-6 mb-6">
                                            <h2 className="text-2xl font-bold text-gray-800 mb-2 flex items-center gap-2">
                                                üìä Qualitative Benefits
                                            </h2>
                                            <p className="text-sm text-gray-600">
                                                Non-monetary benefits tracked separately from financial ROI calculations
                                            </p>
                                        </div>

                                        {(() => {
                                            // Calculate non-monetary benefits across all use cases and months
                                            const npsData = [];
                                            const csatData = [];
                                            const filteredUseCases = getFilteredUseCases();
                                            const filteredMonths = getFilteredMonths();

                                            filteredUseCases.forEach(uc => {
                                                const normalized = ensureUseCaseHasBenefits(uc);
                                                const filteredBenefits = getFilteredBenefits(uc);
                                                filteredBenefits.forEach((benefit, benefitIndex) => {
                                                    filteredMonths.forEach(month => {
                                                        const monthData = uc.data[month.id] || {};
                                                        const nonMon = calculateNonMonetaryBenefits(uc, benefit, monthData, benefitIndex);
                                                        if (nonMon && nonMon.totalImpact > 0) {
                                                            const dataPoint = {
                                                                ...nonMon,
                                                                month,
                                                                category: uc.category,
                                                                channel: uc.channel,
                                                                useCase: uc.name
                                                            };
                                                            // Separate NPS and CSAT data
                                                            if (benefit.metric.includes('NPS')) {
                                                                npsData.push(dataPoint);
                                                            } else if (benefit.metric.includes('CSAT')) {
                                                                csatData.push(dataPoint);
                                                            }
                                                        }
                                                    });
                                                });
                                            });

                                            if (npsData.length === 0 && csatData.length === 0) {
                                                return (
                                                    <div className="bg-white rounded-lg shadow-lg p-6 text-center text-gray-500">
                                                        No non-monetary benefits data for the current filter period
                                                    </div>
                                                );
                                            }

                                            return (
                                                <>
                                                    {/* NPS Section */}
                                                    {npsData.length > 0 && (() => {
                                                        const totalSurveys = npsData.reduce((sum, d) => sum + d.volume, 0);
                                                        const totalPointSurveys = npsData.reduce((sum, d) => sum + d.totalImpact, 0);
                                                        const avgImprovement = totalPointSurveys / totalSurveys || 0;

                                                        return (
                                                            <div className="mb-8">
                                                                <h3 className="text-xl font-semibold text-purple-700 mb-4 flex items-center gap-2">
                                                                    <span>üìä</span> NPS (Net Promoter Score)
                                                                </h3>

                                                                {/* NPS Summary Cards */}
                                                                <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-3 gap-6'} mb-6`}>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Avg NPS Improvement</div>
                                                                        <div className="text-3xl font-bold text-purple-600">
                                                                            {avgImprovement.toFixed(1)}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">points per survey</div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Total Surveys</div>
                                                                        <div className="text-3xl font-bold text-blue-600">
                                                                            {totalSurveys.toLocaleString()}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">responses collected</div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Total Point-Surveys</div>
                                                                        <div className="text-3xl font-bold text-indigo-600">
                                                                            {totalPointSurveys.toLocaleString()}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">weighted impact</div>
                                                                    </div>
                                                                </div>

                                                                {/* NPS Charts */}
                                                                <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <h4 className="text-lg font-semibold mb-4">NPS Improvement Trend</h4>
                                                                        <div className="chart-container">
                                                                            <canvas ref={chartRefs.npsTrend}></canvas>
                                                                        </div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <h4 className="text-lg font-semibold mb-4">NPS Impact by Category</h4>
                                                                        <div className="chart-container">
                                                                            <canvas ref={chartRefs.npsCategory}></canvas>
                                                                        </div>
                                                                    </div>
                                                                </div>

                                                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                                                    <h4 className="text-lg font-semibold mb-4">NPS Impact by Channel</h4>
                                                                    <div className="chart-container">
                                                                        <canvas ref={chartRefs.npsChannel}></canvas>
                                                                    </div>
                                                                </div>

                                                                {/* NPS Data Table */}
                                                                <div className="bg-white rounded-lg shadow-lg p-6">
                                                                    <h4 className="text-lg font-semibold mb-4">Detailed NPS Data</h4>
                                                                    <div className="overflow-x-auto">
                                                                        <table className="analytics-table">
                                                                            <thead>
                                                                                <tr>
                                                                                    <th>Month</th>
                                                                                    <th>Category</th>
                                                                                    <th>Channel</th>
                                                                                    <th>Use Case</th>
                                                                                    <th>Surveys</th>
                                                                                    <th>Avg NPS<br/><small>(points)</small></th>
                                                                                    <th>Point-Surveys</th>
                                                                                </tr>
                                                                            </thead>
                                                                            <tbody>
                                                                                {npsData.map((d, i) => (
                                                                                    <tr key={i}>
                                                                                        <td>{(() => {
                                                                                            const [y, m] = d.month.id.split('-');
                                                                                            return new Date(y, m - 1).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                                                                                        })()}</td>
                                                                                        <td>{d.category}</td>
                                                                                        <td>{d.channel.charAt(0).toUpperCase() + d.channel.slice(1)}</td>
                                                                                        <td>{d.useCase}</td>
                                                                                        <td>{d.volume.toLocaleString()}</td>
                                                                                        <td>{d.improvement.toFixed(1)}</td>
                                                                                        <td>{d.totalImpact.toLocaleString()}</td>
                                                                                    </tr>
                                                                                ))}
                                                                            </tbody>
                                                                        </table>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}

                                                    {/* CSAT Section */}
                                                    {csatData.length > 0 && (() => {
                                                        const totalSurveys = csatData.reduce((sum, d) => sum + d.volume, 0);
                                                        const totalPointSurveys = csatData.reduce((sum, d) => sum + d.totalImpact, 0);
                                                        const avgImprovement = totalPointSurveys / totalSurveys || 0;

                                                        return (
                                                            <div>
                                                                <h3 className="text-xl font-semibold text-orange-700 mb-4 flex items-center gap-2">
                                                                    <span>‚≠ê</span> CSAT (Customer Satisfaction)
                                                                </h3>

                                                                {/* CSAT Summary Cards */}
                                                                <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-3 gap-6'} mb-6`}>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Avg CSAT Improvement</div>
                                                                        <div className="text-3xl font-bold text-orange-600">
                                                                            {avgImprovement.toFixed(1)}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">points per survey</div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Total Surveys</div>
                                                                        <div className="text-3xl font-bold text-amber-600">
                                                                            {totalSurveys.toLocaleString()}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">responses collected</div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <div className="text-sm text-gray-600 mb-1">Total Point-Surveys</div>
                                                                        <div className="text-3xl font-bold text-yellow-600">
                                                                            {totalPointSurveys.toLocaleString()}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500 mt-1">weighted impact</div>
                                                                    </div>
                                                                </div>

                                                                {/* CSAT Charts */}
                                                                <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <h4 className="text-lg font-semibold mb-4">CSAT Improvement Trend</h4>
                                                                        <div className="chart-container">
                                                                            <canvas ref={chartRefs.csatTrend}></canvas>
                                                                        </div>
                                                                    </div>
                                                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                                                        <h4 className="text-lg font-semibold mb-4">CSAT Impact by Category</h4>
                                                                        <div className="chart-container">
                                                                            <canvas ref={chartRefs.csatCategory}></canvas>
                                                                        </div>
                                                                    </div>
                                                                </div>

                                                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                                                    <h4 className="text-lg font-semibold mb-4">CSAT Impact by Channel</h4>
                                                                    <div className="chart-container">
                                                                        <canvas ref={chartRefs.csatChannel}></canvas>
                                                                    </div>
                                                                </div>

                                                                {/* CSAT Data Table */}
                                                                <div className="bg-white rounded-lg shadow-lg p-6">
                                                                    <h4 className="text-lg font-semibold mb-4">Detailed CSAT Data</h4>
                                                                    <div className="overflow-x-auto">
                                                                        <table className="analytics-table">
                                                                            <thead>
                                                                                <tr>
                                                                                    <th>Month</th>
                                                                                    <th>Category</th>
                                                                                    <th>Channel</th>
                                                                                    <th>Use Case</th>
                                                                                    <th>Surveys</th>
                                                                                    <th>Avg CSAT<br/><small>(points)</small></th>
                                                                                    <th>Point-Surveys</th>
                                                                                </tr>
                                                                            </thead>
                                                                            <tbody>
                                                                                {csatData.map((d, i) => (
                                                                                    <tr key={i}>
                                                                                        <td>{(() => {
                                                                                            const [y, m] = d.month.id.split('-');
                                                                                            return new Date(y, m - 1).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                                                                                        })()}</td>
                                                                                        <td>{d.category}</td>
                                                                                        <td>{d.channel.charAt(0).toUpperCase() + d.channel.slice(1)}</td>
                                                                                        <td>{d.useCase}</td>
                                                                                        <td>{d.volume.toLocaleString()}</td>
                                                                                        <td>{d.improvement.toFixed(1)}</td>
                                                                                        <td>{d.totalImpact.toLocaleString()}</td>
                                                                                    </tr>
                                                                                ))}
                                                                            </tbody>
                                                                        </table>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}
                                                </>
                                            );
                                        })()}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Financial Analysis Tab */}
                        {activeTab === 'financial' && (
                            <div className="space-y-6">
                                {/* Filter Controls */}
                                <div className="bg-white rounded-lg shadow-lg p-4">
                                    <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex items-center gap-4'}`}>
                                        <div className={`${isMobile ? 'flex justify-between items-center' : 'flex items-center gap-4'}`}>
                                            <span className="text-sm font-medium text-gray-600">Filters:</span>
                                            {isMobile && (
                                                <button
                                                    onClick={() => {
                                                        setSelectedCategory('all');
                                                        setSelectedChannel('all');
                                                        setSelectedSpecialGroup(null);
                                                        setSelectedMetric(null);
                                                    }}
                                                    className="px-3 py-1 text-sm text-blue-600 hover:text-blue-700"
                                                >
                                                    Clear
                                                </button>
                                            )}
                                        </div>
                                        
                                        <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-4 items-center flex-1'}`}>
                                            {/* Category Filter */}
                                            <select 
                                                value={selectedCategory} 
                                                onChange={(e) => setSelectedCategory(e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Categories</option>
                                                {getCategories().map(cat => (
                                                    <option key={cat} value={cat}>{cat}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Channel Filter */}
                                            <select 
                                                value={selectedChannel} 
                                                onChange={(e) => setSelectedChannel(e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Channels</option>
                                                {ALL_CHANNELS.map(ch => (
                                                    <option key={ch.id} value={ch.id} className="capitalize">
                                                        {ch.label}
                                                    </option>
                                                ))}
                                            </select>
                                            
                                            {/* Special Group Filter */}
                                            <select 
                                                value={selectedSpecialGroup || ''} 
                                                onChange={(e) => setSelectedSpecialGroup(e.target.value || null)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="">All Groups</option>
                                                <option value="none">No Special Group</option>
                                                {Array.from(new Set(
                                                    useCases
                                                        .map(uc => uc.specialGroup)
                                                        .filter(sg => sg)
                                                )).sort().map(group => (
                                                    <option key={group} value={group}>{group}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Benefit/Metric Filter */}
                                            <select 
                                                value={selectedMetric || 'all'} 
                                                onChange={(e) => setSelectedMetric(e.target.value === 'all' ? null : e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Metrics</option>
                                                {[...new Set(useCases.flatMap(uc => {
                                                    const normalized = ensureUseCaseHasBenefits(uc);
                                                    return normalized.benefits.map(benefit => benefit.metric);
                                                }))].sort().map(metric => (
                                                    <option key={metric} value={metric}>{metric}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Clear Filters Button - Desktop Only */}
                                            {!isMobile && (
                                                <button
                                                    onClick={() => {
                                                        setSelectedCategory('all');
                                                        setSelectedChannel('all');
                                                        setSelectedSpecialGroup(null);
                                                        setSelectedMetric(null);
                                                    }}
                                                    className="px-3 py-1.5 text-sm text-blue-600 hover:text-blue-700"
                                                >
                                                    Clear Filters
                                                </button>
                                            )}
                                        </div>
                                        
                                        {/* Active Filter Count */}
                                        <div className={`text-sm text-gray-600 ${isMobile ? 'text-center' : 'ml-auto'}`}>
                                            {(() => {
                                                let activeFilters = 0;
                                                if (selectedCategory !== 'all') activeFilters++;
                                                if (selectedChannel !== 'all') activeFilters++;
                                                if (selectedSpecialGroup) activeFilters++;
                                                if (selectedMetric) activeFilters++;
                                                return activeFilters > 0 
                                                    ? `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active ‚Ä¢ ${getFilteredUseCases().length} of ${useCases.length} use cases`
                                                    : `Showing all ${useCases.length} use cases`;
                                            })()}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Financial Settings Panel */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold flex items-center gap-2">
                                            üí∞ Implementation & Ongoing Costs
                                        </h3>
                                        <label className="flex items-center gap-2 text-sm">
                                            <input
                                                type="checkbox"
                                                checked={financialSettings.useCategoryBilling}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    useCategoryBilling: e.target.checked
                                                })}
                                                className="rounded"
                                            />
                                            Configure by Category
                                        </label>
                                    </div>
                                    
                                    {/* Show notice when category billing is enabled */}
                                    {financialSettings.useCategoryBilling && (
                                        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                                            <p className="text-sm text-yellow-800">
                                                ‚ö†Ô∏è <strong>Note:</strong> Overall implementation costs below are <strong>disabled</strong> when "Configure by Category" is enabled. 
                                                Category-specific costs configured below will be used instead.
                                            </p>
                                        </div>
                                    )}
                                    
                                    <div className={`grid grid-cols-1 md:grid-cols-2 gap-4 ${financialSettings.useCategoryBilling ? 'opacity-50 pointer-events-none' : ''}`}>
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                Implementation Cost Type
                                                {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                            </label>
                                            <select
                                                value={financialSettings.costType}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    costType: e.target.value
                                                })}
                                                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                disabled={financialSettings.useCategoryBilling}
                                            >
                                                <option value="fixed">Fixed Amount ($)</option>
                                                <option value="percentage">% of First Year Benefits</option>
                                            </select>
                                        </div>
                                        
                                        {financialSettings.costType === 'fixed' ? (
                                            <div>
                                                <label className="block text-sm font-medium mb-2">
                                                    Implementation Cost ($)
                                                    <span className="text-xs text-gray-500 ml-2">(Software, Training, Integration)</span>
                                                    {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                                </label>
                                                <input
                                                    type="number"
                                                    value={financialSettings.implementationCost}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        implementationCost: parseFloat(e.target.value) || 0
                                                    })}
                                                    className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                    placeholder="50000"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                            </div>
                                        ) : (
                                            <div>
                                                <label className="block text-sm font-medium mb-2">
                                                    Cost Percentage (%)
                                                    <span className="text-xs text-gray-500 ml-2">(of First Year Benefits)</span>
                                                    {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                                </label>
                                                <input
                                                    type="number"
                                                    value={financialSettings.costPercentage}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        costPercentage: parseFloat(e.target.value) || 0
                                                    })}
                                                    className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                    placeholder="20"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                            </div>
                                        )}
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                Discount Rate (%)
                                                <span className="text-xs text-gray-500 ml-2">(Typically 8-12%)</span>
                                            </label>
                                            <input
                                                type="number"
                                                value={financialSettings.discountRate * 100}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    discountRate: (parseFloat(e.target.value) || 10) / 100
                                                })}
                                                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                placeholder="10"
                                            />
                                            <div className="mt-2 p-3 bg-blue-50 rounded-lg text-xs text-gray-700">
                                                <strong>What is Discount Rate?</strong> It's your company's cost of capital or required return rate. 
                                                It accounts for the time value of money - a dollar today is worth more than a dollar tomorrow.
                                                <div className="mt-2">
                                                    <strong>How to determine it:</strong>
                                                    <ul className="list-disc list-inside mt-1 space-y-1">
                                                        <li><strong>Use your WACC</strong> (Weighted Average Cost of Capital) - typically 8-12% for most companies</li>
                                                        <li><strong>Conservative approach:</strong> Use 10% as a standard business case rate</li>
                                                        <li><strong>Tech companies:</strong> Often use 12-15% due to higher risk/return expectations</li>
                                                        <li><strong>Stable industries:</strong> May use 6-8% for lower risk projects</li>
                                                    </ul>
                                                </div>
                                                <div className="mt-2 font-medium">
                                                    üí° Ask your Finance team for your company's standard discount rate for NPV calculations.
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                <input
                                                    type="checkbox"
                                                    checked={financialSettings.includeOngoingCosts}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        includeOngoingCosts: e.target.checked
                                                    })}
                                                    className="mr-2"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                                Include Ongoing Monthly Costs
                                                {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                            </label>
                                            {financialSettings.includeOngoingCosts && (
                                                <>
                                                    <input
                                                        type="number"
                                                        value={financialSettings.ongoingCostMonthly}
                                                        onChange={(e) => setFinancialSettings({
                                                            ...financialSettings,
                                                            ongoingCostMonthly: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 mt-2"
                                                        placeholder="Monthly subscription/maintenance cost"
                                                        disabled={financialSettings.useCategoryBilling}
                                                    />
                                                    {!financialSettings.useCategoryBilling && (
                                                        <div className="mt-3">
                                                            <label className="block text-xs font-medium mb-1">Billing Cycle</label>
                                                            <select
                                                                value={financialSettings.billingCycle || 'monthly'}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    billingCycle: e.target.value,
                                                                    customMonths: e.target.value === 'custom' ? 
                                                                        (financialSettings.customMonths || 6) : 
                                                                        undefined
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            >
                                                                <option value="monthly">Monthly</option>
                                                                <option value="quarterly">Quarterly (3 mo)</option>
                                                                <option value="semiannual">Semi-Annual (6 mo)</option>
                                                                <option value="annual">Annual (12 mo)</option>
                                                                <option value="custom">Custom Period</option>
                                                            </select>
                                                            {financialSettings.billingCycle === 'custom' && (
                                                                <input
                                                                    type="number"
                                                                    min="1"
                                                                    value={financialSettings.customMonths || 6}
                                                                    onChange={(e) => setFinancialSettings({
                                                                        ...financialSettings,
                                                                        customMonths: parseInt(e.target.value) || 1
                                                                    })}
                                                                    className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500 mt-2"
                                                                    placeholder="Number of months"
                                                                />
                                                            )}
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Category-Specific Billing Configuration */}
                                {financialSettings.useCategoryBilling && (
                                    <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                        <h3 className="text-lg font-semibold mb-4">üìã Category-Specific Implementation & Billing</h3>
                                        <div className="space-y-4">
                                            {categories.map(category => (
                                                <div key={category} className="border rounded-lg p-4 bg-gray-50">
                                                    <h4 className="font-semibold text-md mb-3 text-blue-700">{category}</h4>
                                                    <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Implementation Cost ($)</label>
                                                            <input
                                                                type="number"
                                                                value={financialSettings.categoryBilling?.[category]?.implementationCost || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            implementationCost: parseFloat(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Start Month</label>
                                                            <input
                                                                type="number"
                                                                min="0"
                                                                value={financialSettings.categoryBilling?.[category]?.implementationMonth || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            implementationMonth: parseInt(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                                title="Month when implementation starts (0 = first month)"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Ongoing Cost ($/mo)</label>
                                                            <input
                                                                type="number"
                                                                value={financialSettings.categoryBilling?.[category]?.ongoingCostMonthly || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            ongoingCostMonthly: parseFloat(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Billing Cycle</label>
                                                            <select
                                                                value={financialSettings.categoryBilling?.[category]?.billingCycle || 'monthly'}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            billingCycle: e.target.value,
                                                                            customMonths: e.target.value === 'custom' ? 
                                                                                (financialSettings.categoryBilling?.[category]?.customMonths || 6) : 
                                                                                undefined
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            >
                                                                <option value="monthly">Monthly</option>
                                                                <option value="quarterly">Quarterly (3 mo)</option>
                                                                <option value="semiannual">Semi-Annual (6 mo)</option>
                                                                <option value="annual">Annual (12 mo)</option>
                                                                <option value="custom">Custom Period</option>
                                                            </select>
                                                        </div>
                                                        {financialSettings.categoryBilling?.[category]?.billingCycle === 'custom' && (
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Custom Period (months)</label>
                                                                <input
                                                                    type="number"
                                                                    min="1"
                                                                    value={financialSettings.categoryBilling?.[category]?.customMonths || 6}
                                                                    onChange={(e) => setFinancialSettings({
                                                                        ...financialSettings,
                                                                        categoryBilling: {
                                                                            ...financialSettings.categoryBilling,
                                                                            [category]: {
                                                                                ...(financialSettings.categoryBilling?.[category] || {}),
                                                                                customMonths: parseInt(e.target.value) || 1
                                                                            }
                                                                        }
                                                                    })}
                                                                    className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                                    placeholder="Number of months"
                                                                />
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                                            <p className="text-sm text-blue-800">
                                                üí° <strong>Tip:</strong> Configure different implementation timelines and costs for each category. 
                                                Start Month determines when the implementation cost is incurred (0 = first month of analysis).
                                            </p>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Financial Metrics Display */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold">üìä Key Financial Metrics</h3>
                                        <button
                                            onClick={() => {
                                                const filteredUseCases = getFilteredUseCases();
                                                const financialCSV = generateFinancialAnalysisCSV(filteredUseCases, financialMetrics, financialSettings);
                                                downloadFile(financialCSV, `financial_analysis_${new Date().toISOString().split('T')[0]}.xls`, 'application/vnd.ms-excel');
                                            }}
                                            className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center gap-2"
                                        >
                                            <Icons.Download />
                                            Export to Excel
                                        </button>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Net Present Value (NPV)</div>
                                            <div className="text-2xl font-bold text-blue-600">
                                                ${financialMetrics.npv.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Value in today's dollars
                                            </div>
                                        </div>
                                        
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Internal Rate of Return (IRR)</div>
                                            <div className="text-2xl font-bold text-green-600">
                                                {financialMetrics.irr ? `${financialMetrics.irr.toFixed(1)}%` : 'N/A'}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Annual return rate
                                            </div>
                                        </div>
                                        
                                        <div className="bg-purple-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Payback Period</div>
                                            <div className="text-2xl font-bold text-purple-600">
                                                {financialMetrics.paybackPeriod !== null && financialMetrics.paybackPeriod !== undefined
                                                    ? `${Math.max(0.1, financialMetrics.paybackPeriod).toFixed(1)} mo`
                                                    : 'N/A'}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Break-even point
                                            </div>
                                        </div>
                                        
                                        <div className="bg-orange-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Total ROI</div>
                                            <div className="text-2xl font-bold text-orange-600">
                                                {financialMetrics.totalROI.toFixed(0)}%
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Return on investment
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {/* Calculation Breakdown Helper */}
                                    <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                                        <details className="cursor-pointer">
                                            <summary className="font-semibold text-sm text-gray-700 hover:text-gray-900">
                                                üí° How are these numbers calculated? (Click to expand)
                                            </summary>
                                            <div className="mt-3 space-y-3 text-sm text-gray-600">
                                                {(() => {
                                                    try {
                                                        // Calculate the breakdown values
                                                        const filteredMonths = getFilteredMonths();
                                                        const filteredUseCases = getFilteredUseCases();
                                                        
                                                        if (!filteredMonths || filteredMonths.length === 0) {
                                                            return <div>No data available for calculation breakdown.</div>;
                                                        }
                                                        let totalBenefits = 0;
                                                        let totalImplementation = 0;
                                                        let totalOngoing = 0;
                                                    
                                                        filteredMonths.forEach((month, index) => {
                                                            let monthlyBenefit = 0;
                                                            filteredUseCases.forEach(uc => {
                                                                monthlyBenefit += calculateSavings(uc, month.id);
                                                            });
                                                            totalBenefits += monthlyBenefit;
                                                        
                                                            if (financialSettings.useCategoryBilling) {
                                                                categories.forEach(category => {
                                                                    const catSettings = financialSettings.categoryBilling?.[category];
                                                                    if (catSettings) {
                                                                        if (index === catSettings.implementationMonth) {
                                                                            totalImplementation += catSettings.implementationCost || 0;
                                                                        }
                                                                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                        if (index > catSettings.implementationMonth && 
                                                                            ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                            totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                                        }
                                                                    }
                                                                });
                                                            } else {
                                                                if (index === 0) {
                                                                    totalImplementation = financialSettings.implementationCost || 0;
                                                                }
                                                                const cycleMonths = getBillingCycleMonths(
                                                                    financialSettings.billingCycle || 'monthly',
                                                                    financialSettings.customMonths
                                                                );
                                                                if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                                    totalOngoing += financialSettings.ongoingCostMonthly * cycleMonths;
                                                                }
                                                            }
                                                        });
                                                    
                                                        const totalCosts = totalImplementation + totalOngoing;
                                                        const netGain = totalBenefits - totalCosts;
                                                        
                                                        return (
                                                        <>
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">üìà ROI Calculation Breakdown</h4>
                                                                <div className="space-y-1">
                                                                    <div>Total Benefits: <span className="font-mono font-bold text-green-600">${totalBenefits.toLocaleString()}</span></div>
                                                                    <div>Implementation Cost: <span className="font-mono font-bold text-red-600">-${totalImplementation.toLocaleString()}</span></div>
                                                                    {totalOngoing > 0 && (
                                                                        <div>Total Ongoing Costs: <span className="font-mono font-bold text-red-600">-${totalOngoing.toLocaleString()}</span></div>
                                                                    )}
                                                                    <div className="border-t pt-1 mt-1">
                                                                        <div>Net Gain: <span className="font-mono font-bold">${netGain.toLocaleString()}</span></div>
                                                                        <div className="text-xs text-gray-500 mt-1">
                                                                            <strong>Formula:</strong> ROI = (Benefits - Costs) √∑ Costs √ó 100
                                                                        </div>
                                                                        <div className="text-xs text-gray-500">
                                                                            <strong>Calculation:</strong> ({totalBenefits.toLocaleString()} - {totalCosts.toLocaleString()}) √∑ {totalCosts.toLocaleString()} √ó 100 = <strong className="text-orange-600">{financialMetrics.totalROI.toFixed(1)}%</strong>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">üí∞ NPV (Net Present Value)</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>NPV discounts future cash flows to present value using discount rate: <strong>{(financialSettings.discountRate * 100).toFixed(1)}%</strong></div>
                                                                    <div><strong>Formula:</strong> NPV = Œ£(Cash Flow √∑ (1 + rate)^period)</div>
                                                                    <div>Each month's benefit is discounted more the further in the future it occurs</div>
                                                                    <div className="text-blue-600 font-semibold">NPV = ${financialMetrics.npv.toLocaleString()}</div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">üìä IRR (Internal Rate of Return)</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>IRR is the discount rate that makes NPV = 0</div>
                                                                    <div>It represents the annual return rate of your investment</div>
                                                                    <div>Higher IRR means better investment performance</div>
                                                                    <div className="text-green-600 font-semibold">Annual IRR = {financialMetrics.irr ? `${financialMetrics.irr.toFixed(1)}%` : 'N/A'}</div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">‚è±Ô∏è Payback Period</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>The point when cumulative benefits equal total costs</div>
                                                                    <div>Calculated by tracking when cumulative cash flow becomes positive</div>
                                                                    {financialMetrics.breakEvenMonth && (
                                                                        <div className="text-purple-600 font-semibold">Your investment breaks even in month {financialMetrics.breakEvenMonth}</div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-blue-100 p-3 rounded">
                                                                <div className="text-xs">
                                                                    <strong>üí° Pro Tip:</strong> Export to Excel to see the complete month-by-month calculation with formulas you can verify and modify. All calculations use the filtered data based on your current view settings.
                                                                </div>
                                                            </div>
                                                        </>
                                                    );
                                                    } catch (error) {
                                                        console.error('Error in calculation breakdown:', error);
                                                        return <div>Error calculating breakdown. Check console.</div>;
                                                    }
                                                })()}
                                            </div>
                                        </details>
                                    </div>
                                    
                                    {/* Payback Period Indicator */}
                                    {financialMetrics.paybackPeriod && (
                                        <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                                            <div className="text-sm font-medium mb-2">Payback Period Assessment:</div>
                                            <div className={`text-sm ${
                                                financialMetrics.paybackPeriod < 12 ? 'text-green-600' :
                                                financialMetrics.paybackPeriod < 18 ? 'text-yellow-600' :
                                                'text-red-600'
                                            }`}>
                                                {financialMetrics.paybackPeriod < 12 ? '‚úÖ Excellent - Less than 12 months' :
                                                 financialMetrics.paybackPeriod < 18 ? '‚ö†Ô∏è Good - 12-18 months' :
                                                 '‚ö†Ô∏è Acceptable - More than 18 months'}
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* Cash Flow Table */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold">üíµ Cash Flow Analysis</h3>
                                        <button
                                            onClick={() => setFinancialSettings({
                                                ...financialSettings,
                                                showMonthlyBreakdown: !financialSettings.showMonthlyBreakdown
                                            })}
                                            className="text-sm text-blue-600 hover:text-blue-700"
                                        >
                                            {financialSettings.showMonthlyBreakdown ? 'Hide' : 'Show'} Monthly Details
                                        </button>
                                    </div>
                                    
                                    {financialSettings.showMonthlyBreakdown && financialMetrics.cashFlows.length > 0 && (
                                        <div className="overflow-x-auto">
                                            <table className="min-w-full">
                                                <thead className="bg-gray-50">
                                                    <tr>
                                                        <th className="text-left py-2 px-3">Month</th>
                                                        <th className="text-right py-2 px-3 text-green-700">Benefits</th>
                                                        <th className="text-right py-2 px-3 text-red-700">Implementation</th>
                                                        <th className="text-right py-2 px-3 text-red-700">Ongoing</th>
                                                        <th className="text-right py-2 px-3 font-semibold">Net Cash Flow</th>
                                                        <th className="text-right py-2 px-3">Cumulative</th>
                                                        <th className="text-right py-2 px-3">Present Value</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {financialMetrics.cashFlows.map((cf, index) => {
                                                        const cumulative = financialMetrics.cashFlows
                                                            .slice(0, index + 1)
                                                            .reduce((sum, val) => sum + val, 0);
                                                        const presentValue = cf / Math.pow(1 + financialSettings.discountRate/12, index);
                                                        
                                                        const filteredMonths = getFilteredMonths();
                                                        const filteredUseCases = getFilteredUseCases();
                                                        const monthLabel = filteredMonths[index] 
                                                            ? `${filteredMonths[index].month} ${filteredMonths[index].year}`
                                                            : `Month ${index + 1}`;
                                                        
                                                        // Calculate breakdown for this month
                                                        let monthlyBenefit = 0;
                                                        let implementationCost = 0;
                                                        let ongoingCost = 0;
                                                        
                                                        // Calculate benefits
                                                        if (filteredMonths[index]) {
                                                            filteredUseCases.forEach(uc => {
                                                                monthlyBenefit += calculateSavings(uc, filteredMonths[index].id);
                                                            });
                                                        }
                                                        
                                                        // Calculate costs based on billing mode
                                                        if (financialSettings.useCategoryBilling) {
                                                            // Only include costs for categories that have filtered use cases
                                                            const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                                                            activeCategories.forEach(category => {
                                                                const catSettings = financialSettings.categoryBilling?.[category];
                                                                if (catSettings) {
                                                                    if (index === catSettings.implementationMonth) {
                                                                        implementationCost += catSettings.implementationCost || 0;
                                                                    }
                                                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                    if (index > catSettings.implementationMonth && 
                                                                        ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                        ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                                    }
                                                                }
                                                            });
                                                        } else {
                                                            if (index === 0) {
                                                                implementationCost = financialSettings.implementationCost || 0;
                                                            }
                                                            const cycleMonths = getBillingCycleMonths(
                                                                financialSettings.billingCycle || 'monthly',
                                                                financialSettings.customMonths
                                                            );
                                                            if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                                ongoingCost = financialSettings.ongoingCostMonthly * cycleMonths;
                                                            }
                                                        }
                                                        
                                                        return (
                                                            <tr key={index} className="border-b hover:bg-gray-50">
                                                                <td className="py-2 px-3">
                                                                    {monthLabel}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-green-600">
                                                                    ${monthlyBenefit.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-red-600">
                                                                    {implementationCost > 0 ? `-$${implementationCost.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-'}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-red-600">
                                                                    {ongoingCost > 0 ? `-$${ongoingCost.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-'}
                                                                </td>
                                                                <td className={`text-right py-2 px-3 font-bold ${cf < 0 ? 'text-red-600' : 'text-green-600'}`}>
                                                                    ${cf.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className={`text-right py-2 px-3 font-medium ${cumulative < 0 ? 'text-red-600' : 'text-green-600'}`}>
                                                                    ${cumulative.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-gray-600">
                                                                    ${presentValue.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                            </tr>
                                                        );
                                                    })}
                                                </tbody>
                                                <tfoot className="bg-gray-100 font-semibold">
                                                    <tr>
                                                        <td className="py-2 px-3">Total</td>
                                                        <td className="text-right py-2 px-3 text-green-700">
                                                            ${(() => {
                                                                let total = 0;
                                                                const filteredMonths = getFilteredMonths();
                                                                const filteredUseCases = getFilteredUseCases();
                                                                filteredMonths.forEach(month => {
                                                                    filteredUseCases.forEach(uc => {
                                                                        total += calculateSavings(uc, month.id);
                                                                    });
                                                                });
                                                                return total.toLocaleString(undefined, { maximumFractionDigits: 0 });
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-red-700">
                                                            -${(() => {
                                                                let total = 0;
                                                                if (financialSettings.useCategoryBilling) {
                                                                    // Only include costs for categories that have filtered use cases
                                                                    const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                                                                    activeCategories.forEach(category => {
                                                                        const catSettings = financialSettings.categoryBilling?.[category];
                                                                        if (catSettings) {
                                                                            total += catSettings.implementationCost || 0;
                                                                        }
                                                                    });
                                                                } else {
                                                                    total = financialSettings.implementationCost || 0;
                                                                }
                                                                return total.toLocaleString(undefined, { maximumFractionDigits: 0 });
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-red-700">
                                                            {(() => {
                                                                let total = 0;
                                                                const filteredMonths = getFilteredMonths();
                                                                
                                                                if (financialSettings.useCategoryBilling) {
                                                                    // Only include costs for categories that have filtered use cases
                                                                    const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                                                                    activeCategories.forEach(category => {
                                                                        const catSettings = financialSettings.categoryBilling?.[category];
                                                                        if (catSettings) {
                                                                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                            const monthlyCost = catSettings.ongoingCostMonthly || 0;
                                                                            for (let i = 0; i < filteredMonths.length; i++) {
                                                                                if (i > catSettings.implementationMonth && 
                                                                                    ((i - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                                    total += monthlyCost * cycleMonths;
                                                                                }
                                                                            }
                                                                        }
                                                                    });
                                                                } else if (financialSettings.includeOngoingCosts) {
                                                                    const cycleMonths = getBillingCycleMonths(
                                                                        financialSettings.billingCycle || 'monthly',
                                                                        financialSettings.customMonths
                                                                    );
                                                                    for (let i = 1; i < filteredMonths.length; i++) {
                                                                        if ((i - 1) % cycleMonths === 0) {
                                                                            total += financialSettings.ongoingCostMonthly * cycleMonths;
                                                                        }
                                                                    }
                                                                }
                                                                return total > 0 ? `-$${total.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-';
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3">
                                                            ${financialMetrics.cashFlows.reduce((sum, cf) => sum + cf, 0).toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                        </td>
                                                        <td className="text-right py-2 px-3">
                                                            -
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-blue-600">
                                                            NPV: ${financialMetrics.npv.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                        </td>
                                                    </tr>
                                                </tfoot>
                                            </table>
                                        </div>
                                    )}
                                    
                                    {/* Quick Summary for non-detailed view */}
                                    {!financialSettings.showMonthlyBreakdown && (() => {
                                        // Calculate actual totals from the data
                                        const filteredMonths = getFilteredMonths();
                                        const filteredUseCases = getFilteredUseCases();
                                        let totalBenefits = 0;
                                        let totalImplementation = 0;
                                        let totalOngoing = 0;
                                        
                                        filteredMonths.forEach((month, index) => {
                                            let monthlyBenefit = 0;
                                            filteredUseCases.forEach(uc => {
                                                monthlyBenefit += calculateSavings(uc, month.id);
                                            });
                                            totalBenefits += monthlyBenefit;
                                            
                                            if (financialSettings.useCategoryBilling) {
                                                // Only include costs for categories that have filtered use cases
                                                const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                                                activeCategories.forEach(category => {
                                                    const catSettings = financialSettings.categoryBilling?.[category];
                                                    if (catSettings) {
                                                        if (index === catSettings.implementationMonth) {
                                                            totalImplementation += catSettings.implementationCost || 0;
                                                        }
                                                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                        if (index > catSettings.implementationMonth && 
                                                            ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                            totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                        }
                                                    }
                                                });
                                            } else {
                                                if (index === 0) {
                                                    totalImplementation = financialSettings.implementationCost || 0;
                                                }
                                                const cycleMonths = getBillingCycleMonths(
                                                    financialSettings.billingCycle || 'monthly',
                                                    financialSettings.customMonths
                                                );
                                                if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                    totalOngoing += financialSettings.ongoingCostMonthly * cycleMonths;
                                                }
                                            }
                                        });
                                        
                                        const netGain = totalBenefits - totalImplementation - totalOngoing;
                                        
                                        return (
                                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">
                                                        Implementation Cost
                                                        {financialSettings.useCategoryBilling && (
                                                            <span className="text-xs text-blue-600 ml-1">(Category Total)</span>
                                                        )}
                                                    </div>
                                                    <div className="text-lg font-semibold text-red-600">
                                                        -${totalImplementation.toLocaleString()}
                                                    </div>
                                                    {financialSettings.useCategoryBilling && (
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            From {categories.filter(cat => 
                                                                financialSettings.categoryBilling?.[cat]?.implementationCost > 0
                                                            ).length} categories
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">Total Benefits</div>
                                                    <div className="text-lg font-semibold text-green-600">
                                                        ${totalBenefits.toLocaleString()}
                                                    </div>
                                                </div>
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">Net Gain</div>
                                                    <div className="text-lg font-semibold text-blue-600">
                                                        ${netGain.toLocaleString()}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                </div>
                                
                                {/* Financial Charts */}
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">üìà Cash Flow & Break-Even Analysis</h3>
                                        <div className="chart-container">
                                            <canvas ref={chartRefs.cashFlow}></canvas>
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">üí∞ Cumulative Net Cash Flow</h3>
                                        <div className="chart-container">
                                            <canvas ref={chartRefs.breakeven}></canvas>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Category-specific charts when using category billing */}
                                {financialSettings.useCategoryBilling && (
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-4">üè∑Ô∏è Category Implementation Costs</h3>
                                            <div className="chart-container">
                                                <canvas ref={chartRefs.categoryImplementation}></canvas>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-4">üìä Category Cost Timeline</h3>
                                            <div className="chart-container">
                                                <canvas ref={chartRefs.categoryCostTimeline}></canvas>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Financial Formulas Reference */}
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-4">üìê Financial Formulas Reference</h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                        <div>
                                            <div className="font-medium mb-2">NPV (Net Present Value):</div>
                                            <code className="block p-2 bg-white rounded text-xs">
                                                NPV = Œ£(CashFlow_t / (1 + r)^t) - Initial Investment
                                            </code>
                                            <div className="text-gray-600 mt-1">Where r = discount rate, t = time period</div>
                                        </div>
                                        <div>
                                            <div className="font-medium mb-2">IRR (Internal Rate of Return):</div>
                                            <code className="block p-2 bg-white rounded text-xs">
                                                0 = Œ£(CashFlow_t / (1 + IRR)^t)
                                            </code>
                                            <div className="text-gray-600 mt-1">Rate where NPV equals zero</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Guidance Tab */}
                        {activeTab === 'guidance' && (
                            <div className="space-y-6">
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <h2 className="text-2xl font-bold mb-4">Input Guidance</h2>
                                    <div className="grid grid-cols-1 gap-4">
                                        {Object.keys(InputGuidance).map((metric) => (
                                            <div
                                                key={metric}
                                                className="guidance-card cursor-pointer hover:shadow-lg transition-shadow"
                                                onClick={() => {
                                                    setSelectedMetricGuide(metric);
                                                    setShowGuidanceModal(true);
                                                }}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <div className="guidance-title">{metric}</div>
                                                        <div className="guidance-content">
                                                            <p className="mb-2">{InputGuidance[metric].baseline.description}</p>
                                                        </div>
                                                    </div>
                                                    <Icons.Info />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Guidance Modal */}
                        <GuidanceModal />
                        
                        {/* Mobile Floating Sponsor Button - Top right */}
                        {isMobile && (
                            <div
                                onClick={() => setShowSponsorOverlay(true)}
                                style={{
                                    position: 'fixed',
                                    top: '10px',
                                    right: '10px',
                                    width: '40px',
                                    height: '40px',
                                    borderRadius: '50%',
                                    background: 'linear-gradient(135deg, #ec4899, #8b5cf6)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                                    zIndex: 9999,
                                    cursor: 'pointer',
                                    WebkitTapHighlightColor: 'transparent'
                                }}
                                role="button"
                                aria-label="Support"
                            >
                                <div style={{ color: 'white', fontSize: '18px', lineHeight: '1' }}>‚ô•</div>
                            </div>
                        )}
                        
                        {/* Edit Use Case Modal */}
                        {showEditModal && editingUseCase && (
                            <div className="modal-overlay" onClick={() => setShowEditModal(false)}>
                                <div className="modal-content" style={{maxWidth: '600px'}} onClick={(e) => e.stopPropagation()}>
                                    <div className="modal-close" onClick={() => setShowEditModal(false)}>
                                        <Icons.Close />
                                    </div>
                                    <h3 className="text-xl font-bold mb-4">Edit Use Case: {editingUseCase.name}</h3>
                                    
                                    <div className="space-y-4">
                                        {/* Edit Name */}
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Use Case Name</label>
                                            <input
                                                type="text"
                                                value={editingUseCase.name}
                                                onChange={(e) => setEditingUseCase({...editingUseCase, name: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-md"
                                            />
                                        </div>
                                        
                                        {/* Edit Category and Channel */}
                                        <div className="grid grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium mb-1">Category</label>
                                                <select
                                                    value={editingUseCase.category}
                                                    onChange={(e) => setEditingUseCase({...editingUseCase, category: e.target.value})}
                                                    className="w-full px-3 py-2 border rounded-md"
                                                >
                                                    {categories.map(category => (
                                                        <option key={category} value={category}>{category}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium mb-1">Channel</label>
                                                <select
                                                    value={editingUseCase.channel}
                                                    onChange={(e) => setEditingUseCase({...editingUseCase, channel: e.target.value})}
                                                    className="w-full px-3 py-2 border rounded-md"
                                                >
                                                    <option value="phone">Phone</option>
                                                    <option value="chat">Chat</option>
                                                    <option value="email">Email</option>
                                                    <option value="sms">SMS</option>
                                                    <option value="social">Social</option>
                                                    <option value="bot">Bot</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        {/* Edit Benefits */}
                                        <div>
                                            <h4 className="font-medium mb-2">Benefits (Value Drivers)</h4>
                                            {editingUseCase.benefits && editingUseCase.benefits.map((benefit, index) => (
                                                <div key={index} className="mb-3">
                                                    <div className="grid grid-cols-6 gap-2 mb-1 items-center">
                                                        <select
                                                            value={benefit.metric}
                                                            onChange={(e) => {
                                                                const newBenefits = [...editingUseCase.benefits];
                                                                newBenefits[index] = {...benefit, metric: e.target.value};
                                                                setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                            }}
                                                            className="col-span-3 px-3 py-2 border rounded"
                                                        >
                                                            {getAvailableMetrics().map(metric => (
                                                                <option key={metric} value={metric} disabled={editingUseCase?.benefits?.some((b, idx) => idx !== index && b.metric === metric)}>{metric}</option>
                                                            ))}
                                                        </select>
                                                        <div className="col-span-2">
                                                            <label className="text-xs text-gray-600 block mb-1">
                                                                Baseline {benefit.metric.includes('min') ? '(minutes)' : benefit.metric.includes('points') ? '(points)' : '(%)'}
                                                            </label>
                                                            <input
                                                                type="number"
                                                                placeholder={
                                                                    benefit.metric.includes('min') ? 'Minutes' : 
                                                                    benefit.metric.includes('points') ? 'Points' : 
                                                                    'Percent'
                                                                }
                                                                value={benefit.baselineValue || ''}
                                                                onChange={(e) => {
                                                                    const newBenefits = [...editingUseCase.benefits];
                                                                    newBenefits[index] = {...benefit, baselineValue: parseFloat(e.target.value) || 0};
                                                                    setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                                }}
                                                                className="col-span-2 px-3 py-2 border rounded w-full"
                                                            />
                                                        </div>
                                                        <button
                                                        onClick={() => {
                                                            const newBenefits = editingUseCase.benefits.filter((_, i) => i !== index);
                                                            setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                        }}
                                                        className="text-red-600 hover:text-red-800"
                                                    >
                                                            <Icons.Trash />
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                            
                                            {/* Add New Benefit Button */}
                                            <button
                                                onClick={() => {
                                                    // Find a metric that isn't already used
                                                    const availableMetrics = getAvailableMetrics().filter(m => 
                                                        !editingUseCase.benefits.some(b => b.metric === m)
                                                    );
                                                    if (availableMetrics.length > 0) {
                                                        setEditingUseCase({
                                                            ...editingUseCase, 
                                                            benefits: [...(editingUseCase.benefits || []), {metric: availableMetrics[0], baselineValue: 0}]
                                                        });
                                                    } else {
                                                        alert('All available metrics have been added.');
                                                    }
                                                }}
                                                className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 mt-2"
                                                disabled={editingUseCase?.benefits?.length >= getAvailableMetrics().length}
                                            >
                                                Add Benefit
                                            </button>
                                        </div>
                                        
                                        {/* Save/Cancel Buttons */}
                                        <div className="flex justify-end gap-2 pt-4">
                                            <button
                                                onClick={() => {
                                                    setShowEditModal(false);
                                                    setEditingUseCase(null);
                                                }}
                                                className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
                                            >
                                                Cancel
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (editingUseCase.name) {
                                                        // Save to undo stack before making changes
                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                        setRedoStack([]);
                                                        
                                                        const original = useCases.find(uc => uc.id === editingUseCase.id);
                                                        const migrated = original ? migrateUseCaseBenefitKeys(original, editingUseCase) : editingUseCase;
                                                        setUseCases(useCases.map(uc => 
                                                            uc.id === editingUseCase.id ? migrated : uc
                                                        ));
                                                        setShowEditModal(false);
                                                        setEditingUseCase(null);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                            >
                                                Save Changes
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Render the application with loading animation
        const root = ReactDOM.createRoot(document.getElementById('root'));
        
        // Render the app immediately (it will be behind the loading screen)
        root.render(<AIValueCalculator />);
        
        // Start fade out animation after the app has loaded
        window.addEventListener('load', () => {
            // Give it a moment to ensure everything is rendered
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.classList.add('fade-out');
                    // Remove loading screen completely after fade animation
                    setTimeout(() => {
                        if (loadingScreen && loadingScreen.parentNode) {
                            loadingScreen.parentNode.removeChild(loadingScreen);
                        }
                    }, 2000); // Match the CSS transition duration
                }
            }, 1500); // Show loading animation for at least 1.5 seconds
        });
    </script>
</body>
</html>
