<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Contact Center ROI Calculator - Advanced Edition</title>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
    
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        // Register Chart.js components
        if (window.Chart && Chart.controllers && Chart.elements && Chart.plugins && Chart.scales) {
            try {
                Chart.register(
                    ...Object.values(Chart.controllers),
                    ...Object.values(Chart.elements),
                    ...Object.values(Chart.plugins),
                    ...Object.values(Chart.scales)
                );
            } catch (e) {
                console.log('Chart registration handled by Chart.js automatically');
            }
        }
    </script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Alternating row colors */
        .row-even {
            background-color: #ffffff !important;
        }
        .row-odd {
            background-color: #f9fafb !important;
        }
        .row-selected {
            background-color: #dbeafe !important;
        }
        .row-even td {
            background-color: inherit !important;
        }
        .row-odd td {
            background-color: inherit !important;
        }
        .row-selected td {
            background-color: inherit !important;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 100px auto;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Print styles */
        @media print {
            .no-print {
                display: none !important;
            }
            body {
                background: white !important;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            /* Mobile layout adjustments */
            body {
                padding: 0;
                margin: 0;
            }
            
            /* Mobile navigation */
            .mobile-nav-toggle {
                display: block !important;
            }
            
            .desktop-only {
                display: none !important;
            }
            
            .mobile-only {
                display: block !important;
            }
            
            /* Mobile tabs - horizontal scroll */
            .tab-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                padding-bottom: 4px;
            }
            
            .tab-container::-webkit-scrollbar {
                height: 4px;
            }
            
            /* Mobile cards stack */
            .stats-grid {
                grid-template-columns: 1fr !important;
                gap: 0.5rem !important;
            }
            
            /* Mobile table */
            .mobile-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 0 -1rem;
                padding: 0 1rem;
            }
            
            table {
                min-width: 600px;
            }
            
            /* Mobile inputs */
            input[type="number"],
            input[type="text"] {
                font-size: 16px !important; /* 16px prevents zoom on iOS */
                min-height: 40px !important;
                padding: 8px 12px !important;
            }
            
            /* Mobile buttons - smaller for mobile */
            button {
                min-height: 32px !important;
                font-size: 13px !important;
                padding: 6px 10px !important;
                touch-action: manipulation;
            }
            
            /* Mobile dropdowns - minimal styling to allow native behavior */
            select {
                font-size: 16px; /* 16px prevents zoom on iOS */
            }
            
            /* Don't override native select appearance on mobile */
            select option {
                font-size: 16px;
            }
            
            /* Mobile modals */
            .modal-content {
                width: 95% !important;
                max-width: none !important;
                margin: 1rem !important;
                max-height: 90vh !important;
                padding: 1rem !important;
            }
            
            /* Mobile charts */
            .chart-container {
                height: 250px !important;
            }
            
            /* Mobile tooltips */
            .tooltip .tooltiptext {
                width: 90vw !important;
                left: 5vw !important;
                margin-left: 0 !important;
                bottom: 100% !important;
            }
            
            /* Mobile filter buttons */
            .filter-container {
                flex-wrap: wrap !important;
                gap: 0.5rem !important;
            }
            
            .filter-btn {
                flex: 1 1 calc(50% - 0.25rem) !important;
                min-width: 120px !important;
                font-size: 12px !important;
            }
            
            /* Mobile header controls */
            .header-controls {
                flex-direction: column !important;
                gap: 0.5rem !important;
            }
            
            .header-buttons {
                display: grid !important;
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 0.5rem !important;
                width: 100% !important;
            }
            
            /* Mobile date inputs */
            .date-range-container {
                flex-direction: column !important;
                gap: 0.5rem !important;
            }
            
            /* Mobile settings grid */
            .settings-grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Mobile bulk edit */
            .bulk-edit-controls {
                flex-direction: column !important;
                position: sticky !important;
                bottom: 0 !important;
                background: white !important;
                padding: 1rem !important;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1) !important;
                z-index: 100 !important;
            }
            
            /* Mobile table cells */
            td, th {
                padding: 6px 4px !important;
                font-size: 12px !important;
            }
            
            /* Mobile-friendly spacing */
            .p-6 {
                padding: 1rem !important;
            }
            
            .p-4 {
                padding: 0.75rem !important;
            }
            
            .mb-6 {
                margin-bottom: 1rem !important;
            }
            
            .gap-6 {
                gap: 1rem !important;
            }
            
            /* Removed old floating button styles */
        }
        
        @media (max-width: 480px) {
            /* Extra small devices */
            .header-buttons {
                grid-template-columns: 1fr !important;
            }
            
            .filter-btn {
                flex: 1 1 100% !important;
            }
            
            /* Stack stats vertically on very small screens */
            .stats-row {
                flex-direction: column !important;
            }
            
            /* Full-width modals on small screens */
            .modal-content {
                width: 100% !important;
                height: 100% !important;
                max-height: 100vh !important;
                margin: 0 !important;
                border-radius: 0 !important;
            }
        }
        
        /* Touch-friendly hover states */
        @media (hover: none) and (pointer: coarse) {
            .tooltip:hover .tooltiptext {
                visibility: hidden;
            }
            
            .bulk-edit-cell:hover .quick-actions {
                opacity: 1;
            }
            
            button:hover {
                transform: none;
            }
        }
        
        /* Hide mobile elements on desktop */
        .mobile-only {
            display: none;
        }
        
        .mobile-nav-toggle {
            display: none;
        }
        
        /* Chart container styles */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        
        /* Bulk edit mode styles */
        .bulk-edit-cell:hover .quick-actions {
            opacity: 1;
        }
        
        .quick-actions {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        
        /* Highlight selected rows */
        .selected-row {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border-left: 3px solid #3b82f6;
        }
        
        /* Improved input focus styles */
        .enhanced-input:focus {
            transform: scale(1.02);
            z-index: 10;
        }
        
        /* Paste feedback animation */
        @keyframes pasteFlash {
            0% { background-color: #dbeafe; }
            50% { background-color: #3b82f6; }
            100% { background-color: #dbeafe; }
        }
        
        .paste-flash {
            animation: pasteFlash 0.5s ease-in-out;
        }
        
        /* Loading states for templates */
        .template-loading {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Keyboard shortcuts help */
        .keyboard-hint {
            font-size: 0.7rem;
            color: #6b7280;
            margin-top: 2px;
        }
        
        /* Icon styles */
        .icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }
        
        /* Animated logo styles */
        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.5));
            }
            50% {
                transform: scale(1.05);
                filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.8));
            }
        }
        
        @keyframes rotate-slow {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        .logo-animated {
            animation: pulse-glow 3s ease-in-out infinite;
            display: inline-block;
        }
        
        .logo-rotate {
            animation: rotate-slow 20s linear infinite;
        }
        
        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        
        .title-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #667eea 75%, #764ba2 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 5s ease infinite;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 350px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -175px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Tab styles */
        .tab-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .tab-inactive {
            background-color: #E5E7EB;
            color: #374151;
        }
        
        .tab-inactive:hover {
            background-color: #D1D5DB;
        }
        
        /* Table styles */
        .analytics-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .analytics-table th {
            background-color: #F3F4F6;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #E5E7EB;
        }
        
        .analytics-table td {
            padding: 8px;
            border-bottom: 1px solid #E5E7EB;
        }
        
        .analytics-table tr:hover {
            background-color: #F9FAFB;
        }
        
        /* Filter button styles */
        .filter-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .filter-btn-active {
            background-color: #3B82F6;
            color: white;
        }
        
        .filter-btn-inactive {
            background-color: white;
            color: #374151;
            border: 1px solid #D1D5DB;
        }
        
        .filter-btn-inactive:hover {
            background-color: #F3F4F6;
        }
        
        /* Guidance section styles */
        .guidance-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #3B82F6;
        }
        
        .guidance-title {
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .guidance-content {
            color: #4B5563;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .example-box {
            background: #F3F4F6;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 13px;
        }
        
        .metric-guide {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }
        
        .metric-item {
            background: #F9FAFB;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #E5E7EB;
        }
        
        .metric-label {
            font-weight: 600;
            color: #374151;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .metric-value {
            color: #059669;
            font-weight: 500;
            font-size: 14px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Sponsor overlay styles */
        .sponsor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.95), rgba(147, 51, 234, 0.95));
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        @keyframes heartBeat {
            0% { transform: scale(1); }
            14% { transform: scale(1.3); }
            28% { transform: scale(1); }
            42% { transform: scale(1.3); }
            70% { transform: scale(1); }
        }
        
        @keyframes slideUp {
            from { 
                transform: translateY(30px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .sponsor-content {
            text-align: center;
            color: white;
            animation: slideUp 0.5s ease-out;
            max-width: 500px;
            padding: 2rem;
        }
        
        .heart-icon {
            animation: heartBeat 1.5s ease-in-out infinite;
            display: inline-block;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-200px) translateX(var(--float-x)) scale(0.3);
            }
        }
        
        .floating-heart {
            position: absolute;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sponsor-overlay.closing {
            animation: fadeOut 0.8s ease-out forwards;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 24px;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            cursor: pointer;
            background: #F3F4F6;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #E5E7EB;
        }
        
        /* Settings panel styles */
        .settings-section {
            background: #F9FAFB;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }
        
        .settings-item {
            display: flex;
            flex-direction: column;
        }
        
        .settings-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }
        
        .settings-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .settings-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Month selector styles */
        .month-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #F3F4F6;
            border-radius: 6px;
        }
        
        .month-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: white;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .month-remove {
            cursor: pointer;
            color: #EF4444;
            font-weight: bold;
        }
        
        .month-remove:hover {
            color: #DC2626;
        }
        
        /* Date range picker styles */
        .date-range-picker {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .date-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
        }
        
        .date-input {
            padding: 6px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Cost type toggle */
        .cost-type-toggle {
            display: inline-flex;
            background: #E5E7EB;
            border-radius: 6px;
            padding: 2px;
        }
        
        .cost-type-btn {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cost-type-btn-active {
            background: white;
            color: #1F2937;
            font-weight: 600;
        }
        
        .cost-type-btn-inactive {
            background: transparent;
            color: #6B7280;
        }
        
        .cost-type-btn-inactive:hover {
            color: #374151;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="spinner"></div>
        <p style="text-align: center; margin-top: 20px; color: white;">Loading AI ROI Calculator...</p>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // SINGLE SOURCE OF TRUTH FOR ALL CHANNELS
        const ALL_CHANNELS = [
            { id: 'phone', label: 'Phone', defaultCost: 6.00, defaultAHT: 10 },
            { id: 'chat', label: 'Chat', defaultCost: 2.50, defaultAHT: 8 },
            { id: 'email', label: 'Email', defaultCost: 4.00, defaultAHT: 12 },
            { id: 'sms', label: 'SMS', defaultCost: 1.50, defaultAHT: 3 },
            { id: 'social', label: 'Social', defaultCost: 3.00, defaultAHT: 5 },
            { id: 'bot', label: 'Bot', defaultCost: 0.50, defaultAHT: 2 }
        ];
        
        // Simple SVG icons as components
        const Icons = {
            Download: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                </svg>
            ),
            Upload: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
            ),
            Plus: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
            ),
            Trash: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            ),
            Settings: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            ),
            Chart: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
            ),
            Save: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V2" />
                </svg>
            ),
            Users: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            ),
            Clock: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Dollar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Calendar: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            ),
            Clear: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Help: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            FileText: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
            ),
            Info: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            ),
            Close: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            ),
            Copy: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
            ),
            RefreshCw: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            ),
            Edit: () => (
                <svg className="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
            )
        };

        // Input Guidance Data
        const InputGuidance = {
            "Deflection Rate (%)": {
                baseline: {
                    description: "Current % of contacts that are already being deflected by existing automation (if any)",
                    typical: "0-10%",
                    example: "If you already have a basic FAQ bot handling 5% of queries, enter 5"
                },
                volume: {
                    description: "Number of simple, repetitive contacts that AI could potentially handle",
                    calculation: "Total contacts × % that are simple/repetitive",
                    example: "10,000 monthly chats × 40% simple = 4,000 volume"
                },
                improvement: {
                    description: "Expected % of the volume that AI will successfully handle without agent",
                    typical: "60-80%",
                    example: "If AI can handle 70% of the 4,000 simple queries, enter 70",
                    formula: "Volume × (Deflection% - Baseline%) × Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Password Resets": "85-95%",
                    "Order Status": "75-85%",
                    "FAQs": "70-80%",
                    "Account Balance": "80-90%"
                }
            },
            "AHT Reduction (min)": {
                baseline: {
                    description: "Minutes already saved by current tools/processes (if any)",
                    typical: "0-1 min",
                    example: "If current tools save 0.5 minutes, enter 0.5"
                },
                volume: {
                    description: "Number of agent-handled contacts where AI co-pilot will assist",
                    calculation: "Total agent contacts that need assistance",
                    example: "5,000 complex calls requiring agent assistance"
                },
                improvement: {
                    description: "Minutes saved per contact through AI assistance",
                    typical: "1.5-3 min",
                    example: "AI helps save 2 minutes per call, enter 2",
                    formula: "Volume × (Minutes Saved - Baseline) × (Cost per Contact ÷ AHT) = $ Saved"
                },
                industryBenchmarks: {
                    "Knowledge Suggestions": "1-2 min",
                    "Auto-fill Forms": "2-3 min",
                    "Sentiment Analysis": "0.5-1 min",
                    "Next Best Action": "1.5-2.5 min"
                }
            },
            "Automation Rate (%)": {
                baseline: {
                    description: "Current % of processes that are already automated",
                    typical: "10-20%",
                    example: "If 15% of orders are processed automatically, enter 15"
                },
                volume: {
                    description: "Number of routine tasks that could be automated",
                    calculation: "Total routine/repetitive tasks",
                    example: "8,000 order status checks per month"
                },
                improvement: {
                    description: "Expected % that will be fully automated by AI",
                    typical: "50-70%",
                    example: "AI can automate 65% of routine tasks, enter 65",
                    formula: "Volume × (Automation% - Baseline%) × Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Order Processing": "60-75%",
                    "Returns/Refunds": "50-65%",
                    "Appointment Scheduling": "70-85%",
                    "Document Processing": "55-70%"
                }
            },
            "Self-Service Resolution (%)": {
                baseline: {
                    description: "Current % resolved through existing self-service",
                    typical: "10-25%",
                    example: "If current portal resolves 20%, enter 20"
                },
                volume: {
                    description: "Number of contacts attempting self-service",
                    calculation: "Contacts that try self-service first",
                    example: "3,000 customers trying to self-serve"
                },
                improvement: {
                    description: "Expected % that AI will help resolve without agent",
                    typical: "40-60%",
                    example: "AI improves resolution to 55%, enter 55",
                    formula: "Volume × (Resolution% - Baseline%) × Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Product Comparisons": "45-60%",
                    "Troubleshooting": "40-55%",
                    "Account Management": "50-65%",
                    "Policy Information": "60-75%"
                }
            },
            "Transfer Rate Reduction (%)": {
                baseline: {
                    description: "Current transfer rate between agents/departments",
                    typical: "25-35%",
                    example: "If 30% of calls are transferred, enter 30"
                },
                volume: {
                    description: "Number of contacts that currently get transferred",
                    calculation: "Total contacts × current transfer rate",
                    example: "10,000 calls × 30% transfer rate = 3,000"
                },
                improvement: {
                    description: "Expected reduction in transfer rate",
                    typical: "30-50%",
                    example: "Reduce transfers by 40%, enter 40",
                    formula: "Volume × (Reduction% - Baseline%) × Cost per Contact = $ Saved"
                },
                industryBenchmarks: {
                    "Smart Routing": "35-45%",
                    "Intent Detection": "40-50%",
                    "Skill-based Routing": "30-40%",
                    "Context Preservation": "45-55%"
                }
            },
            "NPS Improvement (points)": {
                baseline: {
                    description: "Current NPS score if you have one",
                    typical: "20-40 points",
                    example: "If current NPS is 30, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of customers surveyed for NPS (not total interactions)",
                    calculation: "Monthly NPS survey respondents × value per point",
                    example: "500 survey responses per month",
                    warning: "⚠️ Use survey count, not interaction volume"
                },
                improvement: {
                    description: "Expected NPS point increase from AI implementation",
                    typical: "5-15 points",
                    example: "If NPS improves from 30 to 40, enter 10",
                    formula: "Survey Count × Points Improved × $ Value per Point",
                    dollarConversion: "💡 How to calculate $ value per NPS point: (1) Take your average customer lifetime value (CLV), (2) Multiply by churn reduction per point (typically 0.5-2%), (3) Example: $5,000 CLV × 1% = $50/point. Industry avg: $50-200. Configure in Settings → Category Metric Values."
                },
                industryBenchmarks: {
                    "Faster Resolution": "8-12 points",
                    "First Contact Resolution": "10-15 points",
                    "Personalization": "5-10 points",
                    "Reduced Wait Times": "7-12 points"
                }
            },
            "CSAT Improvement (%)": {
                baseline: {
                    description: "Current customer satisfaction score",
                    typical: "70-80%",
                    example: "If current CSAT is 75%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of surveyed interactions (not all interactions)",
                    calculation: "Interactions where CSAT is measured",
                    example: "2,000 CSAT surveys per month",
                    warning: "⚠️ Only count interactions with CSAT surveys"
                },
                improvement: {
                    description: "Expected CSAT percentage point increase",
                    typical: "10-20%",
                    example: "If CSAT improves from 75% to 85%, enter 10",
                    formula: "Surveyed Volume × (% Improvement / 100) × $ Value per Point",
                    dollarConversion: "💡 How to calculate $ value per CSAT point: (1) Estimate revenue at risk from dissatisfied customers, (2) Divide by total survey responses, (3) Multiply by retention improvement rate (typically 0.3-1%), (4) Example: $100K at risk / 1000 surveys × 0.5% = $25/point. Configure in Settings → Category Metric Values."
                },
                industryBenchmarks: {
                    "Chatbot Assistance": "8-15%",
                    "Agent Augmentation": "12-18%",
                    "Proactive Support": "15-20%",
                    "Sentiment Analysis": "10-15%"
                }
            },
            "FCR Improvement (%)": {
                baseline: {
                    description: "Current first call resolution rate",
                    typical: "60-70%",
                    example: "If current FCR is 65%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Total contacts that could require follow-ups",
                    calculation: "All contacts needing resolution (not just failures)",
                    example: "6,000 support tickets per month",
                    note: "✅ FCR saves money by avoiding repeat contacts"
                },
                improvement: {
                    description: "Expected FCR percentage point increase",
                    typical: "15-25%",
                    example: "If FCR improves from 65% to 80%, enter 15",
                    formula: "Volume × (% Improvement / 100) × Cost per Contact (avoided repeats)"
                },
                industryBenchmarks: {
                    "Knowledge Base AI": "15-20%",
                    "Agent Assist": "20-25%",
                    "Predictive Analytics": "10-15%",
                    "Smart Routing": "12-18%"
                }
            },
            "Conversion Rate (%)": {
                baseline: {
                    description: "Current sales conversion rate",
                    typical: "2-5%",
                    example: "If current conversion is 3%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of sales opportunities",
                    calculation: "Leads or prospects engaged",
                    example: "2,000 qualified leads per month",
                    note: "💰 This represents potential sales opportunities, not all contacts"
                },
                improvement: {
                    description: "Expected conversion rate percentage point increase",
                    typical: "0.5-2%",
                    example: "If conversion improves from 3% to 4%, enter 1",
                    formula: "Opportunities × (New Rate% - Baseline%) × Average Deal Value = $ Revenue Generated",
                    dollarConversion: "💡 How to calculate Average Deal Value: (1) Sum total revenue from recent period (e.g., last quarter), (2) Divide by number of closed deals, (3) For subscription: use Customer Lifetime Value, (4) Industry avg: B2C $50-500, B2B $1,000-10,000. Configure in Settings → Category Metric Values."
                },
                industryBenchmarks: {
                    "Lead Scoring": "0.8-1.5%",
                    "Personalized Recommendations": "1-2%",
                    "Predictive Analytics": "0.5-1.2%",
                    "Chatbot Qualification": "0.6-1%"
                }
            },
            "Agent Retention (%)": {
                baseline: {
                    description: "Current agent turnover rate",
                    typical: "30-40% annually",
                    example: "Enter 0 as baseline since we measure improvement in retention"
                },
                volume: {
                    description: "Number of agents affected by AI tools",
                    calculation: "Total agents using AI assistance",
                    example: "100 contact center agents",
                    warning: "⚠️ Use agent count, not contact volume"
                },
                improvement: {
                    description: "Expected reduction in agent turnover",
                    typical: "10-20%",
                    example: "If turnover reduces from 35% to 25%, enter 10",
                    formula: "Agent Count × (Retention Improvement%) × Replacement Cost = $ Saved on Hiring/Training",
                    dollarConversion: "💡 How to calculate Agent Replacement Cost: (1) Recruiting costs (job boards, recruiter fees), (2) Training costs (trainer time × hourly rate × training hours), (3) Lost productivity (3-6 months ramp time × productivity gap), (4) Industry avg: $3,000-8,000 per agent. Configure in Settings → Category Metric Values."
                },
                industryBenchmarks: {
                    "AI Assistance Tools": "10-15%",
                    "Reduced Stress": "15-20%",
                    "Career Development": "8-12%",
                    "Job Satisfaction": "12-18%"
                }
            },
            "Compliance Rate (%)": {
                baseline: {
                    description: "Current compliance rate for regulations",
                    typical: "85-95%",
                    example: "If current compliance is 90%, enter 0 as baseline since we measure improvement"
                },
                volume: {
                    description: "Number of interactions requiring compliance",
                    calculation: "Regulated interactions or transactions",
                    example: "10,000 regulated interactions per month",
                    note: "⚖️ Count only interactions subject to compliance requirements"
                },
                improvement: {
                    description: "Expected compliance rate percentage point increase",
                    typical: "3-8%",
                    example: "If compliance improves from 90% to 95%, enter 5",
                    formula: "Regulated Volume × (Compliance Improvement%) × Cost per Violation = $ Fines/Penalties Avoided",
                    dollarConversion: "💡 How to calculate Cost per Violation: (1) Review regulatory fine schedules (TCPA: $500-1,500, GDPR: up to 4% revenue, HIPAA: $100-50,000), (2) Add legal fees and settlement costs, (3) Include reputation damage (lost customers × CLV), (4) Industry avg: $1,000-10,000 per violation. Configure in Settings → Category Metric Values."
                },
                industryBenchmarks: {
                    "Automated Monitoring": "5-8%",
                    "Real-time Alerts": "4-6%",
                    "Quality Assurance AI": "3-5%",
                    "Script Compliance": "6-8%"
                }
            }
        };

        const AIValueCalculator = () => {
            // Initialize with reasonable defaults
            const generateMonthsFromRange = (startDate, endDate) => {
                const months = [];
                
                // Handle invalid or empty dates
                if (!startDate || !endDate) {
                    return months;
                }
                
                // Parse the date strings (format: "YYYY-MM")
                const [startYear, startMonth] = startDate.split('-').map(Number);
                const [endYear, endMonth] = endDate.split('-').map(Number);
                
                // Create dates using local date constructor to avoid timezone issues
                // Set to first day of month at noon to avoid DST issues
                let current = new Date(startYear, startMonth - 1, 1, 12, 0, 0);
                let end = new Date(endYear, endMonth - 1, 1, 12, 0, 0);
                
                // Swap if dates are in wrong order
                if (current > end) {
                    [current, end] = [end, current];
                }
                
                while (current <= end) {
                    months.push({
                        id: `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`,
                        year: current.getFullYear(),
                        month: current.toLocaleString('default', { month: 'short' })
                    });
                    // Move to next month
                    current.setMonth(current.getMonth() + 1);
                }
                return months;
            };

            // Load saved data or use defaults
            const loadFromStorage = () => {
                try {
                    const savedData = localStorage.getItem('aiValueCalculatorData');
                    if (savedData) {
                        const parsed = JSON.parse(savedData);
                        // Ensure each category has metric values
                        const categoryCosts = parsed.categoryCosts || {};
                        const categories = parsed.categories || ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                        
                        // Initialize metric values for categories that don't have them
                        categories.forEach(category => {
                            if (!categoryCosts[category]) {
                                categoryCosts[category] = {};
                            }
                            if (!categoryCosts[category].metricValues) {
                                categoryCosts[category].metricValues = {
                                    npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                                    csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                                    fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                                    conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                                    agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                                    complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                                };
                            }
                        });
                        
                        return {
                            categories,
                            categoryCosts,
                            useCases: parsed.useCases || [],
                            dateRange: parsed.dateRange || {
                                start: new Date().toISOString().slice(0, 7),
                                end: new Date(new Date().setMonth(new Date().getMonth() + 11)).toISOString().slice(0, 7)
                            },
                            financialSettings: parsed.financialSettings || {
                                implementationCost: 0,
                                discountRate: 0.10,
                                costType: 'fixed',
                                costPercentage: 10,
                                includeOngoingCosts: false,
                                ongoingCostMonthly: 0
                            }
                        };
                    }
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
                
                const currentDate = new Date();
                const defaultStart = currentDate.toISOString().slice(0, 7);
                const defaultEnd = new Date(currentDate.setMonth(currentDate.getMonth() + 11)).toISOString().slice(0, 7);
                
                // Return sensible defaults with example data
                const defaultCategories = ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                const defaultCategoryCosts = {};
                
                // Initialize each category with metric values
                defaultCategories.forEach(category => {
                    defaultCategoryCosts[category] = {
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        }
                    };
                });
                
                return {
                    categories: defaultCategories,
                    categoryCosts: defaultCategoryCosts,
                    useCases: [
                        {
                            id: 'uc1',
                            category: 'Pre-Sales',
                            name: 'Answer Bot - General Q&A',
                            channel: 'chat',
                            metric: 'Deflection Rate (%)',
                            baselineValue: 0,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc2',
                            category: 'Pre-Sales',
                            name: 'Product Comparison Bot',
                            channel: 'chat',
                            metric: 'Self-Service Resolution (%)',
                            baselineValue: 10,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc3',
                            category: 'Pre-Sales',
                            name: 'Sales Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 1 Agents',
                            data: {}
                        },
                        {
                            id: 'uc4',
                            category: 'Order Support',
                            name: 'Order Status Automation',
                            channel: 'email',
                            metric: 'Automation Rate (%)',
                            baselineValue: 20,
                            specialGroup: null,
                            data: {}
                        },
                        {
                            id: 'uc5',
                            category: 'Order Support',
                            name: 'Returns Co-Pilot',
                            channel: 'phone',
                            metric: 'AHT Reduction (min)',
                            baselineValue: 0,
                            specialGroup: 'Tier 2 Agents',
                            data: {}
                        }
                    ],
                    dateRange: {
                        start: defaultStart,
                        end: defaultEnd
                    },
                    defaultAHT: 10,
                    metricValues: {
                        npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                        csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                        fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                        conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                        agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                        complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                    }
                };
            };

            const initialData = loadFromStorage();
            
            // State management
            // channelCosts is deprecated but kept as empty object for backward compatibility
            const channelCosts = {};
            const setChannelCosts = () => {}; // No-op setter
            const [categoryCosts, setCategoryCosts] = useState(initialData.categoryCosts);
            const [useCases, setUseCases] = useState(initialData.useCases);
            const [bulkEditMode, setBulkEditMode] = useState(false);
            const [selectedUseCases, setSelectedUseCases] = useState(new Set());
            const [fillMode, setFillMode] = useState('constant'); // 'constant' or 'gradual'
            const [curveType, setCurveType] = useState('linear'); // 'linear', 'exponential', 'scurve', 'logarithmic'
            const [undoStack, setUndoStack] = useState([]);
            const [redoStack, setRedoStack] = useState([]);
            const [unsavedChanges, setUnsavedChanges] = useState(new Set());
            const [dataTemplates, setDataTemplates] = useState(() => {
                const saved = localStorage.getItem('dataTemplates');
                return saved ? JSON.parse(saved) : {
                    'Basic Customer Service': {
                        useCases: [
                            {
                                id: Date.now(),
                                category: 'Customer Service',
                                name: 'General Inquiry Automation',
                                channel: 'chat',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 0}],
                                data: {}
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: '2024-01-01T00:00:00.000Z'
                    },
                    'Technical Support Suite': {
                        useCases: [
                            {
                                id: Date.now() + 1,
                                category: 'Technical Support',
                                name: 'Password Reset Automation',
                                channel: 'bot',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 0}],
                                data: {}
                            },
                            {
                                id: Date.now() + 2,
                                category: 'Technical Support',
                                name: 'Account Status Check',
                                channel: 'bot',
                                benefits: [{metric: 'AHT Reduction (min)', baselineValue: 5}],
                                data: {}
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: '2024-01-01T00:00:00.000Z'
                    },
                    'Comprehensive Test Suite': {
                        useCases: [
                            // Test Cost-based metrics with different channels
                            {
                                id: Date.now() + 100,
                                category: 'Customer Service',
                                name: 'Test: Deflection (Phone)',
                                channel: 'phone',
                                specialGroup: '',
                                benefits: [{metric: 'Deflection Rate (%)', baselineValue: 10}],
                                data: {
                                    'month-1': {
                                        'volume_Deflection Rate (%)': 1000,  // Contacts
                                        'improvement_Deflection Rate (%)': 50  // 50% deflection
                                    }
                                }
                            },
                            {
                                id: Date.now() + 101,
                                category: 'Technical Support',
                                name: 'Test: AHT Reduction (Chat)',
                                channel: 'chat',
                                specialGroup: 'Tier 1',
                                benefits: [{metric: 'AHT Reduction (min)', baselineValue: 2}],
                                data: {
                                    'month-1': {
                                        'volume_AHT Reduction (min)': 500,  // Contacts
                                        'improvement_AHT Reduction (min)': 5  // 5 minutes saved
                                    }
                                }
                            },
                            {
                                id: Date.now() + 102,
                                category: 'Order Support',
                                name: 'Test: FCR Improvement',
                                channel: 'email',
                                specialGroup: '',
                                benefits: [{metric: 'FCR Improvement (%)', baselineValue: 70}],
                                data: {
                                    'month-1': {
                                        'volume_FCR Improvement (%)': 800,  // Contacts
                                        'improvement_FCR Improvement (%)': 85  // 85% FCR
                                    }
                                }
                            },
                            // Test Value-based metrics with different volume types
                            {
                                id: Date.now() + 103,
                                category: 'Customer Service',
                                name: 'Test: NPS Improvement',
                                channel: 'phone',
                                specialGroup: '',
                                benefits: [{metric: 'NPS Improvement (points)', baselineValue: 0}],
                                data: {
                                    'month-1': {
                                        'volume_NPS Improvement (points)': 200,  // Surveys
                                        'improvement_NPS Improvement (points)': 5  // 5 point improvement
                                    }
                                }
                            },
                            {
                                id: Date.now() + 104,
                                category: 'Pre-Sales',
                                name: 'Test: Conversion Rate',
                                channel: 'chat',
                                specialGroup: '',
                                benefits: [{metric: 'Conversion Rate (%)', baselineValue: 5}],
                                data: {
                                    'month-1': {
                                        'volume_Conversion Rate (%)': 100,  // Opportunities
                                        'improvement_Conversion Rate (%)': 15  // 15% conversion
                                    }
                                }
                            },
                            {
                                id: Date.now() + 105,
                                category: 'Technical Support',
                                name: 'Test: Agent Retention',
                                channel: 'phone',
                                specialGroup: 'Offshore',
                                benefits: [{metric: 'Agent Retention (%)', baselineValue: 80}],
                                data: {
                                    'month-1': {
                                        'volume_Agent Retention (%)': 50,  // Agents
                                        'improvement_Agent Retention (%)': 90  // 90% retention
                                    }
                                }
                            },
                            // Test Multiple Benefits in one use case
                            {
                                id: Date.now() + 106,
                                category: 'Customer Service',
                                name: 'Test: Multi-Benefit Case',
                                channel: 'bot',
                                specialGroup: '',
                                benefits: [
                                    {metric: 'Deflection Rate (%)', baselineValue: 20},
                                    {metric: 'NPS Improvement (points)', baselineValue: 0},
                                    {metric: 'AHT Reduction (min)', baselineValue: 1}
                                ],
                                data: {
                                    'month-1': {
                                        'volume_0_Deflection Rate (%)': 2000,  // Contacts for deflection
                                        'improvement_0_Deflection Rate (%)': 60,  // 60% deflection
                                        'volume_1_NPS Improvement (points)': 150,  // Surveys for NPS
                                        'improvement_1_NPS Improvement (points)': 3,  // 3 point improvement
                                        'volume_2_AHT Reduction (min)': 1500,  // Contacts for AHT
                                        'improvement_2_AHT Reduction (min)': 4  // 4 minutes saved
                                    }
                                }
                            },
                            // Test edge cases
                            {
                                id: Date.now() + 107,
                                category: 'Order Support',
                                name: 'Test: Zero Baseline',
                                channel: 'sms',
                                specialGroup: '',
                                benefits: [{metric: 'Automation Rate (%)', baselineValue: 0}],
                                data: {
                                    'month-1': {
                                        'volume_Automation Rate (%)': 300,
                                        'improvement_Automation Rate (%)': 75
                                    }
                                }
                            },
                            {
                                id: Date.now() + 108,
                                category: 'Technical Support',
                                name: 'Test: High Baseline',
                                channel: 'social',
                                specialGroup: 'Tier 2',
                                benefits: [{metric: 'Self-Service Resolution (%)', baselineValue: 50}],
                                data: {
                                    'month-1': {
                                        'volume_Self-Service Resolution (%)': 400,
                                        'improvement_Self-Service Resolution (%)': 80  // Only 30% net improvement
                                    }
                                }
                            }
                        ],
                        categories: ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'],
                        metricValues: {
                            npsImprovement: { value: 100, label: 'Value per NPS Point ($)' },
                            csatImprovement: { value: 50, label: 'Value per CSAT Point ($)' },
                            fcrImprovement: { value: 20, label: 'Value per FCR % Improvement ($)' },
                            conversionRate: { value: 500, label: 'Average Deal Value ($)' },
                            agentRetention: { value: 10000, label: 'Agent Replacement Cost ($)' },
                            complianceRate: { value: 2000, label: 'Cost per Compliance Violation ($)' }
                        },
                        savedDate: new Date().toISOString()
                    }
                };
            });
            const [dateRange, setDateRange] = useState(initialData.dateRange);
            const [months, setMonths] = useState(generateMonthsFromRange(initialData.dateRange.start, initialData.dateRange.end));
            const [activeTab, setActiveTab] = useState('data');
            const [analyticsView, setAnalyticsView] = useState('overall');
            const [analyticsDateRange, setAnalyticsDateRange] = useState({ ...initialData.dateRange });
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [selectedChannel, setSelectedChannel] = useState('all');
            const [selectedSpecialGroup, setSelectedSpecialGroup] = useState(null);
            const [selectedMetric, setSelectedMetric] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [showAddUseCase, setShowAddUseCase] = useState(false);
            const [showTemplates, setShowTemplates] = useState(false); // Toggle for template library
            const [showGuidanceModal, setShowGuidanceModal] = useState(false);
            const [showSponsorOverlay, setShowSponsorOverlay] = useState(false);
            const [isClosingWithHearts, setIsClosingWithHearts] = useState(false);
            const [selectedMetricGuide, setSelectedMetricGuide] = useState(null);
            const [lastSaved, setLastSaved] = useState(new Date());
            const [showSaveIndicator, setShowSaveIndicator] = useState(false);
            const [ahtNegotiationMode, setAhtNegotiationMode] = useState(false); // Toggle for AHT negotiation calculations
            
            // Mobile detection
            const [isMobile, setIsMobile] = useState(false);
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            
            useEffect(() => {
                const checkMobile = () => {
                    // Check for actual mobile device, not just screen size
                    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const isSmallScreen = window.innerWidth <= 768;
                    // Consider it mobile if it's either a mobile device OR a small screen
                    setIsMobile(isMobileDevice || isSmallScreen);
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);
            // Global defaults removed - all configuration at category-channel level
            const defaultAHT = null; // Deprecated - use category-channel config
            const setDefaultAHT = () => {}; // No-op setter for backward compatibility
            const agentUtilization = null; // Deprecated - use category-channel config
            const setAgentUtilization = () => {}; // No-op setter for backward compatibility
            
            const [editingUseCase, setEditingUseCase] = useState(null);
            const [showEditModal, setShowEditModal] = useState(false)
            
            // Category management - ensure all categories from categoryCosts are included
            const deriveCategories = () => {
                const fromInitial = initialData.categories || ['Pre-Sales', 'Order Support', 'Technical Support', 'Customer Service'];
                const fromCosts = Object.keys(initialData.categoryCosts || {});
                const combined = new Set([...fromInitial, ...fromCosts]);
                return Array.from(combined);
            };
            const [categories, setCategories] = useState(deriveCategories());
            const [showCategoryManager, setShowCategoryManager] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [editingCategory, setEditingCategory] = useState(null);
            
            // Value configuration for non-cost metrics
            // Global metric values removed - all configuration at category level
            const metricValues = {}; // Deprecated - use category-specific metric values
            const setMetricValues = () => {}; // No-op setter for backward compatibility
            
            // Metric definitions for UI display
            const METRIC_DEFINITIONS = {
                npsImprovement: { label: 'Value per NPS Point ($)' },
                csatImprovement: { label: 'Value per CSAT Point ($)' },
                fcrImprovement: { label: 'Value per FCR % Improvement ($)' },
                conversionRate: { label: 'Average Deal Value ($)' },
                agentRetention: { label: 'Agent Replacement Cost ($)' },
                complianceRate: { label: 'Cost per Compliance Violation ($)' }
            };
            
            const fileInputRef = useRef(null);
            const chartRefs = {
                monthly: useRef(null),
                cumulative: useRef(null),
                category: useRef(null),
                channel: useRef(null),
                categoryTrend: useRef(null),
                categoryBreakdown: useRef(null),
                channelTrend: useRef(null),
                channelBreakdown: useRef(null),
                usecaseTrend: useRef(null),
                usecaseBreakdown: useRef(null),
                specialgroupTrend: useRef(null),
                specialgroupBreakdown: useRef(null),
                // Financial Analysis charts
                cashFlow: useRef(null),
                breakeven: useRef(null),
                financialTrend: useRef(null),
                categoryImplementation: useRef(null),
                categoryCostTimeline: useRef(null)
            };
            const chartInstances = useRef({});

            const [newUseCase, setNewUseCase] = useState({
                category: categories[0] || '',
                name: '',
                channel: 'phone',
                specialGroup: null,
                benefits: [
                    {
                        metric: 'Deflection Rate (%)',
                        baselineValue: 0
                    }
                ]
            });

            const [newSpecialGroup, setNewSpecialGroup] = useState({
                name: '',
                costType: 'hourly',
                value: 30.00,
                ahtMinutes: 10, // Default AHT if not specified
                utilization: 75 // Default utilization if not specified
            });

            // Initialize default category billing structure
            const getDefaultCategoryBilling = () => ({
                'Pre-Sales': {
                    implementationCost: 10000,
                    implementationMonth: 0,
                    ongoingCostMonthly: 500,
                    billingCycle: 'monthly'
                },
                'Order Support': {
                    implementationCost: 15000,
                    implementationMonth: 1,
                    ongoingCostMonthly: 750,
                    billingCycle: 'monthly'
                },
                'Technical Support': {
                    implementationCost: 25000,
                    implementationMonth: 2,
                    ongoingCostMonthly: 1000,
                    billingCycle: 'quarterly'
                },
                'Customer Service': {
                    implementationCost: 20000,
                    implementationMonth: 0,
                    ongoingCostMonthly: 800,
                    billingCycle: 'monthly'
                }
            });

            // Financial Analysis State
            const [financialSettings, setFinancialSettings] = useState(() => {
                const saved = initialData.financialSettings || {};
                return {
                    implementationCost: saved.implementationCost || 0,
                    discountRate: saved.discountRate || 0.10,
                    costType: saved.costType || 'fixed',
                    costPercentage: saved.costPercentage || 20,
                    includeOngoingCosts: saved.includeOngoingCosts || false,
                    ongoingCostMonthly: saved.ongoingCostMonthly || 0,
                    showMonthlyBreakdown: saved.showMonthlyBreakdown || false,
                    useCategoryBilling: saved.useCategoryBilling || false,
                    categoryBilling: saved.categoryBilling || getDefaultCategoryBilling()
                };
            });

            const [financialMetrics, setFinancialMetrics] = useState({
                npv: 0,
                irr: 0,
                paybackPeriod: null,
                cashFlows: [],
                breakEvenMonth: null,
                totalROI: 0
            });

            // Update months when date range changes and sync analytics date range
            useEffect(() => {
                setMonths(generateMonthsFromRange(dateRange.start, dateRange.end));
                // Also update analytics date range to match
                setAnalyticsDateRange({ ...dateRange });
            }, [dateRange]);

            // Category management functions
            const addCategory = (name) => {
                if (name && !categories.includes(name)) {
                    setCategories([...categories, name]);
                    // Initialize cost structure with default metric values for new category
                    setCategoryCosts({
                        ...categoryCosts,
                        [name]: {
                            metricValues: {
                                npsImprovement: { value: 50, label: 'Value per NPS Point ($)' },
                                csatImprovement: { value: 25, label: 'Value per CSAT Point ($)' },
                                fcrImprovement: { value: 15, label: 'Value per FCR % Improvement ($)' },
                                conversionRate: { value: 200, label: 'Average Deal Value ($)' },
                                agentRetention: { value: 5000, label: 'Agent Replacement Cost ($)' },
                                complianceRate: { value: 1000, label: 'Cost per Compliance Violation ($)' }
                            }
                        }
                    });
                }
            };
            
            const editCategory = (oldName, newName) => {
                if (newName && oldName !== newName) {
                    // Update categories list
                    setCategories(categories.map(cat => cat === oldName ? newName : cat));
                    
                    // Update category costs
                    const newCategoryCosts = { ...categoryCosts };
                    if (newCategoryCosts[oldName]) {
                        newCategoryCosts[newName] = newCategoryCosts[oldName];
                        delete newCategoryCosts[oldName];
                    }
                    setCategoryCosts(newCategoryCosts);
                    
                    // Update use cases with the old category
                    setUseCases(useCases.map(uc => ({
                        ...uc,
                        category: uc.category === oldName ? newName : uc.category
                    })));
                }
            };
            
            const removeCategory = (name) => {
                // Check if any use cases use this category
                const hasUseCases = useCases.some(uc => uc.category === name);
                if (hasUseCases) {
                    alert(`Cannot delete category "${name}" - it has active use cases. Please reassign or delete those use cases first.`);
                    return;
                }
                
                // Remove from categories
                setCategories(categories.filter(cat => cat !== name));
                
                // Remove from category costs
                const newCategoryCosts = { ...categoryCosts };
                delete newCategoryCosts[name];
                setCategoryCosts(newCategoryCosts);
            };
            
            // Auto-save functionality with deep comparison
            const prevDataRef = useRef();
            useEffect(() => {
                const dataToSave = {
                    categoryCosts,
                    categories,
                    useCases,
                    dateRange,
                    financialSettings,
                    ahtNegotiationMode
                };
                
                // Deep comparison to prevent unnecessary saves
                const dataString = JSON.stringify(dataToSave);
                if (prevDataRef.current === dataString) {
                    return; // No changes, skip save
                }
                
                const saveTimeout = setTimeout(() => {
                    try {
                        prevDataRef.current = dataString;
                        localStorage.setItem('aiValueCalculatorData', JSON.stringify({
                            ...dataToSave,
                            savedAt: new Date().toISOString()
                        }));
                        setLastSaved(new Date());
                        setShowSaveIndicator(true);
                        setTimeout(() => setShowSaveIndicator(false), 2000);
                    } catch (error) {
                        console.error('Save error:', error);
                    }
                }, 1000);

                return () => clearTimeout(saveTimeout);
            }, [categoryCosts, categories, useCases, dateRange, financialSettings, ahtNegotiationMode]);

            // Calculate cost based on category-channel hierarchy ONLY (no channel defaults)
            const getEffectiveCost = (useCase, channel) => {
                // Simplified Priority: Category-Channel-SpecialGroup > Category-Channel
                // NO channel defaults - must configure costs at category level
                if (!categoryCosts[useCase.category]) {
                    return 0; // No cost configured for this category
                }
                
                const categoryData = categoryCosts[useCase.category];
                
                // 1) Category-Channel Special Group (highest priority)
                if (
                    useCase.specialGroup &&
                    categoryData[channel] &&
                    categoryData[channel]._specialGroups &&
                    categoryData[channel]._specialGroups[useCase.specialGroup]
                ) {
                    const specialGroupCost = categoryData[channel]._specialGroups[useCase.specialGroup];
                    if (specialGroupCost.costType === 'perContact') {
                        return specialGroupCost.value || 0;
                    }
                    // Hourly → per-contact using AHT and utilization
                    let aht = specialGroupCost.ahtMinutes;
                    if (!aht || aht <= 0) {
                        const channelData = categoryData[channel];
                        if (channelData && channelData._default && channelData._default.ahtMinutes > 0) {
                            aht = channelData._default.ahtMinutes;
                        } else {
                            aht = 10; // Fallback if no AHT configured
                        }
                    }
                    const utilization = specialGroupCost.utilization || 75;
                    const utilizationFactor = utilization > 0 ? (100 / utilization) : 1;
                    return (specialGroupCost.value * aht / 60) * utilizationFactor;
                }
                
                // 2) Category-Channel default
                const channelNode = categoryData[channel];
                if (channelNode && typeof channelNode === 'object') {
                    // Check if this is a cost configuration object (has costType)
                    const costCfg = channelNode.costType ? channelNode : channelNode._default;
                    if (costCfg && costCfg.costType) {
                        if (costCfg.costType === 'perContact') {
                            return costCfg.value || 0;
                        }
                        const aht = (typeof costCfg.ahtMinutes === 'number' && costCfg.ahtMinutes > 0)
                            ? costCfg.ahtMinutes
                            : 10; // Fallback if no AHT configured
                        const utilization = costCfg.utilization || 75;
                        const utilizationFactor = utilization > 0 ? (100 / utilization) : 1;
                        return (costCfg.value * aht / 60) * utilizationFactor;
                    }
                }
                
                // No configuration found for this category-channel combination
                return 0;
            };
            
            // Get the actual cost configuration object for a use case
            const getCostConfiguration = (useCase) => {
                if (!categoryCosts[useCase.category]) return null;
                
                const categoryData = categoryCosts[useCase.category];
                const channel = useCase.channel;
                
                // Check for special group first
                if (useCase.specialGroup && 
                    categoryData[channel] && 
                    categoryData[channel]._specialGroups && 
                    categoryData[channel]._specialGroups[useCase.specialGroup]) {
                    return categoryData[channel]._specialGroups[useCase.specialGroup];
                }
                
                // Then check category-channel
                if (categoryData[channel]) {
                    return categoryData[channel].costType ? categoryData[channel] : categoryData[channel]._default;
                }
                
                return null;
            };
            
            // Get the cost source description for transparency
            const getCostSourceDescription = (useCase, channel) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // Check for special group within category-channel
                    if (useCase.specialGroup && categoryData[channel] && categoryData[channel]._specialGroups && categoryData[channel]._specialGroups[useCase.specialGroup]) {
                        return `Category-Channel-SpecialGroup: ${useCase.category} (${channel}) - ${useCase.specialGroup}`;
                    }
                    
                    // Check for channel-specific cost
                    if (categoryData[channel] && typeof categoryData[channel] === 'object') {
                        return `Category-Channel: ${useCase.category} (${channel})`;
                    }
                    
                    // Category default
                    if (categoryData._default || categoryData.costType) {
                        return `Category Default: ${useCase.category}`;
                    }
                }
                
                return `Not Configured: ${useCase.category} - ${channel}`;
            };

            // Helper to get channel configuration (using top-level ALL_CHANNELS)
            const getChannelConfig = (channelId) => {
                return ALL_CHANNELS.find(ch => ch.id === channelId) || { id: channelId, label: channelId, defaultCost: 0 };
            };
            
            // Helper to ensure all channels exist in channelCosts
            const ensureAllChannelsExist = () => {
                const missingChannels = {};
                ALL_CHANNELS.forEach(channel => {
                    if (!channelCosts.hasOwnProperty(channel.id)) {
                        missingChannels[channel.id] = channel.defaultCost;
                    }
                });
                
                if (Object.keys(missingChannels).length > 0) {
                    setChannelCosts(prev => ({ ...prev, ...missingChannels }));
                    return true; // Channels were added
                }
                return false; // No missing channels
            };
            
            // Get applicable AHT minutes for a use case (SpecialGroup > Category-Channel > Category Default > Global Default)
            const getApplicableAHT = (useCase) => {
                if (categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    
                    // 1. Special Group AHT (highest priority)
                    if (useCase.specialGroup && categoryData[useCase.channel] && categoryData[useCase.channel]._specialGroups && categoryData[useCase.channel]._specialGroups[useCase.specialGroup]) {
                        const specialGroupData = categoryData[useCase.channel]._specialGroups[useCase.specialGroup];
                        if (specialGroupData && typeof specialGroupData.ahtMinutes === 'number' && specialGroupData.ahtMinutes > 0) {
                            return specialGroupData.ahtMinutes;
                        }
                    }
                    
                    // 2. Category-Channel specific AHT
                    if (categoryData[useCase.channel] && typeof categoryData[useCase.channel] === 'object') {
                        const channelSpecific = categoryData[useCase.channel]._default || categoryData[useCase.channel];
                        if (channelSpecific && typeof channelSpecific.ahtMinutes === 'number' && channelSpecific.ahtMinutes > 0) {
                            return channelSpecific.ahtMinutes;
                        }
                    }
                    
                    // 3. Category default AHT
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && typeof defaultCost.ahtMinutes === 'number' && defaultCost.ahtMinutes > 0) {
                        return defaultCost.ahtMinutes;
                    }
                }
                
                // 4. Global default
                return 10; // Fallback if no AHT configured
            };
            
            // Helper function to get available special groups for a category-channel combination
            const getAvailableSpecialGroups = (category, channel) => {
                if (!categoryCosts[category] || !categoryCosts[category][channel] || !categoryCosts[category][channel]._specialGroups) {
                    return [];
                }
                return Object.keys(categoryCosts[category][channel]._specialGroups);
            };
            
            // Helper function to get all special groups across all category-channel combinations
            const getAllSpecialGroups = () => {
                const allGroups = new Set();
                Object.values(categoryCosts).forEach(categoryData => {
                    Object.values(categoryData).forEach(channelData => {
                        if (channelData && channelData._specialGroups) {
                            Object.keys(channelData._specialGroups).forEach(group => {
                                allGroups.add(group);
                            });
                        }
                    });
                });
                return Array.from(allGroups);
            };

            // Helper function to ensure use case has benefits array (backward compatibility)
            const ensureUseCaseHasBenefits = (useCase) => {
                if (!useCase.benefits && useCase.metric) {
                    // Convert old format to new format
                    return {
                        ...useCase,
                        benefits: [
                            {
                                metric: useCase.metric,
                                baselineValue: useCase.baselineValue || 0
                            }
                        ]
                    };
                }
                return useCase;
            };

            // Migrate monthly data keys when the benefit set (metric names/count) changes
            // Preserves entered volumes/improvements by renaming keys to match the new benefit schema
            const migrateUseCaseBenefitKeys = (oldUseCase, newUseCase) => {
                const oldUC = ensureUseCaseHasBenefits(oldUseCase);
                const newUC = ensureUseCaseHasBenefits(newUseCase);
                const migrated = { ...newUC, data: { ...(oldUseCase.data || {}) } };
                const monthsIds = Object.keys(oldUseCase.data || {});

                const renameKey = (obj, fromKey, toKey) => {
                    if (Object.prototype.hasOwnProperty.call(obj, fromKey)) {
                        obj[toKey] = obj[fromKey];
                        if (toKey !== fromKey) delete obj[fromKey];
                    }
                };

                monthsIds.forEach((monthId) => {
                    const md = { ...(migrated.data[monthId] || {}) };
                    const oldB = oldUC.benefits || [];
                    const newB = newUC.benefits || [];
                    const singleOld = oldB.length === 1;
                    const singleNew = newB.length === 1;

                    if (singleOld && singleNew) {
                        // volume_<oldMetric> -> volume_<newMetric>
                        renameKey(md, `volume_${oldB[0].metric}`, `volume_${newB[0].metric}`);
                        renameKey(md, `improvement_${oldB[0].metric}`, `improvement_${newB[0].metric}`);
                    } else if (!singleOld && !singleNew) {
                        const minLen = Math.min(oldB.length, newB.length);
                        for (let i = 0; i < minLen; i++) {
                            renameKey(md, `volume_${i}_${oldB[i].metric}`, `volume_${i}_${newB[i].metric}`);
                            renameKey(md, `improvement_${i}_${oldB[i].metric}`, `improvement_${i}_${newB[i].metric}`);
                        }
                        // Remove any keys for old benefits beyond the new length
                        for (let i = minLen; i < oldB.length; i++) {
                            delete md[`volume_${i}_${oldB[i].metric}`];
                            delete md[`improvement_${i}_${oldB[i].metric}`];
                        }
                    } else if (singleOld && !singleNew) {
                        // Map single keys to index 0 of the new list
                        if (newB[0]) {
                            renameKey(md, `volume_${oldB[0].metric}`, `volume_0_${newB[0].metric}`);
                            renameKey(md, `improvement_${oldB[0].metric}`, `improvement_0_${newB[0].metric}`);
                        }
                    } else if (!singleOld && singleNew) {
                        // Map index 0 to the single keys; drop the rest
                        if (oldB[0]) {
                            renameKey(md, `volume_0_${oldB[0].metric}`, `volume_${newB[0].metric}`);
                            renameKey(md, `improvement_0_${oldB[0].metric}`, `improvement_${newB[0].metric}`);
                        }
                        for (let i = 1; i < oldB.length; i++) {
                            delete md[`volume_${i}_${oldB[i].metric}`];
                            delete md[`improvement_${i}_${oldB[i].metric}`];
                        }
                    }

                    migrated.data[monthId] = md;
                });

                return migrated;
            };

            // Centralized metric configuration - single source of truth for all calculations
            // To add a new metric:
            // 1. Add entry to METRIC_CONFIG with unique key matching metric name
            // 2. Set type: 'percentage_cost', 'time_cost', 'points_value', 'percentage_value', or create new type
            // 3. Define formula (documentation) and excelFormula (function returning Excel formula string)
            // 4. For value-based metrics, add metricKey pointing to metricValues configuration
            // 5. Update calculateBenefitSavings switch statement if new type is created
            const METRIC_CONFIG = {
                'Deflection Rate (%)': {
                    type: 'percentage_cost',
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage of contacts deflected'
                },
                'AHT Reduction (min)': {
                    type: 'time_cost',
                    formula: 'volume * cappedMinutes * costPerMinute',
                    excelFormula: (row, params) => `=G${row}*MIN(J${row},${params.aht})*${params.rate}`,
                    requiresAHT: true,
                    description: 'Minutes saved per contact'
                },
                'Automation Rate (%)': {
                    type: 'percentage_cost',
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage of contacts automated'
                },
                'Self-Service Resolution (%)': {
                    type: 'percentage_cost',
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Percentage resolved via self-service'
                },
                'Transfer Rate Reduction (%)': {
                    type: 'percentage_cost',
                    formula: 'volume * (netImprovement / 100) * cost',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}`,
                    description: 'Reduction in transfer rate'
                },
                'NPS Improvement (points)': {
                    type: 'points_value',
                    metricKey: 'npsImprovement',
                    formula: 'volume * netImprovement * valuePerPoint',
                    excelFormula: (row, value) => `=G${row}*J${row}*${value}`,
                    description: 'NPS points improvement'
                },
                'CSAT Improvement (%)': {
                    type: 'percentage_value',
                    metricKey: 'csatImprovement',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'CSAT percentage improvement'
                },
                'FCR Improvement (%)': {
                    type: 'fcr_special',
                    formula: 'volume * (netImprovement / 100) * cost * repeatCallFactor',
                    excelFormula: (row) => `=G${row}*(J${row}/100)*K${row}*0.3`,
                    repeatCallFactor: 0.3,
                    description: 'First Call Resolution improvement'
                },
                'Conversion Rate (%)': {
                    type: 'percentage_value',
                    metricKey: 'conversionRate',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Conversion rate improvement'
                },
                'Agent Retention (%)': {
                    type: 'percentage_value',
                    metricKey: 'agentRetention',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Agent retention improvement'
                },
                'Compliance Rate (%)': {
                    type: 'percentage_value',
                    metricKey: 'complianceRate',
                    formula: 'volume * (netImprovement / 100) * value',
                    excelFormula: (row, value) => `=G${row}*(J${row}/100)*${value}`,
                    description: 'Compliance rate improvement'
                }
            };

            // Helper function to get all available metric types
            const getAvailableMetrics = () => {
                return Object.keys(METRIC_CONFIG);
            };
            
            // Helper function to validate metric configuration consistency
            const validateMetricConfig = () => {
                const errors = [];
                Object.entries(METRIC_CONFIG).forEach(([metric, config]) => {
                    if (!config.type) errors.push(`${metric}: missing type`);
                    if (!config.formula) errors.push(`${metric}: missing formula documentation`);
                    if (!config.excelFormula) errors.push(`${metric}: missing excelFormula function`);
                    if (config.type.includes('value') && !config.metricKey) {
                        errors.push(`${metric}: value-based metric missing metricKey`);
                    }
                });
                if (errors.length > 0) {
                    console.error('Metric configuration errors:', errors);
                }
                return errors.length === 0;
            };
            
            // Helper to get metric info for UI display
            const getMetricInfo = (metricName) => {
                const config = METRIC_CONFIG[metricName];
                if (!config) return { description: 'Unknown metric', unit: '%' };
                
                const unit = metricName.includes('(min)') ? 'minutes' : 
                            metricName.includes('(points)') ? 'points' : 
                            metricName.includes('(%)') ? '%' : '';
                
                return {
                    description: config.description || metricName,
                    unit: unit,
                    type: config.type,
                    requiresAHT: config.requiresAHT || false
                };
            };

            // Helper function to categorize metrics by type for analytics
            const getMetricTypeForMetric = (metric) => {
                if (metric.includes('NPS') || metric.includes('CSAT')) {
                    return 'Quality Improvement';
                } else if (metric.includes('FCR')) {
                    return 'Cost Savings'; // FCR prevents repeat calls, saving contact costs
                } else if (metric.includes('Conversion Rate')) {
                    return 'Revenue Generation';
                } else if (metric.includes('Agent Retention')) {
                    return 'Cost Avoidance';
                } else if (metric.includes('Compliance')) {
                    return 'Risk Reduction';
                } else {
                    return 'Cost Savings'; // Default for traditional cost metrics
                }
            };

            // Helper function to get all available metric types
            const getAvailableMetricTypes = () => {
                return ['Cost Savings', 'Quality Improvement', 'Revenue Generation', 'Cost Avoidance', 'Risk Reduction'];
            };
            
            // Helper functions for channel cost extraction to handle both number and object formats
            const getChannelCostValue = (channel) => {
                const cost = channelCosts[channel];
                if (!cost) return 0;
                return typeof cost === 'object' ? cost.value : cost;
            };

            const getChannelCostType = (channel) => {
                const cost = channelCosts[channel];
                if (!cost || typeof cost !== 'object') return 'perContact';
                return cost.costType || 'perContact';
            };

            const getChannelAHT = (channel) => {
                const cost = channelCosts[channel];
                if (!cost || typeof cost !== 'object') return 10;
                return cost.ahtMinutes || 10;
            };
            
            // Curve interpolation functions
            const interpolateValue = (startVal, endVal, progress, curve) => {
                const delta = endVal - startVal;
                
                switch (curve) {
                    case 'linear':
                        // Linear interpolation: steady growth
                        return startVal + delta * progress;
                        
                    case 'exponential':
                        // Exponential: slow start, rapid acceleration
                        const expProgress = (Math.exp(progress * 2) - 1) / (Math.exp(2) - 1);
                        return startVal + delta * expProgress;
                        
                    case 'scurve':
                        // S-curve (sigmoid): slow start, rapid middle, slow end
                        const sigmoid = 1 / (1 + Math.exp(-10 * (progress - 0.5)));
                        return startVal + delta * sigmoid;
                        
                    case 'logarithmic':
                        // Logarithmic: rapid start, slow later
                        const logProgress = Math.log(1 + progress * 9) / Math.log(10);
                        return startVal + delta * logProgress;
                        
                    case 'custom':
                        // Custom curve based on milestone percentages
                        const milestone3 = parseFloat(document.getElementById('custom-milestone-3')?.value || '25') / 100;
                        const milestone6 = parseFloat(document.getElementById('custom-milestone-6')?.value || '50') / 100;
                        const milestone9 = parseFloat(document.getElementById('custom-milestone-9')?.value || '75') / 100;
                        
                        // Map progress to custom milestones
                        if (progress <= 0.25) {
                            // 0-25% of time: interpolate to milestone3
                            return startVal + delta * (milestone3 * (progress / 0.25));
                        } else if (progress <= 0.5) {
                            // 25-50% of time: interpolate from milestone3 to milestone6
                            const localProgress = (progress - 0.25) / 0.25;
                            const milestoneValue = milestone3 + (milestone6 - milestone3) * localProgress;
                            return startVal + delta * milestoneValue;
                        } else if (progress <= 0.75) {
                            // 50-75% of time: interpolate from milestone6 to milestone9
                            const localProgress = (progress - 0.5) / 0.25;
                            const milestoneValue = milestone6 + (milestone9 - milestone6) * localProgress;
                            return startVal + delta * milestoneValue;
                        } else {
                            // 75-100% of time: interpolate from milestone9 to 1
                            const localProgress = (progress - 0.75) / 0.25;
                            const milestoneValue = milestone9 + (1 - milestone9) * localProgress;
                            return startVal + delta * milestoneValue;
                        }
                        
                    default:
                        return startVal + delta * progress;
                }
            };
            
            // Helper function to get the appropriate volume label for a metric
            const getVolumeLabel = (metric) => {
                if (metric.includes('Deflection') || metric.includes('Automation') || 
                    metric.includes('Self-Service') || metric.includes('AHT') || 
                    metric.includes('Transfer') || metric.includes('FCR')) {
                    return 'Contacts';
                } else if (metric.includes('NPS')) {
                    return 'Surveys';
                } else if (metric.includes('CSAT')) {
                    return 'CSAT Cases';
                } else if (metric.includes('Agent Retention')) {
                    return 'Agents';
                } else if (metric.includes('Conversion Rate')) {
                    return 'Opportunities';
                } else if (metric.includes('Compliance')) {
                    return 'Audits';
                } else {
                    return 'Volume';
                }
            };

            // Helper: return the volume used for a specific benefit in a given month
            const getBenefitVolumeValue = (useCaseOrNormalized, monthData, benefit, benefitIndex = 0) => {
                const normalizedUC = (useCaseOrNormalized && useCaseOrNormalized.benefits)
                    ? useCaseOrNormalized
                    : ensureUseCaseHasBenefits(useCaseOrNormalized);
                const key = (normalizedUC.benefits?.length === 1)
                    ? `volume_${benefit.metric}`
                    : `volume_${benefitIndex}_${benefit.metric}`;
                const v = parseFloat(monthData?.[key]);
                if (!isNaN(v)) return v;
                const generic = parseFloat(monthData?.volume);
                return isNaN(generic) ? 0 : generic;
            };

            // Helper: total volume for a use case in a given month (sums benefit-specific volumes; falls back to generic volume)
            const getTotalVolumeForUseCaseMonth = (useCaseOrNormalized, monthData) => {
                const normalizedUC = (useCaseOrNormalized && useCaseOrNormalized.benefits)
                    ? useCaseOrNormalized
                    : ensureUseCaseHasBenefits(useCaseOrNormalized);
                let found = false;
                let total = 0;
                (normalizedUC.benefits || []).forEach((benefit, i) => {
                    const key = (normalizedUC.benefits.length === 1)
                        ? `volume_${benefit.metric}`
                        : `volume_${i}_${benefit.metric}`;
                    if (monthData && monthData[key] !== undefined && monthData[key] !== null && monthData[key] !== '') {
                        total += parseFloat(monthData[key]) || 0;
                        found = true;
                    }
                });
                if (!found) total += parseFloat(monthData?.volume) || 0;
                return total;
            };
            
            // Helper function to get effective metric value (with hierarchy: Special Group > Category > Global)
            const getEffectiveMetricValue = (metricKey, useCase) => {
                // First check if special group has an override
                if (useCase.specialGroup && categoryCosts[useCase.category]) {
                    const categoryData = categoryCosts[useCase.category];
                    const channelData = categoryData[useCase.channel];
                    if (channelData && channelData._specialGroups && channelData._specialGroups[useCase.specialGroup]) {
                        const specialGroupData = channelData._specialGroups[useCase.specialGroup];
                        if (specialGroupData.metricValues && specialGroupData.metricValues[metricKey]) {
                            return specialGroupData.metricValues[metricKey].value;
                        }
                    }
                }
                
                // Then check if category has an override
                if (categoryCosts[useCase.category] && categoryCosts[useCase.category].metricValues && 
                    categoryCosts[useCase.category].metricValues[metricKey]) {
                    return categoryCosts[useCase.category].metricValues[metricKey].value;
                }
                
                // No global default - must be configured at category level
                return 0;
            };
            
            // Migration function to convert old category structure to new category-channel structure
            const migrateCategoryCosts = () => {
                const newCategoryCosts = {};
                let migrationApplied = false;
                
                Object.entries(categoryCosts).forEach(([category, data]) => {
                    // Check if it's already in new format (has channel keys or _default)
                    if (data._default || Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))) {
                        // Already in new format, keep as is
                        newCategoryCosts[category] = data;
                    } else {
                        // Old format, migrate to new format
                        newCategoryCosts[category] = {
                            _default: {
                                costType: data.costType,
                                value: data.value,
                                ahtMinutes: data.ahtMinutes
                            }
                        };
                        migrationApplied = true;
                    }
                });
                
                if (migrationApplied) {
                    setCategoryCosts(newCategoryCosts);
                    alert(`Migration completed! ${Object.keys(categoryCosts).length} categories converted to new category-channel structure. You can now set different costs per channel for each category.`);
                } else {
                    alert('No migration needed - your data is already in the new category-channel format.');
                }
            };
            
            // Check if migration is needed
            const needsMigration = () => {
                return Object.values(categoryCosts).some(data => 
                    data.costType && !data._default && !Object.keys(data).some(key => !['costType', 'value', 'ahtMinutes'].includes(key))
                );
            };
            
            // Helper function to get all available channels (from single source of truth)
            const getUniqueChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };
            
            // Helper function to add a new channel-specific cost for a category
            const addChannelCostToCategory = (category, channel, costData) => {
                setCategoryCosts(prev => ({
                    ...prev,
                    [category]: {
                        ...prev[category],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a category
            const removeChannelCostFromCategory = (category, channel) => {
                setCategoryCosts(prev => {
                    const newCategoryData = { ...prev[category] };
                    delete newCategoryData[channel];
                    return {
                        ...prev,
                        [category]: newCategoryData
                    };
                });
            };
            
            // Helper function to add a new channel-specific cost for a special group
            const addChannelCostToSpecialGroup = (group, channel, costData) => {
                setSpecialGroups(prev => ({
                    ...prev,
                    [group]: {
                        ...prev[group],
                        [channel]: costData
                    }
                }));
            };
            
            // Helper function to remove a channel-specific cost from a special group
            const removeChannelCostFromSpecialGroup = (group, channel) => {
                setSpecialGroups(prev => {
                    const newGroupData = { ...prev[group] };
                    delete newGroupData[channel];
                    return {
                        ...prev,
                        [group]: newGroupData
                    };
                });
            };
            

            // Calculate savings for a single benefit using centralized metric config
            const calculateBenefitSavings = (useCase, benefit, monthData, benefitIndex = 0) => {
                const normalizedUC = ensureUseCaseHasBenefits(useCase);
                
                // Get metric configuration
                const metricConfig = METRIC_CONFIG[benefit.metric];
                if (!metricConfig) {
                    console.warn(`No configuration found for metric: ${benefit.metric}`);
                    return 0;
                }
                
                // Get benefit-specific volume or fall back to general volume
                const volumeFieldKey = normalizedUC.benefits.length === 1 
                    ? `volume_${benefit.metric}`
                    : `volume_${benefitIndex}_${benefit.metric}`;
                const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                
                const fieldKey = normalizedUC.benefits.length === 1 
                    ? `improvement_${benefit.metric}`
                    : `improvement_${benefitIndex}_${benefit.metric}`;
                const improvement = parseFloat(monthData[fieldKey]) || 0;
                const baseline = parseFloat(benefit.baselineValue) || 0;
                
                // Calculate net improvement (improvement - baseline)
                let netImprovement = Math.max(0, improvement - baseline);
                
                // Calculate based on metric type from configuration
                switch (metricConfig.type) {
                    case 'time_cost': {
                        // AHT Reduction calculation
                        const costConfig = getCostConfiguration(useCase);
                        
                        // For per-contact costs, handle based on negotiation mode
                        if (costConfig && costConfig.costType === 'perContact') {
                            if (ahtNegotiationMode) {
                                // Calculate what the new per-contact cost SHOULD be
                                // This helps in contract negotiations
                                const originalAHT = Math.max(0.01, parseFloat(getApplicableAHT(useCase)) || 10);
                                const newAHT = Math.max(0.01, originalAHT - netImprovement);
                                const reductionRatio = newAHT / originalAHT;
                                const currentCost = getEffectiveCost(useCase, useCase.channel);
                                const suggestedNewCost = currentCost * reductionRatio;
                                const savingsPerContact = currentCost - suggestedNewCost;
                                return volume * savingsPerContact;
                            } else {
                                // Standard mode: no savings for per-contact billing
                                return 0;
                            }
                        }
                        
                        // For hourly costs, AHT reductions always save money
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const aht = Math.max(0.01, parseFloat(getApplicableAHT(useCase)) || 10);
                        const costPerMinute = effectiveCost / aht;
                        const cappedMinutes = Math.min(netImprovement, aht);
                        return volume * cappedMinutes * costPerMinute;
                    }
                    
                    case 'percentage_cost': {
                        // Deflection, Automation, Resolution, Transfer Rate calculations
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        return volume * (pct / 100) * effectiveCost;
                    }
                    
                    case 'fcr_special': {
                        // FCR with repeat call factor
                        const effectiveCost = getEffectiveCost(useCase, useCase.channel);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        const repeatCallFactor = metricConfig.repeatCallFactor || 0.3;
                        return volume * (pct / 100) * effectiveCost * repeatCallFactor;
                    }
                    
                    case 'points_value': {
                        // NPS points-based calculation
                        const value = getEffectiveMetricValue(metricConfig.metricKey, useCase);
                        return volume * netImprovement * value;
                    }
                    
                    case 'percentage_value': {
                        // CSAT, Conversion, Agent Retention, Compliance percentage-based calculations
                        const value = getEffectiveMetricValue(metricConfig.metricKey, useCase);
                        const pct = Math.max(0, Math.min(100, netImprovement));
                        return volume * (pct / 100) * value;
                    }
                    
                    default:
                        console.warn(`Unknown metric type: ${metricConfig.type} for metric: ${benefit.metric}`);
                        return 0;
                }
            };

            // Calculate total savings for a use case (sum of all benefits)
            const calculateSavings = (useCase, monthId) => {
                // Ensure backward compatibility
                const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                const monthData = normalizedUseCase.data[monthId] || {};
                
                let totalSavings = 0;
                
                // Sum savings from all benefits
                normalizedUseCase.benefits.forEach((benefit, benefitIndex) => {
                    totalSavings += calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                });
                
                return totalSavings;
            };
            
            // New function to get detailed savings breakdown by benefit
            const calculateSavingsBreakdown = (useCase, monthId) => {
                const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                const monthData = normalizedUseCase.data[monthId] || {};
                
                const breakdown = [];
                let totalSavings = 0;
                
                normalizedUseCase.benefits.forEach((benefit, benefitIndex) => {
                    const savings = calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                    totalSavings += savings;
                    breakdown.push({
                        metric: benefit.metric,
                        savings: savings,
                        percentage: 0 // Will calculate after total
                    });
                });
                
                // Calculate percentages
                breakdown.forEach(item => {
                    item.percentage = totalSavings > 0 ? (item.savings / totalSavings * 100) : 0;
                });
                
                return {
                    total: totalSavings,
                    breakdown: breakdown
                };
            };

            // Check if there are AHT reductions with per-contact billing
            const hasAHTWithPerContactBilling = () => {
                return useCases.some(uc => {
                    const costConfig = getCostConfiguration(uc);
                    if (costConfig && costConfig.costType === 'perContact') {
                        // Check if this use case has AHT reduction benefits
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        return normalizedUC.benefits.some(b => b.metric === 'AHT Reduction (min)');
                    }
                    return false;
                });
            };
            
            const calculateTotalSavings = () => {
                let total = 0;
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    filteredMonths.forEach(month => {
                        total += calculateSavings(uc, month.id);
                    });
                });
                return total;
            };

            // Financial Analysis Functions (NPV, IRR, Payback Period)
            const calculateNPV = (cashFlows, discountRate = 0.10) => {
                return cashFlows.reduce((npv, cf, index) => {
                    return npv + cf / Math.pow(1 + discountRate / 12, index); // Monthly discount rate
                }, 0);
            };

            const calculateIRR = (cashFlows, guess = 0.1) => {
                const maxIterations = 100;
                const tolerance = 1e-6;
                let rate = guess;
                
                // Newton-Raphson method
                for (let i = 0; i < maxIterations; i++) {
                    let npv = 0;
                    let dnpv = 0;
                    
                    for (let t = 0; t < cashFlows.length; t++) {
                        const pv = Math.pow(1 + rate, -t);
                        npv += cashFlows[t] * pv;
                        dnpv -= t * cashFlows[t] * pv / (1 + rate);
                    }
                    
                    if (Math.abs(npv) < tolerance) {
                        return rate * 12; // Convert to annual rate
                    }
                    
                    if (Math.abs(dnpv) < tolerance) {
                        // Fallback to bisection if derivative is too small
                        return calculateIRRBisection(cashFlows);
                    }
                    
                    const newRate = rate - npv / dnpv;
                    
                    // Bounds checking
                    if (newRate < -0.99) {
                        return calculateIRRBisection(cashFlows);
                    }
                    if (newRate > 10) {
                        return calculateIRRBisection(cashFlows);
                    }
                    
                    rate = newRate;
                }
                
                // If Newton-Raphson doesn't converge, use bisection
                return calculateIRRBisection(cashFlows);
            };

            const calculateIRRBisection = (cashFlows) => {
                let lower = -0.99;
                let upper = 10;
                const tolerance = 1e-6;
                const maxIterations = 100;
                
                for (let i = 0; i < maxIterations; i++) {
                    const mid = (lower + upper) / 2;
                    const npv = cashFlows.reduce((sum, cf, t) => {
                        return sum + cf / Math.pow(1 + mid, t);
                    }, 0);
                    
                    if (Math.abs(npv) < tolerance) {
                        return mid * 12; // Convert to annual rate
                    }
                    
                    if (npv > 0) {
                        lower = mid;
                    } else {
                        upper = mid;
                    }
                }
                
                return ((lower + upper) / 2) * 12; // Convert to annual rate
            };

            // Calculate payback period in months
            const calculatePaybackPeriod = (cashFlows) => {
                let cumulative = 0;
                for (let i = 0; i < cashFlows.length; i++) {
                    cumulative += cashFlows[i];
                    if (cumulative >= 0) {
                        if (i === 0) {
                            // If positive from the start, payback is immediate
                            if (cashFlows[0] >= 0) return 0.01; // Return small positive number instead of 0
                            // Otherwise calculate fraction of first month
                            return -cashFlows[0] / (cumulative);
                        }
                        // Linear interpolation for fractional months
                        const prevCumulative = cumulative - cashFlows[i];
                        const fraction = -prevCumulative / cashFlows[i];
                        return i - 1 + fraction;
                    }
                }
                return null; // No payback within the period
            };

            // Helper to get billing cycle months
            const getBillingCycleMonths = (billingCycle, customMonths) => {
                switch (billingCycle) {
                    case 'monthly': return 1;
                    case 'quarterly': return 3;
                    case 'semiannual': return 6;
                    case 'annual': return 12;
                    case 'custom': return customMonths || 6;
                    default: return 1;
                }
            };

            // Generate cash flow array from monthly savings
            const generateCashFlows = (implementationCost = 0, ongoingMonthlyCost = 0) => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                
                // Initialize cash flows array
                const cashFlows = [];
                
                // If using category-specific billing, track costs by category
                if (financialSettings.useCategoryBilling) {
                    // Track implementation costs by month for each category
                    const implementationByMonth = {};
                    const ongoingByMonth = {};
                    
                    // Only include costs for categories that have filtered use cases
                    const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                    
                    // Calculate category-specific costs
                    activeCategories.forEach(category => {
                        const catSettings = financialSettings.categoryBilling?.[category];
                        if (catSettings) {
                            const implMonth = catSettings.implementationMonth || 0;
                            if (!implementationByMonth[implMonth]) {
                                implementationByMonth[implMonth] = 0;
                            }
                            implementationByMonth[implMonth] += catSettings.implementationCost || 0;
                            
                            // Calculate ongoing costs based on billing cycle
                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                            const monthlyCost = catSettings.ongoingCostMonthly || 0;
                            
                            // Apply ongoing costs at appropriate intervals
                            for (let i = 0; i < filteredMonths.length; i++) {
                                if (i > implMonth && ((i - implMonth - 1) % cycleMonths === 0)) {
                                    if (!ongoingByMonth[i]) {
                                        ongoingByMonth[i] = 0;
                                    }
                                    // Charge for the entire cycle at once
                                    ongoingByMonth[i] += monthlyCost * cycleMonths;
                                }
                            }
                        }
                    });
                    
                    // Build cash flows with category-specific costs
                    // Align with Excel: each month includes its benefits and costs
                    filteredMonths.forEach((month, i) => {
                        let cashFlow = 0;
                        let monthlyBenefit = 0;
                        
                        // Add benefits for this month
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, month.id);
                        });
                        cashFlow = monthlyBenefit;
                        
                        // Subtract implementation costs for this month
                        if (implementationByMonth[i]) {
                            cashFlow -= implementationByMonth[i];
                        }
                        
                        // Subtract ongoing costs for this month
                        if (ongoingByMonth[i]) {
                            cashFlow -= ongoingByMonth[i];
                        }
                        
                        cashFlows.push(cashFlow);
                    });
                } else {
                    // Use simple overall implementation cost with billing cycle support
                    // Get billing cycle for non-category mode
                    const cycleMonths = getBillingCycleMonths(
                        financialSettings.billingCycle || 'monthly',
                        financialSettings.customMonths
                    );
                    
                    // Align with Excel: combine implementation cost with first month's benefits
                    filteredMonths.forEach((month, index) => {
                        let monthTotal = 0;
                        filteredUseCases.forEach(uc => {
                            monthTotal += calculateSavings(uc, month.id);
                        });
                        
                        // Add implementation cost to first month (index 0)
                        let implCost = 0;
                        if (index === 0) {
                            implCost = implementationCost;
                        }
                        
                        // Apply ongoing costs based on billing cycle (starting from month 1, not month 0)
                        let ongoingCost = 0;
                        if (ongoingMonthlyCost > 0 && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = ongoingMonthlyCost * cycleMonths;
                        }
                        
                        cashFlows.push(monthTotal - implCost - ongoingCost);
                    });
                }
                
                return cashFlows;
            };

            // Calculate totals by metric type for analytics
            const calculateTotalSavingsByMetricType = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                const metricTypes = getAvailableMetricTypes();
                const totals = {};
                
                // Initialize totals
                metricTypes.forEach(type => {
                    totals[type] = { total: 0, count: 0 };
                });
                
                filteredUseCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        const metricType = getMetricTypeForMetric(benefit.metric);
                        totals[metricType].count++;
                        
                        filteredMonths.forEach(month => {
                            const monthData = normalizedUC.data[month.id] || {};
                            totals[metricType].total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                        });
                    });
                });
                
                return totals;
            };

            // Get metric type breakdown for charts
            const getMetricTypeBreakdown = () => {
                const totals = calculateTotalSavingsByMetricType();
                
                return Object.entries(totals)
                    .filter(([type, data]) => data.total > 0)
                    .map(([type, data]) => ({
                        label: type,
                        value: Math.round(data.total),
                        count: data.count
                    }));
            };

            // Get filtered months for analytics
            const getFilteredMonths = () => {
                if (activeTab === 'analytics' && analyticsDateRange) {
                    return generateMonthsFromRange(analyticsDateRange.start, analyticsDateRange.end);
                }
                return months;
            };

            // Get filtered use cases based on current view
            const getFilteredUseCases = () => {
                let filtered = useCases;
                
                // Category filter
                if (selectedCategory !== 'all') {
                    filtered = filtered.filter(uc => uc.category === selectedCategory);
                }
                
                // Channel filter
                if (selectedChannel !== 'all') {
                    filtered = filtered.filter(uc => uc.channel === selectedChannel);
                }
                
                // Special Group filter
                if (selectedSpecialGroup !== null) {
                    if (selectedSpecialGroup === 'none') {
                        filtered = filtered.filter(uc => !uc.specialGroup);
                    } else {
                        filtered = filtered.filter(uc => uc.specialGroup === selectedSpecialGroup);
                    }
                }
                
                // Metric filter
                if (selectedMetric !== null) {
                    filtered = filtered.filter(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        return normalizedUC.benefits.some(benefit => benefit.metric === selectedMetric);
                    });
                }
                
                return filtered;
            };

            // Get unique categories
            const getCategories = () => {
                const categories = new Set(useCases.map(uc => uc.category));
                return Array.from(categories);
            };

            // Get unique channels for analytics (all channels always available)
            const getChannels = () => {
                return ALL_CHANNELS.map(ch => ch.id);
            };

            // Chart data preparation
            const getMonthlyTrendData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(monthTotal)
                    };
                });
            };

            // Enhanced monthly trend data with metric type breakdown
            const getEnhancedMonthlyTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const metricTypes = getAvailableMetricTypes();
                
                const datasets = [];
                
                // Add total line
                const totalData = filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    return Math.round(monthTotal);
                });
                
                datasets.push({
                    label: 'Total Value',
                    data: totalData,
                    borderColor: '#1F2937',
                    backgroundColor: 'rgba(31, 41, 55, 0.1)',
                    tension: 0.4,
                    borderWidth: 3,
                    fill: false
                });
                
                // Add lines for each metric type
                metricTypes.forEach(metricType => {
                    const data = filteredMonths.map(month => {
                        let total = 0;
                        filteredUseCases.forEach(uc => {
                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                            const monthData = normalizedUC.data[month.id] || {};
                            
                            normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                                if (getMetricTypeForMetric(benefit.metric) === metricType) {
                                    total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                }
                            });
                        });
                        return Math.round(total);
                    });
                    
                    // Only add if there's data for this metric type
                    if (data.some(value => value > 0)) {
                        const colors = {
                            'Cost Savings': '#3B82F6',
                            'Quality Improvement': '#10B981', 
                            'Revenue Generation': '#F59E0B',
                            'Cost Avoidance': '#EF4444',
                            'Risk Reduction': '#8B5CF6'
                        };
                        
                        datasets.push({
                            label: metricType,
                            data,
                            borderColor: colors[metricType] || '#6B7280',
                            backgroundColor: (colors[metricType] || '#6B7280') + '20',
                            tension: 0.4,
                            fill: false
                        });
                    }
                });
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets
                };
            };

            const getCumulativeData = () => {
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                let cumulative = 0;
                
                return filteredMonths.map(month => {
                    let monthTotal = 0;
                    filteredUseCases.forEach(uc => {
                        monthTotal += calculateSavings(uc, month.id);
                    });
                    cumulative += monthTotal;
                    return {
                        label: `${month.month} ${month.year}`,
                        value: Math.round(cumulative)
                    };
                });
            };

            const getCategoryBreakdown = () => {
                const categories = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!categories[uc.category]) {
                        categories[uc.category] = 0;
                    }
                    filteredMonths.forEach(month => {
                        categories[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(categories).map(([name, value]) => ({
                    label: name,
                    value: Math.round(value)
                }));
            };

            const getChannelBreakdown = () => {
                const channels = {};
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                filteredUseCases.forEach(uc => {
                    if (!channels[uc.channel]) {
                        channels[uc.channel] = 0;
                    }
                    filteredMonths.forEach(month => {
                        channels[uc.channel] += calculateSavings(uc, month.id);
                    });
                });
                return Object.entries(channels).map(([name, value]) => ({
                    label: name.charAt(0).toUpperCase() + name.slice(1),
                    value: Math.round(value)
                }));
            };

            // Get data for specific analytics views
            const getCategoryTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const categories = [...new Set(useCases.map(uc => uc.category))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: categories.map((cat, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.category === cat).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];
                        return {
                            label: cat,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getChannelTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const channels = [...new Set(useCases.map(uc => uc.channel))];
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: channels.map((ch, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => uc.channel === ch).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444'];
                        return {
                            label: ch.charAt(0).toUpperCase() + ch.slice(1),
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getUseCaseTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const topUseCases = filteredUseCases
                    .map(uc => ({
                        ...uc,
                        total: filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0)
                    }))
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 5); // Top 5 use cases
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: topUseCases.map((uc, index) => {
                        const data = filteredMonths.map(month => calculateSavings(uc, month.id));
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        // Include category and special group in label
                        const labelParts = [uc.name];
                        if (uc.category) labelParts.push(`(${uc.category})`);
                        if (uc.specialGroup) labelParts.push(`[${uc.specialGroup}]`);
                        return {
                            label: labelParts.join(' '),
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getSpecialGroupTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const groups = [...new Set(useCases.map(uc => uc.specialGroup).filter(Boolean))];
                groups.push('No Special Group');
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: groups.map((group, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            useCases.filter(uc => (uc.specialGroup || 'No Special Group') === group).forEach(uc => {
                                total += calculateSavings(uc, month.id);
                            });
                            return total;
                        });
                        const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                        return {
                            label: group,
                            data,
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '20',
                            tension: 0.4
                        };
                    })
                };
            };

            const getMetricTypeTrendData = () => {
                const filteredMonths = getFilteredMonths();
                const filteredUseCases = getFilteredUseCases();
                const metricTypes = getAvailableMetricTypes();
                
                return {
                    labels: filteredMonths.map(m => `${m.month} ${m.year}`),
                    datasets: metricTypes.map((metricType, index) => {
                        const data = filteredMonths.map(month => {
                            let total = 0;
                            filteredUseCases.forEach(uc => {
                                const normalizedUC = ensureUseCaseHasBenefits(uc);
                                const monthData = normalizedUC.data[month.id] || {};
                                
                                // Calculate savings only for benefits of this metric type
                                normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                                    if (getMetricTypeForMetric(benefit.metric) === metricType) {
                                        total += calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                                    }
                                });
                            });
                            return Math.round(total);
                        });
                        
                        const colors = {
                            'Cost Savings': '#3B82F6',
                            'Quality Improvement': '#10B981', 
                            'Revenue Generation': '#F59E0B',
                            'Cost Avoidance': '#EF4444',
                            'Risk Reduction': '#8B5CF6'
                        };
                        
                        return {
                            label: metricType,
                            data,
                            borderColor: colors[metricType] || '#6B7280',
                            backgroundColor: (colors[metricType] || '#6B7280') + '20',
                            tension: 0.4
                        };
                    }).filter(dataset => dataset.data.some(value => value > 0)) // Only include metric types with data
                };
            };

            // Initialize charts
            useEffect(() => {
                if (activeTab === 'analytics' && window.Chart) {
                    // Destroy existing charts
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                    chartInstances.current = {};

                    if (analyticsView === 'overall') {
                        // Monthly Trend Chart
                        if (chartRefs.monthly.current) {
                            const monthlyData = getMonthlyTrendData();
                            const ctx = chartRefs.monthly.current.getContext('2d');
                            chartInstances.current.monthly = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: monthlyData.map(d => d.label),
                                    datasets: [{
                                        label: 'Monthly Savings',
                                        data: monthlyData.map(d => d.value),
                                        borderColor: '#3B82F6',
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Cumulative Chart
                        if (chartRefs.cumulative.current) {
                            const cumulativeData = getCumulativeData();
                            const ctx = chartRefs.cumulative.current.getContext('2d');
                            chartInstances.current.cumulative = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: cumulativeData.map(d => d.label),
                                    datasets: [{
                                        label: 'Cumulative Savings',
                                        data: cumulativeData.map(d => d.value),
                                        borderColor: '#10B981',
                                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `Total: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Pie Chart
                        if (chartRefs.category.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.category.current.getContext('2d');
                                chartInstances.current.category = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: [
                                                '#3B82F6',
                                                '#10B981',
                                                '#F59E0B',
                                                '#EF4444',
                                                '#8B5CF6'
                                            ]
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Channel Bar Chart
                        if (chartRefs.channel.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channel.current.getContext('2d');
                                chartInstances.current.channel = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: '#8B5CF6'
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'category') {
                        // Category Trend Chart
                        if (chartRefs.categoryTrend.current) {
                            const trendData = getCategoryTrendData();
                            const ctx = chartRefs.categoryTrend.current.getContext('2d');
                            chartInstances.current.categoryTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Category Breakdown Chart
                        if (chartRefs.categoryBreakdown.current) {
                            const categoryData = getCategoryBreakdown();
                            if (categoryData.length > 0) {
                                const ctx = chartRefs.categoryBreakdown.current.getContext('2d');
                                chartInstances.current.categoryBreakdown = new Chart(ctx, {
                                    type: 'doughnut',
                                    data: {
                                        labels: categoryData.map(d => d.label),
                                        datasets: [{
                                            data: categoryData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'channel') {
                        // Channel Trend Chart
                        if (chartRefs.channelTrend.current) {
                            const trendData = getChannelTrendData();
                            const ctx = chartRefs.channelTrend.current.getContext('2d');
                            chartInstances.current.channelTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Channel Breakdown Chart
                        if (chartRefs.channelBreakdown.current) {
                            const channelData = getChannelBreakdown();
                            if (channelData.length > 0) {
                                const ctx = chartRefs.channelBreakdown.current.getContext('2d');
                                chartInstances.current.channelBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: channelData.map(d => d.label),
                                        datasets: [{
                                            label: 'Channel Savings',
                                            data: channelData.map(d => d.value),
                                            backgroundColor: ['#8B5CF6', '#06B6D4', '#84CC16', '#F97316', '#EF4444']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            y: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.y.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'usecase') {
                        // Use Case Trend Chart (Top 5)
                        if (chartRefs.usecaseTrend.current) {
                            const trendData = getUseCaseTrendData();
                            const ctx = chartRefs.usecaseTrend.current.getContext('2d');
                            chartInstances.current.usecaseTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Use Case Performance Bar Chart
                        if (chartRefs.usecaseBreakdown.current) {
                            const filteredMonths = getFilteredMonths();
                            const filteredUseCases = getFilteredUseCases();
                            const useCaseData = filteredUseCases.map(uc => {
                                const total = filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0);
                                // Include category/group in display name
                                let displayName = uc.name;
                                if (uc.specialGroup) displayName += ` [${uc.specialGroup}]`;
                                else if (uc.category) displayName += ` (${uc.category})`;
                                return { name: displayName, value: total, originalName: uc.name };
                            }).sort((a, b) => b.value - a.value).slice(0, 10);

                            if (useCaseData.length > 0) {
                                const ctx = chartRefs.usecaseBreakdown.current.getContext('2d');
                                chartInstances.current.usecaseBreakdown = new Chart(ctx, {
                                    type: 'bar',
                                    data: {
                                        labels: useCaseData.map(d => d.name),
                                        datasets: [{
                                            label: 'Use Case Savings',
                                            data: useCaseData.map(d => d.value),
                                            backgroundColor: '#3B82F6'
                                        }]
                                    },
                                    options: {
                                        indexAxis: 'y',
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                            x: {
                                                beginAtZero: true,
                                                ticks: {
                                                    callback: function(value) {
                                                        return '$' + value.toLocaleString();
                                                    }
                                                }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: false },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `Savings: $${context.parsed.x.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    } else if (analyticsView === 'specialgroup') {
                        // Special Group Trend Chart
                        if (chartRefs.specialgroupTrend.current) {
                            const trendData = getSpecialGroupTrendData();
                            const ctx = chartRefs.specialgroupTrend.current.getContext('2d');
                            chartInstances.current.specialgroupTrend = new Chart(ctx, {
                                type: 'line',
                                data: trendData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: { display: true, position: 'top' },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => `${context.dataset.label}: $${context.parsed.y.toLocaleString()}`
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Special Group Breakdown Chart
                        if (chartRefs.specialgroupBreakdown.current) {
                            const groupData = {};
                            const filteredMonths = getFilteredMonths();
                            getAllSpecialGroups().forEach(group => {
                                groupData[group] = 0;
                            });
                            groupData['No Special Group'] = 0;

                            useCases.forEach(uc => {
                                const key = uc.specialGroup || 'No Special Group';
                                // Initialize if key doesn't exist (for data consistency)
                                if (!(key in groupData)) {
                                    groupData[key] = 0;
                                }
                                filteredMonths.forEach(month => {
                                    groupData[key] += calculateSavings(uc, month.id);
                                });
                            });

                            const chartData = Object.entries(groupData)
                                .filter(([, value]) => value > 0)
                                .map(([name, value]) => ({ label: name, value }));

                            if (chartData.length > 0) {
                                const ctx = chartRefs.specialgroupBreakdown.current.getContext('2d');
                                chartInstances.current.specialgroupBreakdown = new Chart(ctx, {
                                    type: 'pie',
                                    data: {
                                        labels: chartData.map(d => d.label),
                                        datasets: [{
                                            data: chartData.map(d => d.value),
                                            backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
                                        }]
                                    },
                                    options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        plugins: {
                                            legend: { position: 'bottom' },
                                            tooltip: {
                                                callbacks: {
                                                    label: (context) => `${context.label}: $${context.parsed.toLocaleString()}`
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }

                return () => {
                    Object.values(chartInstances.current).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [activeTab, analyticsView, useCases, months, channelCosts, categoryCosts, selectedCategory, selectedChannel, selectedSpecialGroup, selectedMetric, analyticsDateRange]);
            
            // Calculate financial metrics when on financial tab
            useEffect(() => {
                if (activeTab === 'financial') {
                    // Calculate implementation cost
                    let implCost = financialSettings.implementationCost;
                    
                    if (financialSettings.costType === 'percentage') {
                        // Calculate first year benefits using filtered use cases
                        const filteredUseCases = getFilteredUseCases();
                        const firstYearMonths = months.slice(0, Math.min(12, months.length));
                        let firstYearBenefits = 0;
                        
                        firstYearMonths.forEach(month => {
                            filteredUseCases.forEach(uc => {
                                firstYearBenefits += calculateSavings(uc, month.id);
                            });
                        });
                        
                        implCost = firstYearBenefits * (financialSettings.costPercentage / 100);
                    }
                    
                    // Generate cash flows
                    const ongoingCost = financialSettings.includeOngoingCosts ? financialSettings.ongoingCostMonthly : 0;
                    const cashFlows = generateCashFlows(implCost, ongoingCost);
                    
                    // Calculate metrics
                    const npv = calculateNPV(cashFlows, financialSettings.discountRate);
                    const irr = cashFlows.length > 1 && cashFlows.some(cf => cf > 0) ? calculateIRR(cashFlows) : 0;
                    const paybackPeriod = calculatePaybackPeriod(cashFlows);
                    
                    
                    // Calculate total ROI using same logic as Excel export for consistency
                    // ROI = (Total Benefits - Total Costs) / Total Costs * 100
                    let totalBenefits = 0;
                    let totalImplementationCost = 0;
                    let totalOngoingCosts = 0;
                    
                    const filteredMonths = getFilteredMonths();
                    const filteredUseCases = getFilteredUseCases();
                    
                    // Calculate using the exact same logic as the Excel export
                    filteredMonths.forEach((month, index) => {
                        let monthlyBenefit = 0;
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, month.id);
                        });
                        totalBenefits += monthlyBenefit;
                        
                        if (financialSettings.useCategoryBilling) {
                            categories.forEach(category => {
                                const catSettings = financialSettings.categoryBilling?.[category];
                                if (catSettings) {
                                    if (index === catSettings.implementationMonth) {
                                        totalImplementationCost += catSettings.implementationCost || 0;
                                    }
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                    if (index > catSettings.implementationMonth && 
                                        ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                        totalOngoingCosts += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                }
                            });
                        } else {
                            if (index === 0) {
                                totalImplementationCost = implCost || 0;
                            }
                            const cycleMonths = getBillingCycleMonths(
                                financialSettings.billingCycle || 'monthly',
                                financialSettings.customMonths
                            );
                            if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                totalOngoingCosts += financialSettings.ongoingCostMonthly * cycleMonths;
                            }
                        }
                    });
                    
                    const totalCosts = totalImplementationCost + totalOngoingCosts;
                    const totalROI = totalCosts > 0 ? ((totalBenefits - totalCosts) / totalCosts) * 100 : 0;
                    
                    setFinancialMetrics({
                        npv,
                        irr,
                        paybackPeriod,
                        cashFlows,
                        breakEvenMonth: paybackPeriod !== null ? Math.max(1, Math.ceil(paybackPeriod)) : null,
                        totalROI
                    });
                }
            }, [activeTab, financialSettings, useCases, months, selectedCategory, selectedChannel, selectedSpecialGroup]);
            
            // Create Financial Analysis charts
            useEffect(() => {
                if (activeTab === 'financial' && window.Chart && financialMetrics.cashFlows.length > 0) {
                    // Destroy existing financial charts
                    ['cashFlow', 'breakeven', 'categoryImplementation', 'categoryCostTimeline'].forEach(chartName => {
                        if (chartInstances.current[chartName]) {
                            chartInstances.current[chartName].destroy();
                            delete chartInstances.current[chartName];
                        }
                    });
                    
                    const filteredMonths = getFilteredMonths();
                    // Use actual month names for all labels (no "Month 0")
                    const monthLabels = filteredMonths.map(m => `${m.month} ${m.year}`);
                    
                    // Cash Flow Chart
                    if (chartRefs.cashFlow.current) {
                        const ctx = chartRefs.cashFlow.current.getContext('2d');
                        chartInstances.current.cashFlow = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Monthly Cash Flow',
                                    data: financialMetrics.cashFlows,
                                    backgroundColor: financialMetrics.cashFlows.map(cf => cf < 0 ? '#EF4444' : '#10B981'),
                                    borderColor: financialMetrics.cashFlows.map(cf => cf < 0 ? '#DC2626' : '#059669'),
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            callback: function(value) {
                                                return '$' + value.toLocaleString();
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        callbacks: {
                                            label: (context) => {
                                                const value = context.parsed.y;
                                                if (context.dataIndex === 0) {
                                                    return `Implementation Cost: -$${Math.abs(value).toLocaleString()}`;
                                                }
                                                return `Cash Flow: $${value.toLocaleString()}`;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Break-even / Cumulative Cash Flow Chart
                    if (chartRefs.breakeven.current) {
                        const cumulativeCashFlow = [];
                        let cumulative = 0;
                        financialMetrics.cashFlows.forEach(cf => {
                            cumulative += cf;
                            cumulativeCashFlow.push(cumulative);
                        });
                        
                        const ctx = chartRefs.breakeven.current.getContext('2d');
                        chartInstances.current.breakeven = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Cumulative Cash Flow',
                                    data: cumulativeCashFlow,
                                    borderColor: '#3B82F6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.4,
                                    fill: true
                                }, {
                                    label: 'Break-even Line',
                                    data: Array(financialMetrics.cashFlows.length).fill(0),
                                    borderColor: '#6B7280',
                                    borderDash: [5, 5],
                                    borderWidth: 1,
                                    fill: false,
                                    pointRadius: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            callback: function(value) {
                                                return '$' + value.toLocaleString();
                                            }
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { 
                                        display: true,
                                        position: 'bottom'
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: (context) => {
                                                if (context.datasetIndex === 0) {
                                                    return `Cumulative: $${context.parsed.y.toLocaleString()}`;
                                                }
                                                return null;
                                            }
                                        }
                                    },
                                    annotation: financialMetrics.paybackPeriod ? {
                                        annotations: {
                                            breakeven: {
                                                type: 'line',
                                                xMin: financialMetrics.paybackPeriod,
                                                xMax: financialMetrics.paybackPeriod,
                                                borderColor: '#10B981',
                                                borderWidth: 2,
                                                label: {
                                                    enabled: true,
                                                    content: `Break-even: ${financialMetrics.paybackPeriod.toFixed(1)} months`,
                                                    position: 'start'
                                                }
                                            }
                                        }
                                    } : {}
                                }
                            }
                        });
                    }
                    
                    // Create category-specific charts when using category billing
                    if (financialSettings.useCategoryBilling) {
                        // Category Implementation Costs Chart
                        if (chartRefs.categoryImplementation.current) {
                            const ctx = chartRefs.categoryImplementation.current.getContext('2d');
                            
                            // Only include categories that have filtered use cases
                            const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                            
                            const categoryData = activeCategories.map(category => {
                                const catSettings = financialSettings.categoryBilling?.[category] || {};
                                return catSettings.implementationCost || 0;
                            });
                            
                            chartInstances.current.categoryImplementation = new Chart(ctx, {
                                type: 'doughnut',
                                data: {
                                    labels: activeCategories,
                                    datasets: [{
                                        data: categoryData,
                                        backgroundColor: [
                                            '#3B82F6', // Blue
                                            '#10B981', // Green
                                            '#F59E0B', // Yellow
                                            '#EF4444', // Red
                                            '#8B5CF6', // Purple
                                            '#EC4899'  // Pink
                                        ],
                                        borderWidth: 2,
                                        borderColor: '#fff'
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    plugins: {
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                padding: 15,
                                                font: { size: 11 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => {
                                                    const label = context.label || '';
                                                    const value = context.parsed || 0;
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                                    return `${label}: $${value.toLocaleString()} (${percentage}%)`;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Category Cost Timeline Chart
                        if (chartRefs.categoryCostTimeline.current) {
                            const ctx = chartRefs.categoryCostTimeline.current.getContext('2d');
                            
                            // Only include categories that have filtered use cases
                            const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                            
                            // Prepare datasets for each active category
                            const datasets = activeCategories.map((category, index) => {
                                const catSettings = financialSettings.categoryBilling?.[category] || {};
                                const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];
                                const color = colors[index % colors.length];
                                
                                // Create cost data for first 12 months
                                const costData = [];
                                for (let month = 0; month < 12; month++) {
                                    let cost = 0;
                                    // Implementation cost at specified month
                                    if (month === (catSettings.implementationMonth || 0)) {
                                        cost += catSettings.implementationCost || 0;
                                    }
                                    // Ongoing costs based on billing cycle
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                                    if (month > (catSettings.implementationMonth || 0) && 
                                        ((month - (catSettings.implementationMonth || 0) - 1) % cycleMonths === 0)) {
                                        cost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                    costData.push(cost);
                                }
                                
                                return {
                                    label: category,
                                    data: costData,
                                    backgroundColor: color + '33', // Add transparency
                                    borderColor: color,
                                    borderWidth: 2,
                                    fill: true
                                };
                            });
                            
                            chartInstances.current.categoryCostTimeline = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: ['Month 0', 'Month 1', 'Month 2', 'Month 3', 'Month 4', 'Month 5', 
                                            'Month 6', 'Month 7', 'Month 8', 'Month 9', 'Month 10', 'Month 11'],
                                    datasets: datasets
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        mode: 'index',
                                        intersect: false
                                    },
                                    scales: {
                                        x: {
                                            display: true,
                                            title: {
                                                display: true,
                                                text: 'Timeline'
                                            }
                                        },
                                        y: {
                                            display: true,
                                            title: {
                                                display: true,
                                                text: 'Cost ($)'
                                            },
                                            stacked: true,
                                            ticks: {
                                                callback: function(value) {
                                                    return '$' + value.toLocaleString();
                                                }
                                            }
                                        }
                                    },
                                    plugins: {
                                        legend: {
                                            position: 'bottom',
                                            labels: {
                                                padding: 10,
                                                font: { size: 11 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: (context) => {
                                                    const label = context.dataset.label || '';
                                                    const value = context.parsed.y || 0;
                                                    if (value > 0) {
                                                        return `${label}: $${value.toLocaleString()}`;
                                                    }
                                                    return null;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }, [activeTab, financialMetrics, getFilteredMonths, financialSettings, categories]);
            
            // No longer needed - removed channel defaults
            // useEffect(() => {
            //     if (ensureAllChannelsExist()) {
            //         console.log('Added missing channels to channelCosts configuration');
            //     }
            // }, []);

            // CRUD Operations
            const addUseCase = () => {
                if (newUseCase.name) {
                    setUseCases([...useCases, {
                        id: `uc${Date.now()}`,
                        ...newUseCase,
                        data: {}
                    }]);
                    setNewUseCase({
                        category: categories[0] || '',
                        name: '',
                        channel: 'phone',
                        specialGroup: null,
                        benefits: [
                            {
                                metric: 'Deflection Rate (%)',
                                baselineValue: 0
                            }
                        ]
                    });
                    setShowAddUseCase(false);
                }
            };

            const removeUseCase = (id) => {
                setUseCases(useCases.filter(uc => uc.id !== id));
            };

            const updateUseCaseData = (useCaseId, monthId, field, value) => {
                // Save current state to undo stack before making changes
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]); // Clear redo stack on new change
                setUnsavedChanges(prev => new Set([...prev, `${useCaseId}-${monthId}-${field}`]));
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        return {
                            ...uc,
                            data: {
                                ...uc.data,
                                [monthId]: {
                                    ...uc.data[monthId],
                                    [field]: value
                                }
                            }
                        };
                    }
                    return uc;
                }));
                
                // Auto-save after a delay
                setTimeout(() => {
                    setUnsavedChanges(prev => {
                        const newSet = new Set(prev);
                        newSet.delete(`${useCaseId}-${monthId}-${field}`);
                        return newSet;
                    });
                }, 1500);
            };
            
            // Helper to create deep copy of use cases for undo/redo
            const deepCopyUseCases = (cases) => {
                return JSON.parse(JSON.stringify(cases));
            };

            // Undo/Redo functions
            const undo = () => {
                if (undoStack.length > 0) {
                    setRedoStack(prev => [...prev, deepCopyUseCases(useCases)]);
                    const previousState = undoStack[undoStack.length - 1];
                    setUndoStack(prev => prev.slice(0, -1));
                    setUseCases(previousState);
                    setUnsavedChanges(new Set());
                }
            };
            
            const redo = () => {
                if (redoStack.length > 0) {
                    setUndoStack(prev => [...prev, deepCopyUseCases(useCases)]);
                    const nextState = redoStack[redoStack.length - 1];
                    setRedoStack(prev => prev.slice(0, -1));
                    setUseCases(nextState);
                    setUnsavedChanges(new Set());
                }
            };
            
            // Bulk operations functions
            const applyToAllMonths = (useCaseId, sourceMonthId) => {
                const useCase = useCases.find(uc => uc.id === useCaseId);
                const sourceData = useCase?.data[sourceMonthId];
                if (!sourceData) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            if (month.id !== sourceMonthId) {
                                newData[month.id] = { ...sourceData };
                            }
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
            };
            
            const copyPreviousMonth = (useCaseId, targetMonthId) => {
                const currentMonthIndex = months.findIndex(m => m.id === targetMonthId);
                if (currentMonthIndex <= 0) return;
                
                const previousMonth = months[currentMonthIndex - 1];
                const useCase = useCases.find(uc => uc.id === useCaseId);
                const previousData = useCase?.data[previousMonth.id];
                if (!previousData) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (uc.id === useCaseId) {
                        return {
                            ...uc,
                            data: {
                                ...uc.data,
                                [targetMonthId]: { ...previousData }
                            }
                        };
                    }
                    return uc;
                }));
            };
            
            const fillDown = (useCaseIds, field, value, clearSelection = true) => {
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (useCaseIds.includes(uc.id)) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            newData[month.id] = {
                                ...newData[month.id],
                                [field]: value
                            };
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
                if (clearSelection) {
                    setSelectedUseCases(new Set());
                }
            };
            
            const batchFillDown = (fillOperations) => {
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    const operations = fillOperations.filter(op => op.useCaseId === uc.id);
                    if (operations.length > 0) {
                        const newData = { ...uc.data };
                        months.forEach(month => {
                            operations.forEach(op => {
                                newData[month.id] = {
                                    ...newData[month.id],
                                    [op.field]: op.value
                                };
                            });
                        });
                        return { ...uc, data: newData };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const clearAllData = (useCaseIds = null) => {
                if (!confirm('Are you sure you want to clear all data? This cannot be undone.')) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const targetIds = useCaseIds || useCases.map(uc => uc.id);
                setUseCases(useCases.map(uc => {
                    if (targetIds.includes(uc.id)) {
                        return { ...uc, data: {} };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            // Batch operations for selected use cases
            const batchUpdateCategory = (newCategory) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, category: newCategory };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchUpdateChannel = (newChannel) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, channel: newChannel };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchUpdateSpecialGroup = (newSpecialGroup) => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.map(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        return { ...uc, specialGroup: newSpecialGroup || null };
                    }
                    return uc;
                }));
                setSelectedUseCases(new Set());
            };
            
            const batchDelete = () => {
                if (selectedUseCases.size === 0) return;
                if (!confirm(`Are you sure you want to delete ${selectedUseCases.size} selected use cases? This cannot be undone.`)) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                setUseCases(useCases.filter(uc => !selectedUseCases.has(uc.id)));
                setSelectedUseCases(new Set());
            };
            
            const batchDuplicate = () => {
                if (selectedUseCases.size === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const newUseCases = [];
                useCases.forEach(uc => {
                    if (selectedUseCases.has(uc.id)) {
                        newUseCases.push({
                            ...uc,
                            id: Date.now() + Math.random(),
                            name: `${uc.name} (Copy)`
                        });
                    }
                });
                
                setUseCases([...useCases, ...newUseCases]);
                setSelectedUseCases(new Set());
            };
            
            // Template functions
            const saveAsTemplate = (templateName) => {
                if (!templateName.trim()) return;
                
                const newTemplates = {
                    ...dataTemplates,
                    [templateName]: {
                        useCases: useCases.map(uc => {
                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                            // Only keep the normalized benefits format, remove old metric/baselineValue fields
                            const { metric, baselineValue, ...cleanUC } = normalizedUC;
                            return {
                                ...cleanUC,
                                id: Date.now() + Math.random(), // New IDs for template
                                data: {} // Clean data for template
                            };
                        }),
                        // Save the current categories configuration with the template
                        categories: [...categories],
                        // Save metric values configuration
                        metricValues: { ...metricValues },
                        savedDate: new Date().toISOString()
                    }
                };
                
                setDataTemplates(newTemplates);
                localStorage.setItem('dataTemplates', JSON.stringify(newTemplates));
            };
            
            const loadTemplate = (templateName) => {
                const template = dataTemplates[templateName];
                if (!template) return;
                
                // Check if template has categories saved
                const hasTemplateCategories = template.categories && Array.isArray(template.categories);
                const hasMetricValues = template.metricValues && typeof template.metricValues === 'object';
                
                let confirmMessage = `Load template "${templateName}"? This will replace all current use cases.`;
                
                if (hasTemplateCategories) {
                    confirmMessage += `\n\nThis template includes ${template.categories.length} categories. Your current categories will be replaced.`;
                }
                
                if (hasMetricValues) {
                    confirmMessage += `\n\nThis template includes configuration values (NPS value, Agent replacement cost, etc.) that will replace your current settings.`;
                }
                
                if (!confirm(confirmMessage)) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                // If template has categories, update them
                if (hasTemplateCategories) {
                    // Handle both array format (new) and string array format
                    const templateCategories = typeof template.categories[0] === 'string' 
                        ? template.categories 
                        : template.categories.map(c => c.name || c);
                    setCategories(templateCategories);
                }
                
                // If template has metric values, update them
                if (hasMetricValues) {
                    setMetricValues(template.metricValues);
                }
                
                // Load use cases and validate their categories
                const currentCategoryNames = hasTemplateCategories 
                    ? (typeof template.categories[0] === 'string' ? template.categories : template.categories.map(c => c.name || c))
                    : categories;
                
                setUseCases(template.useCases.map(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits({
                        ...uc,
                        id: Date.now() + Math.random() // Ensure unique IDs
                    });
                    
                    // Validate category exists, if not assign to first available category
                    if (!currentCategoryNames.includes(normalizedUC.category)) {
                        console.warn(`Category "${normalizedUC.category}" not found, assigning to "${currentCategoryNames[0]}"`);
                        normalizedUC.category = currentCategoryNames[0] || 'Pre-Sales';
                    }
                    
                    return normalizedUC;
                }));
            };
            
            const deleteTemplate = (templateName) => {
                if (!confirm(`Delete template "${templateName}"? This cannot be undone.`)) return;
                
                const newTemplates = { ...dataTemplates };
                delete newTemplates[templateName];
                setDataTemplates(newTemplates);
                localStorage.setItem('dataTemplates', JSON.stringify(newTemplates));
            };
            
            // Handle paste from spreadsheet
            const handlePaste = (e, startUseCaseIndex, startMonthIndex) => {
                e.preventDefault();
                const pastedData = e.clipboardData.getData('text');
                
                // Clean up the data - remove any trailing whitespace and split properly
                const rows = pastedData.trim().split(/\r?\n/).map(row => row.trim()).filter(row => row);
                
                if (rows.length === 0) return;
                
                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                setRedoStack([]);
                
                const updatedUseCases = deepCopyUseCases(useCases);
                const useCase = updatedUseCases[startUseCaseIndex];
                
                if (!useCase) return;
                
                const normalizedUC = ensureUseCaseHasBenefits(useCase);
                
                // Determine which field was focused by checking the active element
                const activeElement = document.activeElement;
                const fieldKey = activeElement?.getAttribute('data-field-key');
                const isVolumeField = fieldKey && fieldKey.startsWith('volume');
                const isImprovementField = fieldKey && fieldKey.startsWith('improvement');
                
                // Check if this is a single cell paste (no tabs or newlines)
                const isSingleCell = rows.length === 1 && !rows[0].includes('\t');
                
                if (isSingleCell) {
                    // Single value paste - put it in the focused field
                    const value = parseFloat(rows[0]) || 0;
                    const monthId = months[startMonthIndex].id;
                    
                    if (!updatedUseCases[startUseCaseIndex].data[monthId]) {
                        updatedUseCases[startUseCaseIndex].data[monthId] = {};
                    }
                    
                    // Use the field key from the active element
                    if (fieldKey) {
                        updatedUseCases[startUseCaseIndex].data[monthId][fieldKey] = value;
                    }
                } else {
                    // Multi-cell paste
                    const expectedFields = 1 + normalizedUC.benefits.length; // volume + benefits
                    const isPastingFields = rows.length === expectedFields;
                    
                    if (isPastingFields) {
                        // Pasting volume and benefits for a single use case across months
                        rows.forEach((row, rowIndex) => {
                            const cells = row.split('\t').map(cell => cell.trim());
                            
                            cells.forEach((cell, cellIndex) => {
                                const monthIndex = startMonthIndex + cellIndex;
                                
                                if (monthIndex < months.length && cell) {
                                    const monthId = months[monthIndex].id;
                                    const value = parseFloat(cell) || 0;
                                    
                                    if (!updatedUseCases[startUseCaseIndex].data[monthId]) {
                                        updatedUseCases[startUseCaseIndex].data[monthId] = {};
                                    }
                                    
                                    if (rowIndex === 0) {
                                        // First row is volume
                                        updatedUseCases[startUseCaseIndex].data[monthId].volume = value;
                                    } else {
                                        // Subsequent rows are benefits
                                        const benefitIndex = rowIndex - 1;
                                        if (benefitIndex < normalizedUC.benefits.length) {
                                            const benefit = normalizedUC.benefits[benefitIndex];
                                            const fieldKey = normalizedUC.benefits.length === 1 
                                                ? `improvement_${benefit.metric}`
                                                : `improvement_${benefitIndex}_${benefit.metric}`;
                                            updatedUseCases[startUseCaseIndex].data[monthId][fieldKey] = value;
                                        }
                                    }
                                }
                            });
                        });
                    } else {
                        // Original behavior: each row is a different use case
                        rows.forEach((row, rowIndex) => {
                            const cells = row.split('\t').map(cell => cell.trim());
                            const useCaseIndex = startUseCaseIndex + rowIndex;
                            
                            if (useCaseIndex < updatedUseCases.length) {
                                const currentUC = ensureUseCaseHasBenefits(updatedUseCases[useCaseIndex]);
                                
                                cells.forEach((cell, cellIndex) => {
                                    const monthIndex = startMonthIndex + cellIndex;
                                    
                                    if (monthIndex < months.length && cell) {
                                        const monthId = months[monthIndex].id;
                                        const value = parseFloat(cell) || 0;
                                        
                                        if (!updatedUseCases[useCaseIndex].data[monthId]) {
                                            updatedUseCases[useCaseIndex].data[monthId] = {};
                                        }
                                        
                                        // For single row, assume it's volume data
                                        updatedUseCases[useCaseIndex].data[monthId].volume = value;
                                    }
                                });
                            }
                        });
                    }
                }
                
                setUseCases(updatedUseCases);
            };
            
            // Validate metric configuration on mount
            React.useEffect(() => {
                validateMetricConfig();
            }, []);
            
            // Keyboard shortcuts
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'z':
                                e.preventDefault();
                                if (e.shiftKey) {
                                    redo();
                                } else {
                                    undo();
                                }
                                break;
                            case 'y':
                                e.preventDefault();
                                redo();
                                break;
                            case 'a':
                                if (activeTab === 'data' && bulkEditMode) {
                                    e.preventDefault();
                                    setSelectedUseCases(new Set(useCases.map(uc => uc.id)));
                                }
                                break;
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undoStack, redoStack, activeTab, bulkEditMode, useCases]);

            // Special group functions are now handled within the category-channel structure
            // Functions removed as they're no longer needed with nested structure

            // Helper function to download CSV/Excel files
            const downloadFile = (content, filename, type = 'text/csv') => {
                const blob = new Blob([content], { type });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                window.URL.revokeObjectURL(url);
            };
            
            // Generate Financial Analysis Excel with tab-separated values for proper formula support
            const generateFinancialAnalysisCSV = (filteredUseCases, metrics, settings) => {
                const TAB = '\t';
                let csv = 'FINANCIAL ANALYSIS REPORT WITH EXCEL FORMULAS\n\n';
                
                // Use filtered months consistently throughout
                const filteredMonths = getFilteredMonths();
                
                // Configuration Section
                csv += 'CONFIGURATION\n';
                csv += `Parameter${TAB}Value${TAB}Formula${TAB}Description\n`;
                
                if (settings.useCategoryBilling) {
                    csv += `Category Billing Mode${TAB}ENABLED${TAB}${TAB}Using category-specific implementation costs\n`;
                    csv += `Discount Rate${TAB}${(settings.discountRate).toFixed(4)}${TAB}${TAB}Annual discount rate for NPV (as decimal)\n`;
                    csv += `Monthly Discount Rate${TAB}${(settings.discountRate / 12).toFixed(6)}${TAB}${TAB}Monthly rate for NPV calculations\n`;
                    csv += `Analysis Months${TAB}${filteredMonths.length}${TAB}${TAB}Total months in analysis period\n\n`;
                    
                    // Category-specific configuration
                    csv += 'CATEGORY-SPECIFIC BILLING CONFIGURATION\n';
                    csv += `Category${TAB}Implementation Cost${TAB}Start Month${TAB}Ongoing Cost Monthly${TAB}Billing Cycle${TAB}Cycle Months\n`;
                    categories.forEach(category => {
                        const catSettings = settings.categoryBilling?.[category] || {};
                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                        csv += `${category}${TAB}${catSettings.implementationCost || 0}${TAB}${catSettings.implementationMonth || 0}${TAB}${catSettings.ongoingCostMonthly || 0}${TAB}${catSettings.billingCycle || 'monthly'}${TAB}${cycleMonths}\n`;
                    });
                    csv += '\n';
                } else {
                    csv += `Implementation Cost${TAB}${settings.implementationCost}${TAB}${TAB}One-time implementation cost\n`;
                    csv += `Discount Rate${TAB}${(settings.discountRate).toFixed(4)}${TAB}${TAB}Annual discount rate for NPV (as decimal)\n`;
                    csv += `Monthly Discount Rate${TAB}${(settings.discountRate / 12).toFixed(6)}${TAB}${TAB}Monthly rate for NPV calculations\n`;
                    csv += `Ongoing Cost Monthly${TAB}${settings.includeOngoingCosts ? settings.ongoingCostMonthly : 0}${TAB}${TAB}Monthly ongoing costs\n`;
                    csv += `Analysis Months${TAB}${filteredMonths.length}${TAB}${TAB}Total months in analysis period\n\n`;
                }
                
                // Monthly Cash Flow Table with Excel formulas
                csv += 'MONTHLY CASH FLOW ANALYSIS\n';
                csv += `Month${TAB}Period${TAB}Monthly Benefit${TAB}Implementation Cost${TAB}Ongoing Cost${TAB}Net Cash Flow${TAB}Cumulative Cash Flow${TAB}PV Factor${TAB}NPV Contribution\n`;
                
                // Calculate the actual starting row for cash flow data
                // Row 1: Title "FINANCIAL ANALYSIS REPORT WITH EXCEL FORMULAS"
                // Row 2: Empty
                // Row 3: "CONFIGURATION"
                // Row 4: Header row
                // Rows 5-8: Configuration data (4 rows for non-category, variable for category)
                // Additional rows for category billing configuration if enabled
                // Then empty row, then "MONTHLY CASH FLOW ANALYSIS", then headers
                // Count the actual rows output so far
                let row;
                if (settings.useCategoryBilling) {
                    // Actual row counting from the screenshot:
                    // Rows 1-11: Fixed headers and config (including CATEGORY-SPECIFIC header)
                    // Rows 12-15: 4 category data rows (one per category)
                    // Row 16: Empty line
                    // Row 17: "MONTHLY CASH FLOW ANALYSIS" text
                    // Row 18: Column headers (Month, Period, Monthly Benefit, etc.)
                    // Row 19: First actual data row
                    // So for 4 categories: row 19 = 15 + 4
                    row = 15 + categories.length;
                } else {
                    // Without category billing:
                    // Row 1: Title
                    // Row 2: Empty line
                    // Row 3: CONFIGURATION
                    // Row 4: Parameter headers
                    // Row 5: Implementation Cost row
                    // Row 6: Discount Rate row
                    // Row 7: Monthly Discount Rate row
                    // Row 8: Ongoing Cost Monthly row
                    // Row 9: Analysis Months row
                    // Row 10: Empty line
                    // Row 11: MONTHLY CASH FLOW ANALYSIS
                    // Row 12: Column headers
                    // Row 13: First data row
                    row = 13;
                }
                filteredMonths.forEach((month, index) => {
                    const currentRow = row + index; // Current row number
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    // Calculate actual implementation and ongoing costs for this month
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        // Calculate category-specific costs for this month
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                // Implementation cost at the specified month
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                // Ongoing costs based on billing cycle
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        // Simple implementation cost in first month
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        // Ongoing costs based on billing cycle (not every month)
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    csv += `${month.month} ${month.year}${TAB}${index}${TAB}`;
                    csv += `${monthlyBenefit.toFixed(2)}${TAB}`;
                    csv += `${-implCost}${TAB}`;
                    csv += `${-ongoingCost}${TAB}`;
                    
                    // Net Cash Flow formula
                    csv += `=C${currentRow}+D${currentRow}+E${currentRow}${TAB}`;
                    
                    // Cumulative Cash Flow formula
                    if (index === 0) {
                        csv += `=F${currentRow}${TAB}`;
                    } else {
                        csv += `=G${currentRow-1}+F${currentRow}${TAB}`;
                    }
                    
                    // PV Factor formula - using the actual discount rate value
                    const monthlyRate = settings.discountRate / 12;
                    csv += `=1/POWER(1+${monthlyRate.toFixed(6)},B${currentRow})${TAB}`;
                    
                    // NPV Contribution formula
                    csv += `=F${currentRow}*H${currentRow}\n`;
                });
                
                csv += '\n';
                const lastRow = row + filteredMonths.length - 1;
                
                // Summary Metrics with Excel formulas
                csv += 'FINANCIAL METRICS\n';
                csv += `Metric${TAB}Value${TAB}Formula${TAB}Description\n`;
                
                // Calculate the row where metrics start (after the cash flow data and headers)
                const metricsStartRow = lastRow + 4; // +1 for empty row, +1 for section header, +1 for column headers, +1 for first metric row
                
                csv += `Total Benefits${TAB}=SUM(C${row}:C${lastRow})${TAB}${TAB}Sum of all monthly benefits\n`;
                csv += `Total Investment${TAB}=-SUM(D${row}:D${lastRow})${TAB}${TAB}Total implementation costs\n`;
                csv += `Total Ongoing Costs${TAB}=-SUM(E${row}:E${lastRow})${TAB}${TAB}Sum of all ongoing costs\n`;
                csv += `Net Cash Flow${TAB}=SUM(F${row}:F${lastRow})${TAB}${TAB}Total net cash flow\n`;
                csv += `NPV${TAB}=SUM(I${row}:I${lastRow})${TAB}${TAB}Net Present Value\n`;
                
                // Calculate payback period value directly
                const paybackValue = metrics.paybackPeriod ? Math.ceil(metrics.paybackPeriod) : 'Not reached';
                csv += `Payback Period${TAB}${paybackValue}${TAB}${TAB}Months to break even\n`;
                
                // Calculate ROI using same calculation as elsewhere
                // Get the actual totals for Financial Metrics section
                let metricsTotalBenefits = 0;
                let metricsTotalImplementation = 0;
                let metricsTotalOngoing = 0;
                
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    metricsTotalBenefits += monthlyBenefit;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    metricsTotalImplementation += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    metricsTotalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            metricsTotalImplementation = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            metricsTotalOngoing += settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                });
                
                const metricsTotalCosts = metricsTotalImplementation + metricsTotalOngoing;
                const roiDecimal = metricsTotalCosts > 0 ? ((metricsTotalBenefits - metricsTotalCosts) / metricsTotalCosts) : 0;
                
                csv += `ROI (decimal)${TAB}${roiDecimal.toFixed(4)}${TAB}${TAB}Return on Investment (format as % in Excel)\n`;
                
                // Provide IRR values directly since Excel IRR can be tricky
                const monthlyIRR = metrics.irr ? (metrics.irr / 100 / 12).toFixed(4) : 'N/A';
                const annualIRR = metrics.irr ? (metrics.irr / 100).toFixed(4) : 'N/A';
                csv += `IRR Monthly${TAB}${monthlyIRR}${TAB}${TAB}Monthly Internal Rate of Return\n`;
                csv += `IRR Annual${TAB}${annualIRR}${TAB}${TAB}Annualized IRR\n\n`;
                
                // Category breakdown for category billing
                if (settings.useCategoryBilling) {
                    csv += 'CATEGORY COST BREAKDOWN\n';
                    csv += `Category${TAB}Total Implementation${TAB}First Year Ongoing${TAB}Total First Year Cost\n`;
                    categories.forEach(category => {
                        const catSettings = settings.categoryBilling?.[category] || {};
                        const implCost = catSettings.implementationCost || 0;
                        const monthlyOngoing = catSettings.ongoingCostMonthly || 0;
                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                        // Calculate first year ongoing costs based on billing cycle
                        const monthsAfterImpl = Math.max(0, 12 - (catSettings.implementationMonth || 0));
                        const cyclesInFirstYear = Math.floor(monthsAfterImpl / cycleMonths);
                        const firstYearOngoing = cyclesInFirstYear * monthlyOngoing * cycleMonths;
                        csv += `${category}${TAB}${implCost}${TAB}${firstYearOngoing}${TAB}${implCost + firstYearOngoing}\n`;
                    });
                    csv += '\n';
                }
                
                // Use Cases Detail
                csv += 'USE CASES INCLUDED\n';
                csv += `Category${TAB}Use Case${TAB}Channel${TAB}Special Group${TAB}Monthly Avg Benefit\n`;
                filteredUseCases.forEach(uc => {
                    const totalSavings = filteredMonths.reduce((sum, month) => sum + calculateSavings(uc, month.id), 0);
                    const avgMonthlySavings = totalSavings / filteredMonths.length;
                    csv += `${uc.category}${TAB}${uc.name}${TAB}${uc.channel}${TAB}${uc.specialGroup || 'None'}${TAB}${avgMonthlySavings.toFixed(2)}\n`;
                });
                
                csv += '\n';
                
                // Add Chart Data Section for visualization
                csv += '\n';
                csv += '--- CHART DATA FOR EXCEL VISUALIZATION ---\n';
                csv += 'Instructions: Select data ranges below and use Insert > Charts in Excel\n';
                csv += '\n';
                
                // 1. Cash Flow and Cumulative Chart Data
                csv += '1. CASH FLOW ANALYSIS (For Column/Line Combo Chart)\n';
                csv += `Month${TAB}Monthly Cash Flow${TAB}Cumulative Cash Flow${TAB}Break-Even Line\n`;
                let cumulative = 0;
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    const netCashFlow = monthlyBenefit - implCost - ongoingCost;
                    cumulative += netCashFlow;
                    
                    csv += `${month.month} ${month.year}${TAB}${netCashFlow.toFixed(2)}${TAB}${cumulative.toFixed(2)}${TAB}0\n`;
                });
                
                // Break-even point
                const breakEvenMonth = filteredMonths.findIndex((month, index) => {
                    let cum = 0;
                    for (let i = 0; i <= index; i++) {
                        let monthlyBenefit = 0;
                        filteredUseCases.forEach(uc => {
                            monthlyBenefit += calculateSavings(uc, filteredMonths[i].id);
                        });
                        
                        let implCost = 0;
                        let ongoingCost = 0;
                        
                        if (settings.useCategoryBilling) {
                            categories.forEach(category => {
                                const catSettings = settings.categoryBilling?.[category];
                                if (catSettings) {
                                    if (i === catSettings.implementationMonth) {
                                        implCost += catSettings.implementationCost || 0;
                                    }
                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                    if (i > catSettings.implementationMonth && 
                                        ((i - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                        ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                    }
                                }
                            });
                        } else {
                            if (i === 0) {
                                implCost = settings.implementationCost || 0;
                            }
                            const cycleMonths = getBillingCycleMonths(
                                settings.billingCycle || 'monthly',
                                settings.customMonths
                            );
                            if (settings.includeOngoingCosts && i > 0 && ((i - 1) % cycleMonths === 0)) {
                                ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                            }
                        }
                        
                        cum += monthlyBenefit - implCost - ongoingCost;
                    }
                    return cum >= 0;
                });
                
                csv += `\nBreak-even Point: ${breakEvenMonth >= 0 ? `Month ${breakEvenMonth + 1} (${filteredMonths[breakEvenMonth].month} ${filteredMonths[breakEvenMonth].year})` : 'Not reached'}\n`;
                csv += '\n';
                
                // 2. Benefits vs Costs Comparison Chart
                csv += '2. BENEFITS VS COSTS COMPARISON (For Stacked Column Chart)\n';
                csv += `Month${TAB}Benefits${TAB}Implementation Costs${TAB}Ongoing Costs\n`;
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    
                    let implCost = 0;
                    let ongoingCost = 0;
                    
                    if (settings.useCategoryBilling) {
                        categories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    implCost += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            implCost = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            ongoingCost = settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                    
                    csv += `${month.month} ${month.year}${TAB}${monthlyBenefit.toFixed(2)}${TAB}${implCost}${TAB}${ongoingCost}\n`;
                });
                csv += '\n';
                
                // 3. ROI Metrics Summary (For Pie/Donut Chart)
                // Calculate the same way as UI for consistency
                let totalBenefits = 0;
                let totalImplementation = 0;
                let totalOngoing = 0;
                
                filteredMonths.forEach((month, index) => {
                    let monthlyBenefit = 0;
                    filteredUseCases.forEach(uc => {
                        monthlyBenefit += calculateSavings(uc, month.id);
                    });
                    totalBenefits += monthlyBenefit;
                    
                    if (settings.useCategoryBilling) {
                        // Only include costs for categories that have filtered use cases
                        const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                        activeCategories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category];
                            if (catSettings) {
                                if (index === catSettings.implementationMonth) {
                                    totalImplementation += catSettings.implementationCost || 0;
                                }
                                const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                if (index > catSettings.implementationMonth && 
                                    ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                    totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                }
                            }
                        });
                    } else {
                        if (index === 0) {
                            totalImplementation = settings.implementationCost || 0;
                        }
                        const cycleMonths = getBillingCycleMonths(
                            settings.billingCycle || 'monthly',
                            settings.customMonths
                        );
                        if (settings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                            totalOngoing += settings.ongoingCostMonthly * cycleMonths;
                        }
                    }
                });
                
                const totalCosts = totalImplementation + totalOngoing;
                const netGain = totalBenefits - totalCosts;
                const roiPercent = totalCosts > 0 ? ((totalBenefits - totalCosts) / totalCosts * 100) : 0;
                
                csv += '3. ROI METRICS SUMMARY (For Pie Chart)\n';
                csv += `Metric${TAB}Value\n`;
                csv += `Total Benefits${TAB}${totalBenefits.toFixed(2)}\n`;
                csv += `Total Implementation${TAB}${totalImplementation.toFixed(2)}\n`;
                csv += `Total Ongoing Costs${TAB}${totalOngoing.toFixed(2)}\n`;
                csv += `Total Costs${TAB}${totalCosts.toFixed(2)}\n`;
                csv += `Net Gain${TAB}${netGain.toFixed(2)}\n`;
                // Export ROI as decimal so Excel can format it as percentage
                csv += `ROI %${TAB}${(roiPercent/100).toFixed(4)}\n`;
                csv += `NPV${TAB}${metrics.npv ? metrics.npv.toFixed(2) : 0}\n`;
                csv += '\n';
                
                // Category-specific chart data when using category billing
                if (settings.useCategoryBilling) {
                    csv += '4. CATEGORY IMPLEMENTATION TIMELINE (For Stacked Area Chart)\n';
                    csv += `Month${TAB}`;
                    // Only include categories that have filtered use cases
                    const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                    activeCategories.forEach(cat => {
                        csv += `${cat}${TAB}`;
                    });
                    csv += '\n';
                    
                    // First 12 months of category costs
                    for (let month = 0; month < 12; month++) {
                        csv += `Month ${month}${TAB}`;
                        activeCategories.forEach(category => {
                            const catSettings = settings.categoryBilling?.[category] || {};
                            let cost = 0;
                            
                            if (month === (catSettings.implementationMonth || 0)) {
                                cost += catSettings.implementationCost || 0;
                            }
                            
                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle || 'monthly', catSettings.customMonths);
                            if (month > (catSettings.implementationMonth || 0) && 
                                ((month - (catSettings.implementationMonth || 0) - 1) % cycleMonths === 0)) {
                                cost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                            }
                            
                            csv += `${cost}${TAB}`;
                        });
                        csv += '\n';
                    }
                    csv += '\n';
                }
                
                csv += '\n';
                csv += '--- HOW TO CREATE CHARTS IN EXCEL ---\n';
                csv += '\n';
                csv += '1. CASH FLOW CHART:\n';
                csv += '   - Select the "1. CASH FLOW ANALYSIS" data range\n';
                csv += '   - Go to Insert > Charts > Combo Chart\n';
                csv += '   - Set Monthly Cash Flow as Columns\n';
                csv += '   - Set Cumulative Cash Flow as Line with markers\n';
                csv += '   - Add Break-Even Line as a reference line\n\n';
                csv += '2. BENEFITS VS COSTS:\n';
                csv += '   - Select the "2. BENEFITS VS COSTS COMPARISON" data\n';
                csv += '   - Insert > Charts > Stacked Column Chart\n';
                csv += '   - This shows monthly benefits against costs\n\n';
                csv += '3. ROI SUMMARY:\n';
                csv += '   - Select the "3. ROI METRICS SUMMARY" data\n';
                csv += '   - Insert > Charts > Pie or Donut Chart\n';
                csv += '   - Shows proportion of benefits vs investment\n\n';
                if (settings.useCategoryBilling) {
                    csv += '4. CATEGORY TIMELINE:\n';
                    csv += '   - Select the "4. CATEGORY IMPLEMENTATION TIMELINE" data\n';
                    csv += '   - Insert > Charts > Stacked Area Chart\n';
                    csv += '   - Shows phased rollout by category\n\n';
                }
                csv += 'TIPS:\n';
                csv += '- Format currency columns (B, C, D, E, F, G, I) as Currency\n';
                csv += '- Format the ROI % cell as Percentage (it will show correctly as 239% for example)\n';
                csv += '- Use conditional formatting on Cumulative Cash Flow to highlight when positive\n';
                csv += '- Add data labels to charts for key values\n';
                csv += '- Use Excel\'s Chart Design tab to apply professional styles\n';
                
                return csv;
            };
            
            // Import/Export functionality
            const exportToCSV = () => {
                let csv = '=== AI ROI CALCULATOR FULL EXPORT (MULTI-BENEFIT) ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${dateRange.start} to ${dateRange.end}\n`;
                csv += `Total Months: ${months.length}\n`;
                csv += `Total Use Cases: ${useCases.length}\n`;
                // Global defaults removed - configuration at category-channel level
                
                // Add filter information if on analytics tab
                if (activeTab === 'analytics') {
                    csv += `\n=== CURRENT ANALYTICS FILTERS ===\n`;
                    csv += `View: ${analyticsView}\n`;
                    csv += `Analytics Period: ${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                    csv += `Category Filter: ${selectedCategory}\n`;
                    csv += `Channel Filter: ${selectedChannel}\n`;
                    csv += `Special Group Filter: ${selectedSpecialGroup || 'all'}\n`;
                    csv += `Metric Filter: ${selectedMetric || 'all'}\n`;
                    csv += `Filtered Results: ${getFilteredUseCases().length} of ${useCases.length} use cases\n`;
                }
                csv += '\n';
                
                // SECTION 1: MULTI-BENEFIT USE CASE DATA
                csv += '=== SECTION 1: DETAILED USE CASE MULTI-BENEFIT CALCULATIONS ===\n';
                csv += 'Category,Use Case Name,Channel,Special Group,Benefit Number,Metric Type,Baseline Value,Unit,Cost Source,Effective Cost (USD),Cost Type,AHT Used (min)';
                
                months.forEach(month => {
                    csv += `,${month.year}-${month.month}_Volume,${month.year}-${month.month}_Improvement_Input,${month.year}-${month.month}_Net_Improvement,${month.year}-${month.month}_Benefit_Value_USD`;
                });
                csv += ',Total_Benefit_Value_USD,Calculation_Formula,Value_Driver_Type\n';
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        // Determine effective cost and type for different metric types
                        let effectiveCost = '';
                        let costSource = '';
                        let costType = '';
                        let valueDriverType = '';
                        let unit = '';
                        let calculationFormula = '';
                        
                        // Determine metric type and calculation approach
                        if (benefit.metric.includes('Deflection') || benefit.metric.includes('Automation') || 
                            benefit.metric.includes('Self-Service') || benefit.metric.includes('Transfer')) {
                            effectiveCost = getEffectiveCost(uc, uc.channel);
                            costSource = getCostSourceDescription(uc, uc.channel);
                            valueDriverType = 'Cost Savings';
                            unit = '%';
                            calculationFormula = 'Volume × (Improvement% - Baseline%) × Cost_per_Contact';
                            
                            if (uc.specialGroup && categoryCosts[uc.category] && categoryCosts[uc.category][uc.channel] && categoryCosts[uc.category][uc.channel]._specialGroups && categoryCosts[uc.category][uc.channel]._specialGroups[uc.specialGroup]) {
                                costType = categoryCosts[uc.category][uc.channel]._specialGroups[uc.specialGroup].costType === 'hourly' ? 'Hourly' : 'Per Contact';
                            } else if (categoryCosts[uc.category]) {
                                const categoryData = categoryCosts[uc.category];
                                const channelSpecific = categoryData[uc.channel];
                                const defaultCost = categoryData._default || categoryData;
                                const activeCost = channelSpecific || defaultCost;
                                costType = activeCost && activeCost.costType === 'hourly' ? 'Hourly' : 'Per Contact';
                            }
                        } else if (benefit.metric.includes('AHT Reduction')) {
                            effectiveCost = getEffectiveCost(uc, uc.channel);
                            costSource = getCostSourceDescription(uc, uc.channel);
                            valueDriverType = 'Cost Savings';
                            unit = 'minutes';
                            calculationFormula = 'Volume × (Minutes_Saved - Baseline) × Cost_per_Minute';
                            costType = 'Time-based';
                        } else if (benefit.metric.includes('NPS Improvement')) {
                            effectiveCost = getEffectiveMetricValue('npsImprovement', uc);
                            const categoryOverride = categoryCosts[uc.category]?.metricValues?.npsImprovement;
                            costSource = categoryOverride ? `Category Override (${uc.category})` : 'Global Metric Value';
                            costType = 'Value per Point';
                            valueDriverType = 'Quality Improvement';
                            unit = 'points';
                            calculationFormula = 'Volume × NPS_Points_Improved × Value_per_NPS_Point';
                        } else if (benefit.metric.includes('CSAT Improvement')) {
                            effectiveCost = getEffectiveMetricValue('csatImprovement', uc);
                            const categoryOverride = categoryCosts[uc.category]?.metricValues?.csatImprovement;
                            costSource = categoryOverride ? `Category Override (${uc.category})` : 'Global Metric Value';
                            costType = 'Value per Point';
                            valueDriverType = 'Quality Improvement';
                            unit = '%';
                            calculationFormula = 'Volume × (CSAT_% - Baseline%) × Value_per_CSAT_Point';
                        } else if (benefit.metric.includes('FCR Improvement')) {
                            effectiveCost = getEffectiveCost(uc, uc.channel);
                            costSource = getCostSourceDescription(uc, uc.channel);
                            costType = 'Cost per Contact';
                            valueDriverType = 'Cost Savings';
                            unit = '%';
                            calculationFormula = 'Volume × (FCR_% - Baseline%) × Cost_per_Contact';
                        } else if (benefit.metric.includes('Conversion Rate')) {
                            effectiveCost = getEffectiveMetricValue('conversionRate', uc);
                            const categoryOverride = categoryCosts[uc.category]?.metricValues?.conversionRate;
                            costSource = categoryOverride ? `Category Override (${uc.category})` : 'Global Metric Value';
                            costType = 'Average Deal Value';
                            valueDriverType = 'Revenue Generation';
                            unit = '%';
                            calculationFormula = 'Volume × (Conversion_% - Baseline%) × Average_Deal_Value';
                        } else if (benefit.metric.includes('Agent Retention')) {
                            effectiveCost = getEffectiveMetricValue('agentRetention', uc);
                            const categoryOverride = categoryCosts[uc.category]?.metricValues?.agentRetention;
                            costSource = categoryOverride ? `Category Override (${uc.category})` : 'Global Metric Value';
                            costType = 'Replacement Cost';
                            valueDriverType = 'Cost Avoidance';
                            unit = '%';
                            calculationFormula = 'Volume × (Retention_% - Baseline%) × Agent_Replacement_Cost';
                        } else if (benefit.metric.includes('Compliance Rate')) {
                            effectiveCost = getEffectiveMetricValue('complianceRate', uc);
                            const categoryOverride = categoryCosts[uc.category]?.metricValues?.complianceRate;
                            costSource = categoryOverride ? `Category Override (${uc.category})` : 'Global Metric Value';
                            costType = 'Violation Cost';
                            valueDriverType = 'Risk Reduction';
                            unit = '%';
                            calculationFormula = 'Volume × (Compliance_% - Baseline%) × Cost_per_Violation';
                        }
                        
                        const ahtUsed = getApplicableAHT(uc);
                        csv += `${uc.category},"${uc.name}",${uc.channel},${uc.specialGroup || 'None'},${benefitIndex + 1},"${benefit.metric}",${benefit.baselineValue},${unit},"${costSource}",${effectiveCost},"${costType}",${ahtUsed}`;
                        
                        let totalBenefitValue = 0;
                        
                        months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            const fieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            const improvement = monthData[fieldKey] || 0;
                            const netImprovement = Math.max(0, improvement - benefit.baselineValue);
                            const benefitValue = calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                            totalBenefitValue += benefitValue;
                            const volForThisBenefit = getBenefitVolumeValue(normalizedUC, monthData, benefit, benefitIndex);
                            csv += `,${volForThisBenefit},${improvement},${netImprovement},${benefitValue.toFixed(2)}`;
                        });
                        csv += `,${totalBenefitValue.toFixed(2)},"${calculationFormula}","${valueDriverType}"\n`;
                    });
                });
                
                // SECTION 2: MULTI-BENEFIT INPUT PARAMETERS
                csv += '\n\n=== SECTION 2: ALL MULTI-BENEFIT INPUT PARAMETERS ===\n';
                csv += 'Use Case,Month,Benefit Number,Metric,Unit,Volume Type,Volume Count,Improvement Input,Baseline,Net Improvement Used\n';
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        let unit = '%';
                        if (benefit.metric.includes('AHT Reduction')) unit = 'minutes';
                        else if (benefit.metric.includes('NPS Improvement')) unit = 'points';
                        
                        months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            const volumeLabel = getVolumeLabel(benefit.metric);
                            const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0; // Fallback to general volume
                            const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                            const netImprovement = Math.max(0, improvement - benefit.baselineValue);
                            csv += `"${uc.name}",${month.month} ${month.year},${benefitIndex + 1},"${benefit.metric}",${unit},"${volumeLabel}",${volume},${improvement},${benefit.baselineValue},${netImprovement}\n`;
                        });
                    });
                });
                
                // SECTION 3: COMPLETE COST & VALUE CONFIGURATION
                csv += '\n\n=== SECTION 3: COMPLETE COST & VALUE CONFIGURATION ===\n';
                
                // Quality Metric Values
                csv += '\n--- QUALITY METRIC VALUES ---\n';
                csv += 'Metric Type,Dollar Value,Unit,Description\n';
                Object.entries(metricValues).forEach(([key, config]) => {
                    csv += `"${config.label}",${config.value},USD,Quality improvement monetary value\n`;
                });
                
                // Agent Configuration
                csv += '\n--- AGENT CONFIGURATION ---\n';
                csv += 'Parameter,Value,Unit\n';
                // Global defaults removed - configuration at category-channel level
                
                // Cost Hierarchy
                csv += '\n--- COST HIERARCHY ---\n';
                csv += 'Cost Tier,Type,Name,Cost Type,Value,AHT (min),Priority\n';
                
                // Channel costs (Priority 3)
                Object.entries(channelCosts).forEach(([channel, cost]) => {
                    csv += `Channel Default,Channel,${channel},Per Contact,${cost},10,Priority 3 (Lowest)\n`;
                });
                
                // Category costs (Priority 3)
                Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                    // Category default
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        const aht = typeof defaultCost.ahtMinutes === 'number' ? defaultCost.ahtMinutes : 10;
                        csv += `Category Default,Category,${category},${defaultCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${defaultCost.value},${aht},Priority 3\n`;
                    }
                    
                    // Category-Channel costs (Priority 2)
                    Object.entries(categoryData).forEach(([channel, channelData]) => {
                        if (channel !== '_default' && channelData && channelData._default) {
                            const channelCost = channelData._default;
                            const aht = typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : 10;
                            csv += `Category-Channel,Category-Channel,"${category} (${channel})",${channelCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${channelCost.value},${aht},Priority 2\n`;
                            
                            // Special groups within category-channel (Priority 1)
                            if (channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = typeof groupData.ahtMinutes === 'number' ? groupData.ahtMinutes : 10;
                                    csv += `Special Group,Category-Channel-SpecialGroup,"${category} (${channel}) - ${group}",${groupData.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${groupData.value},${aht},Priority 1 (Highest)\n`;
                                });
                            }
                        }
                    });
                });
                
                // SECTION 4: COMPREHENSIVE CALCULATION FORMULAS
                csv += '\n\n=== SECTION 4: COMPREHENSIVE CALCULATION FORMULAS ===\n';
                csv += 'Metric Category,Metric Type,Formula,Example,Value Driver Type\n';
                
                // Cost calculation notes
                csv += 'Cost Calculation,Cost per Contact (Hourly),"(Hourly Rate × AHT) / 60","$30/hr × 8min / 60 = $4.00",Cost Basis\n';
                csv += 'Cost Calculation,Cost per Minute (Hourly),"Hourly Rate / 60","$30/hr / 60 = $0.50/min",Cost Basis\n';
                csv += 'Cost Calculation,Cost per Contact (Fixed),"Fixed Cost per Contact","$2.50 per contact",Cost Basis\n';
                
                // Traditional cost-based metrics
                csv += 'Cost Savings,Deflection Rate (%),"Volume × (Improvement% - Baseline%) × Cost_per_Contact","1000 × (70% - 10%) × $2.50 = $1,500",Cost Savings\n';
                csv += 'Cost Savings,AHT Reduction (min),"Volume × (Minutes_Saved - Baseline) × Cost_per_Minute","500 × (3 - 0.5) × $0.50 = $625",Cost Savings\n';
                csv += 'Cost Savings,Automation Rate (%),"Volume × (Improvement% - Baseline%) × Cost_per_Contact","2000 × (60% - 20%) × $4 = $3,200",Cost Savings\n';
                csv += 'Cost Savings,Self-Service Resolution (%),"Volume × (Improvement% - Baseline%) × Cost_per_Contact","1500 × (50% - 15%) × $3 = $1,575",Cost Savings\n';
                csv += 'Cost Savings,Transfer Rate Reduction (%),"Volume × (Reduction% - Baseline%) × Cost_per_Contact","3000 × (40% - 30%) × $6 = $1,800",Cost Savings\n';
                
                // Quality-based metrics
                csv += `Quality Improvement,NPS Improvement (points),"Volume × NPS_Points_Improved × Value_per_NPS_Point","1000 × 2 points × $${metricValues.npsImprovement?.value || 50} = $${(1000 * 2 * (metricValues.npsImprovement?.value || 50)).toLocaleString()}",Quality Improvement\n`;
                csv += `Quality Improvement,CSAT Improvement (%),"Volume × (CSAT% - Baseline%) × Value_per_CSAT_Point","1000 × (85% - 75%) × $${metricValues.csatImprovement?.value || 25} = $${(1000 * 0.1 * (metricValues.csatImprovement?.value || 25)).toLocaleString()}",Quality Improvement\n`;
                csv += `Cost Savings,FCR Improvement (%),"Volume × (FCR% - Baseline%) × Cost_per_Contact","1000 × (90% - 80%) × $6 = $600",Cost Savings (Avoided Repeat Calls)\n`;
                
                // Revenue-based metrics
                csv += `Revenue Generation,Conversion Rate (%),"Volume × (Conversion% - Baseline%) × Average_Deal_Value","1000 × (15% - 10%) × $${metricValues.conversionRate?.value || 200} = $${(1000 * 0.05 * (metricValues.conversionRate?.value || 200)).toLocaleString()}",Revenue Generation\n`;
                
                // Cost avoidance metrics
                csv += `Cost Avoidance,Agent Retention (%),"Agents × (Retention% - Baseline%) × Replacement_Cost","100 agents × (95% - 85%) × $${metricValues.agentRetention?.value || 5000} = $${(100 * 0.1 * (metricValues.agentRetention?.value || 5000)).toLocaleString()}",Cost Avoidance\n`;
                csv += `Risk Reduction,Compliance Rate (%),"Volume × (Compliance% - Baseline%) × Cost_per_Violation","1000 × (98% - 90%) × $${metricValues.complianceRate?.value || 1000} = $${(1000 * 0.08 * (metricValues.complianceRate?.value || 1000)).toLocaleString()}",Risk Reduction\n`;

                // NEW SECTION: DETAILED CALCULATION VERIFICATION
                csv += '\n\n=== DETAILED CALCULATION VERIFICATION ===\n';
                csv += 'Use Case,Month,Metric,Volume,Improvement,Baseline,Net Change,Cost/Contact,Formula,Step-by-Step Calculation,Result ($)\n';
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        
                        normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                            const volume = getBenefitVolumeValue(normalizedUC, monthData, benefit, benefitIndex);
                            const fieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            const improvement = parseFloat(monthData[fieldKey]) || 0;
                            const baseline = parseFloat(benefit.baselineValue) || 0;
                            const netImprovement = Math.max(0, improvement - baseline);
                            const effectiveCost = getEffectiveCost(uc, uc.channel);
                            const aht = getApplicableAHT(uc);
                            
                            let formula = '';
                            let calculation = '';
                            let result = 0;
                            
                            if (benefit.metric.includes('AHT Reduction')) {
                                const costPerMinute = aht > 0 ? effectiveCost / aht : 0;
                                formula = 'Volume × Minutes_Saved × Cost_per_Minute';
                                calculation = `${volume} × ${netImprovement} min × $${costPerMinute.toFixed(3)}/min`;
                                result = volume * netImprovement * costPerMinute;
                            } else if (benefit.metric.includes('FCR')) {
                                formula = 'Volume × FCR_Improvement% × Cost_per_Contact';
                                calculation = `${volume} × ${netImprovement}% × $${effectiveCost.toFixed(2)}`;
                                result = volume * (netImprovement / 100) * effectiveCost;
                            } else if (benefit.metric.includes('NPS')) {
                                const npsValue = metricValues.npsImprovement?.value || 50;
                                formula = 'Survey_Count × Points × Value_per_Point';
                                calculation = `${volume} × ${netImprovement} pts × $${npsValue}`;
                                result = volume * netImprovement * npsValue;
                            } else if (benefit.metric.includes('CSAT')) {
                                const csatValue = metricValues.csatImprovement?.value || 25;
                                formula = 'Survey_Count × CSAT% × Value_per_Point';
                                calculation = `${volume} × ${netImprovement}% × $${csatValue}`;
                                result = volume * (netImprovement / 100) * csatValue;
                            } else {
                                // Default for all percentage-based metrics
                                formula = 'Volume × Improvement% × Cost_per_Contact';
                                calculation = `${volume} × ${netImprovement}% × $${effectiveCost.toFixed(2)}`;
                                result = volume * (netImprovement / 100) * effectiveCost;
                            }
                            
                            csv += `"${uc.name}","${month.month} ${month.year}","${benefit.metric}",${volume},${improvement},${baseline},${netImprovement},${effectiveCost.toFixed(2)},"${formula}","${calculation}",${result.toFixed(2)}\n`;
                        });
                    });
                });
                
                // SECTION 5: MONTHLY SUMMARY
                csv += '\n\n=== SECTION 5: MONTHLY SAVINGS SUMMARY ===\n';
                csv += 'Month,Total Volume,Total Savings,Cumulative Savings\n';
                
                let cumulative = 0;
                months.forEach(month => {
                    let monthVolume = 0;
                    let monthSavings = 0;
                    useCases.forEach(uc => {
                        const monthData = uc.data[month.id] || {};
                        monthVolume += getTotalVolumeForUseCaseMonth(uc, monthData);
                        monthSavings += calculateSavings(uc, month.id);
                    });
                    cumulative += monthSavings;
                    csv += `${month.month} ${month.year},${monthVolume},${monthSavings.toFixed(2)},${cumulative.toFixed(2)}\n`;
                });
                
                // SECTION 6: CATEGORY BREAKDOWN
                csv += '\n\n=== SECTION 6: SAVINGS BY CATEGORY ===\n';
                csv += 'Category,Total Volume,Total Savings,% of Total\n';
                
                const categoryTotals = {};
                const categoryVolumes = {};
                useCases.forEach(uc => {
                    if (!categoryTotals[uc.category]) {
                        categoryTotals[uc.category] = 0;
                        categoryVolumes[uc.category] = 0;
                    }
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        categoryVolumes[uc.category] += getTotalVolumeForUseCaseMonth(uc, monthData);
                        categoryTotals[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                
                const totalSavingsAll = calculateTotalSavings();
                Object.entries(categoryTotals).forEach(([category, savings]) => {
                    const percentage = totalSavingsAll > 0 ? (savings / totalSavingsAll * 100).toFixed(1) : 0;
                    csv += `${category},${categoryVolumes[category]},${savings.toFixed(2)},${percentage}%\n`;
                });
                
                // SECTION 7: CHANNEL BREAKDOWN
                csv += '\n\n=== SECTION 7: SAVINGS BY CHANNEL ===\n';
                csv += 'Channel,Total Volume,Total Savings,Default Cost,% of Total\n';
                
                const channelTotals = {};
                const channelVolumes = {};
                useCases.forEach(uc => {
                    if (!channelTotals[uc.channel]) {
                        channelTotals[uc.channel] = 0;
                        channelVolumes[uc.channel] = 0;
                    }
                    months.forEach(month => {
                        const monthData = uc.data[month.id] || {};
                        channelVolumes[uc.channel] += getTotalVolumeForUseCaseMonth(uc, monthData);
                        channelTotals[uc.channel] += calculateSavings(uc, month.id);
                    });
                });
                
                Object.entries(channelTotals).forEach(([channel, savings]) => {
                    const percentage = totalSavingsAll > 0 ? (savings / totalSavingsAll * 100).toFixed(1) : 0;
                    // Use helper function for channel cost extraction
                    const channelCost = getChannelCostValue(channel);
                    csv += `${channel},${channelVolumes[channel]},${savings.toFixed(2)},${channelCost},${percentage}%\n`;
                });
                
                // SECTION 8: VALUE DRIVER TYPE BREAKDOWN
                csv += '\n\n=== SECTION 8: SAVINGS BY VALUE DRIVER TYPE ===\n';
                csv += 'Value Driver Type,Total Savings (USD),Number of Benefits,% of Total,Description\n';
                
                const valueDriverTotals = {
                    'Cost Savings': { total: 0, count: 0, description: 'Traditional cost reduction through automation and deflection' },
                    'Quality Improvement': { total: 0, count: 0, description: 'Customer satisfaction and service quality enhancements' },
                    'Revenue Generation': { total: 0, count: 0, description: 'Direct revenue impact through improved conversion rates' },
                    'Cost Avoidance': { total: 0, count: 0, description: 'Avoided costs through improved retention and compliance' },
                    'Risk Reduction': { total: 0, count: 0, description: 'Reduced compliance violations and regulatory risks' }
                };
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        let valueDriverType = 'Cost Savings'; // default
                        
                        if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) {
                            valueDriverType = 'Quality Improvement';
                        } else if (benefit.metric.includes('FCR')) {
                            valueDriverType = 'Cost Savings';
                        } else if (benefit.metric.includes('Conversion Rate')) {
                            valueDriverType = 'Revenue Generation';
                        } else if (benefit.metric.includes('Agent Retention')) {
                            valueDriverType = 'Cost Avoidance';
                        } else if (benefit.metric.includes('Compliance')) {
                            valueDriverType = 'Risk Reduction';
                        }
                        
                        valueDriverTotals[valueDriverType].count++;
                        months.forEach(month => {
                            valueDriverTotals[valueDriverType].total += calculateBenefitSavings(normalizedUC, benefit, uc.data[month.id] || {}, benefitIndex);
                        });
                    });
                });
                
                Object.entries(valueDriverTotals).forEach(([type, data]) => {
                    const percentage = totalSavingsAll > 0 ? (data.total / totalSavingsAll * 100).toFixed(1) : 0;
                    csv += `"${type}",${data.total.toFixed(2)},${data.count},${percentage}%,"${data.description}"\n`;
                });
                
                // SECTION 9: ENHANCED EXECUTIVE SUMMARY
                csv += '\n\n=== SECTION 9: ENHANCED EXECUTIVE SUMMARY ===\n';
                csv += 'Metric,Value,Notes\n';
                csv += `Total Projected Value,$${calculateTotalSavings().toFixed(2)},Includes cost savings + quality improvements + revenue generation\n`;
                csv += `Average Monthly Value,$${(calculateTotalSavings() / months.length).toFixed(2)},Total value divided by analysis period\n`;
                csv += `Total Use Cases,${useCases.length},Individual AI implementations\n`;
                
                // Calculate benefit distribution
                let totalBenefits = 0;
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    totalBenefits += normalizedUC.benefits.length;
                });
                csv += `Total Benefits Tracked,${totalBenefits},Individual value drivers across all use cases\n`;
                csv += `Analysis Period,"${dateRange.start} to ${dateRange.end}",Date range for projections\n`;
                csv += `Number of Months,${months.length},Time periods analyzed\n`;
                csv += `Total Volume Processed,${Object.values(channelVolumes).reduce((a, b) => a + b, 0)},Total customer interactions across all channels\n`;
                csv += `Average Value per Contact,$${totalSavingsAll > 0 ? (totalSavingsAll / Object.values(channelVolumes).reduce((a, b) => a + b, 0) || 1).toFixed(2) : 0},Total value divided by total volume\n`;
                
                // Quality metrics configuration summary
                csv += `\nQuality Metric Values Used:,,Configuration settings for non-cost metrics\n`;
                Object.entries(metricValues).forEach(([key, config]) => {
                    csv += `${config.label},$${config.value},Per unit value for quality calculations\n`;
                });
                
                // Value driver summary
                csv += `\nValue Driver Distribution:,,Breakdown by benefit category\n`;
                Object.entries(valueDriverTotals).forEach(([type, data]) => {
                    const percentage = totalSavingsAll > 0 ? (data.total / totalSavingsAll * 100).toFixed(1) : 0;
                    csv += `${type} (${data.count} benefits),$${data.total.toFixed(2)},${percentage}% of total value\n`;
                });

                // SECTION 10: MULTI-BENEFIT USE CASE SUMMARY
                csv += '\n\n=== SECTION 10: MULTI-BENEFIT USE CASE SUMMARY ===\n';
                csv += 'Category,Use Case,Channel,Special Group,Total Benefits,Total Value (USD),Average Monthly Value (USD),Primary Value Driver Type\n';
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    let total = 0;
                    const valueDriverCounts = { 'Cost Savings': 0, 'Quality Improvement': 0, 'Revenue Generation': 0, 'Cost Avoidance': 0, 'Risk Reduction': 0 };
                    
                    normalizedUC.benefits.forEach(benefit => {
                        let valueDriverType = 'Cost Savings';
                        if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) {
                            valueDriverType = 'Quality Improvement';
                        } else if (benefit.metric.includes('FCR')) {
                            valueDriverType = 'Cost Savings'; // FCR is cost-based
                        } else if (benefit.metric.includes('Conversion Rate')) {
                            valueDriverType = 'Revenue Generation';
                        } else if (benefit.metric.includes('Agent Retention')) {
                            valueDriverType = 'Cost Avoidance';
                        } else if (benefit.metric.includes('Compliance')) {
                            valueDriverType = 'Risk Reduction';
                        }
                        valueDriverCounts[valueDriverType]++;
                    });
                    
                    months.forEach(month => { total += calculateSavings(uc, month.id); });
                    const avg = months.length > 0 ? (total / months.length) : 0;
                    
                    // Find primary value driver
                    const primaryValueDriver = Object.entries(valueDriverCounts).reduce((a, b) => valueDriverCounts[a[0]] > valueDriverCounts[b[0]] ? a : b)[0];
                    
                    csv += `${uc.category},"${uc.name}",${uc.channel},${uc.specialGroup || 'None'},${normalizedUC.benefits.length},${total.toFixed(2)},${avg.toFixed(2)},"${primaryValueDriver}"\n`;
                });

                // SECTION 11: MONTHLY VALUE MATRIX BY USE CASE
                csv += '\n\n=== SECTION 11: MONTHLY VALUE MATRIX BY USE CASE ===\n';
                csv += 'Use Case,Category,Channel,Total Benefits';
                months.forEach(month => {
                    csv += `,${month.year}-${month.month} Savings`;
                });
                csv += ',Total\n';
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    let total = 0;
                    let row = `"${uc.name}",${uc.category},${uc.channel},${normalizedUC.benefits.length}`;
                    months.forEach(month => {
                        const s = calculateSavings(uc, month.id);
                        total += s;
                        row += `,${s.toFixed(2)}`;
                    });
                    row += `,${total.toFixed(2)}\n`;
                    csv += row;
                });
                
                // Add a totals row across all use cases per month
                const totalBenefitsCount = useCases.reduce((sum, uc) => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    return sum + normalizedUC.benefits.length;
                }, 0);
                let totalsRow = `TOTAL (${useCases.length} use cases),,,${totalBenefitsCount}`;
                let grandTotal = 0;
                months.forEach(month => {
                    let mTotal = 0;
                    useCases.forEach(uc => { mTotal += calculateSavings(uc, month.id); });
                    grandTotal += mTotal;
                    totalsRow += `,${mTotal.toFixed(2)}`;
                });
                totalsRow += `,${grandTotal.toFixed(2)}\n`;
                csv += totalsRow;

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_analysis_complete_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            // Export current analytics view to CSV
            const exportAnalyticsCSV = () => {
                let csv = `=== MULTI-BENEFIT ANALYTICS EXPORT (${analyticsView.toUpperCase()}) ===\n`;
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                csv += `Months: ${getFilteredMonths().length}\n`;
                // Global defaults removed - configuration at category-channel level
                
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                csv += `Filtered Use Cases: ${filteredUseCases.length} of ${useCases.length}\n`;
                
                // Calculate total benefits in filtered data
                const totalFilteredBenefits = filteredUseCases.reduce((sum, uc) => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    return sum + normalizedUC.benefits.length;
                }, 0);
                csv += `Total Benefits in Filtered Data: ${totalFilteredBenefits}\n`;
                
                csv += `Category Filter: ${selectedCategory}\n`;
                csv += `Channel Filter: ${selectedChannel}\n`;
                csv += `Special Group Filter: ${selectedSpecialGroup || 'all'}\n`;
                csv += `Metric Filter: ${selectedMetric || 'all'}\n\n`;
                
                // Add active filters summary
                let activeFilters = [];
                if (selectedCategory !== 'all') activeFilters.push(`Category: ${selectedCategory}`);
                if (selectedChannel !== 'all') activeFilters.push(`Channel: ${selectedChannel}`);
                if (selectedSpecialGroup) activeFilters.push(`Special Group: ${selectedSpecialGroup === 'none' ? 'No Special Group' : selectedSpecialGroup}`);
                if (selectedMetric) activeFilters.push(`Metric: ${selectedMetric}`);
                
                if (activeFilters.length > 0) {
                    csv += `Active Filters Applied: ${activeFilters.join(', ')}\n`;
                } else {
                    csv += `Active Filters Applied: None (showing all data)\n`;
                }
                csv += '\n';

                if (analyticsView === 'overall') {
                    // Monthly trend data
                    csv += '=== MONTHLY TREND DATA ===\n';
                    csv += 'Note: All savings in USD\n';
                    csv += 'Formula: Savings = Volume × (Improvement - Baseline) × Effective Cost per Contact\n';
                    csv += 'Month,Monthly Savings ($),Cumulative Savings ($)\n';
                    const monthly = getMonthlyTrendData();
                    const cumulative = getCumulativeData();
                    monthly.forEach((d, i) => {
                        csv += `${d.label},${d.value},${cumulative[i]?.value || 0}\n`;
                    });
                    
                    csv += '\n=== BREAKDOWN BY CATEGORY ===\n';
                    csv += 'Category,Total Savings ($),Percentage of Total\n';
                    const byCategory = getCategoryBreakdown();
                    const totalCat = byCategory.reduce((s, c) => s + c.value, 0);
                    byCategory.forEach(d => {
                        const pct = totalCat > 0 ? ((d.value / totalCat) * 100).toFixed(1) : 0;
                        csv += `${d.label},${d.value},${pct}%\n`;
                    });
                    
                    // Add calculation formulas section
                    csv += '\n\n=== COMPREHENSIVE CALCULATION FORMULAS USED ===\n';
                    csv += 'Value Driver Type,Metric Type,Formula,Notes\n';
                    
                    // Cost-based metrics
                    csv += 'Cost Savings,Deflection Rate (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Prevents contacts from reaching agents"\n';
                    csv += 'Cost Savings,AHT Reduction (min),"Volume × (Minutes - Baseline) × (Cost/Minute)","For hourly rates: × (Rate/60); for per-contact: × (Rate/AHT)"\n';
                    csv += 'Cost Savings,Automation Rate (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Fully automated interactions"\n';
                    csv += 'Cost Savings,Self-Service Resolution (%),"Volume × (Improvement% - Baseline%) × Cost/Contact","Resolved without agent involvement"\n';
                    csv += 'Cost Savings,Transfer Rate Reduction (%),"Volume × (Reduction% - Baseline%) × Cost/Contact","Reduced agent-to-agent transfers"\n';
                    
                    // Quality-based metrics
                    csv += `Quality Improvement,NPS Improvement (points),"Volume × Points_Improved × $${metricValues.npsImprovement?.value || 50}","Customer loyalty and satisfaction value"\n`;
                    csv += `Quality Improvement,CSAT Improvement (%),"Volume × (CSAT% - Baseline%) × $${metricValues.csatImprovement?.value || 25}","Customer satisfaction score improvements"\n`;
                    csv += `Cost Savings,FCR Improvement (%),"Volume × (FCR% - Baseline%) × Cost_per_Contact","Avoided repeat calls from improved first call resolution"\n`;
                    
                    // Revenue and other metrics
                    csv += `Revenue Generation,Conversion Rate (%),"Volume × (Rate% - Baseline%) × $${metricValues.conversionRate?.value || 200}","Average deal value from improved conversions"\n`;
                    csv += `Cost Avoidance,Agent Retention (%),"Agents × (Retention% - Baseline%) × $${metricValues.agentRetention?.value || 5000}","Avoided recruitment and training costs"\n`;
                    csv += `Risk Reduction,Compliance Rate (%),"Volume × (Rate% - Baseline%) × $${metricValues.complianceRate?.value || 1000}","Avoided compliance violation costs"\n`;
                    
                    csv += '\n=== BREAKDOWN BY CHANNEL ===\n';
                    csv += 'Channel,Total Savings ($),Percentage of Total\n';
                    const byChannel = getChannelBreakdown();
                    const totalCh = byChannel.reduce((s, c) => s + c.value, 0);
                    byChannel.forEach(d => {
                        const pct = totalCh > 0 ? ((d.value / totalCh) * 100).toFixed(1) : 0;
                        csv += `${d.label},${d.value},${pct}%\n`;
                    });
                    
                } else if (analyticsView === 'category') {
                    csv += '=== MULTI-BENEFIT CATEGORY PERFORMANCE ANALYSIS ===\n';
                    csv += 'Note: Costs determined by hierarchy - Special Groups > Category Overrides > Channel Defaults\n';
                    csv += 'Category,Use Cases (count),Total Benefits,Total Volume (contacts),Total Value ($),Avg Value per Contact ($/contact),% of Total Value,Use Case Names\n';
                    const categoryStats = {};
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        if (!categoryStats[uc.category]) {
                            categoryStats[uc.category] = { useCases: [], benefitCount: 0, volume: 0, savings: 0 };
                        }
                        categoryStats[uc.category].useCases.push(uc.name);
                        categoryStats[uc.category].benefitCount += normalizedUC.benefits.length;
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            categoryStats[uc.category].volume += getTotalVolumeForUseCaseMonth(uc, md);
                            categoryStats[uc.category].savings += calculateSavings(uc, month.id);
                        });
                    });
                    const totalSavingsAll = Object.values(categoryStats).reduce((s, v) => s + v.savings, 0);
                    // Check if multiple categories have savings
                    const categoriesWithSavings = Object.values(categoryStats).filter(s => s.savings > 0).length;
                    
                    Object.entries(categoryStats).forEach(([cat, stats]) => {
                        let pct = '0';
                        if (totalSavingsAll > 0) {
                            const percentage = (stats.savings / totalSavingsAll * 100);
                            if (percentage > 0 && percentage < 0.1) {
                                pct = '<0.1';
                            } else if (percentage > 99.9 && percentage < 100 && categoriesWithSavings > 1) {
                                pct = '>99.9';
                            } else {
                                pct = percentage.toFixed(1);
                            }
                        }
                        const avg = stats.volume > 0 ? (stats.savings / stats.volume).toFixed(2) : '0.00';
                        const useCaseNames = stats.useCases.join('; ');
                        csv += `${cat},${stats.useCases.length},${stats.benefitCount},${Math.round(stats.volume)},${Math.round(stats.savings)},${avg},${pct}%,"${useCaseNames}"\n`;
                    });
                    
                    csv += '\n=== ENHANCED COST HIERARCHY EXPLANATION ===\n';
                    csv += 'Priority Level,Source,Description,Example\n';
                    csv += '1 (Highest),Special Group,"Override all other costs for specific agent groups","Tier 1 Agents: $25/hr"\n';
                    csv += '2 (High),Category-Channel,"Category-specific cost for specific channel","Pre-Sales Phone: $35/hr"\n';
                    csv += '3 (Medium),Category Default,"Category fallback cost for unspecified channels","Pre-Sales: $30/hr (default)"\n';
                    csv += '4 (Lowest),Channel Default,"Base costs per communication channel","Phone: $6/contact"\n';
                    
                } else if (analyticsView === 'channel') {
                    csv += '=== CHANNEL PERFORMANCE ANALYSIS ===\n';
                    csv += 'Note: Default costs can be overridden by category or special group settings\n';
                    csv += 'Channel,Use Cases (count),Total Volume (contacts),Total Savings ($),Default Cost ($/contact),Avg Improvement (% or min),% of Total Savings,Use Case Names\n';
                    const channelStats = {};
                    filteredUseCases.forEach(uc => {
                        if (!channelStats[uc.channel]) {
                            channelStats[uc.channel] = { useCases: [], volume: 0, savings: 0, improvements: [] };
                        }
                        channelStats[uc.channel].useCases.push(uc.name);
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                            channelStats[uc.channel].volume += getTotalVolumeForUseCaseMonth(normalizedUC, md);
                            channelStats[uc.channel].savings += calculateSavings(uc, month.id);
                            (normalizedUC.benefits || []).forEach((benefit, i) => {
                                const fieldKey = (normalizedUC.benefits.length === 1)
                                    ? `improvement_${benefit.metric}`
                                    : `improvement_${i}_${benefit.metric}`;
                                if (md[fieldKey] != null && !isNaN(parseFloat(md[fieldKey]))) {
                                    channelStats[uc.channel].improvements.push(parseFloat(md[fieldKey]));
                                }
                            });
                        });
                    });
                    const totalSavingsAll = Object.values(channelStats).reduce((s, v) => s + v.savings, 0);
                    
                    // Check if multiple channels have savings
                    const channelsWithSavings = Object.values(channelStats).filter(s => s.savings > 0).length;
                    
                    Object.entries(channelStats).forEach(([ch, stats]) => {
                        const avgImp = stats.improvements.length ? (stats.improvements.reduce((a,b)=>a+b,0)/stats.improvements.length).toFixed(1) : '0.0';
                        let pct = '0';
                        if (totalSavingsAll > 0) {
                            const percentage = (stats.savings / totalSavingsAll * 100);
                            if (percentage > 0 && percentage < 0.1) {
                                pct = '<0.1';
                            } else if (percentage > 99.9 && percentage < 100 && channelsWithSavings > 1) {
                                pct = '>99.9';
                            } else {
                                pct = percentage.toFixed(1);
                            }
                        }
                        const useCaseNames = stats.useCases.join('; ');
                        // Use helper function for channel cost extraction
                        const channelCost = getChannelCostValue(ch);
                        csv += `${ch},${stats.useCases.length},${Math.round(stats.volume)},${Math.round(stats.savings)},${channelCost},${avgImp}%,${pct}%,"${useCaseNames}"\n`;
                    });
                    
                    csv += '\n=== COST OVERRIDE INFORMATION ===\n';
                    csv += 'Channel,Default Cost ($/contact),Category Overrides,Special Group Overrides\n';
                    Object.keys(channelCosts).forEach(ch => {
                        const categoryOverrides = Object.keys(categoryCosts).filter(cat => 
                            filteredUseCases.some(uc => uc.channel === ch && uc.category === cat)).join('; ') || 'None';
                        const specialOverrides = getAllSpecialGroups().filter(sg => 
                            filteredUseCases.some(uc => uc.channel === ch && uc.specialGroup === sg)).join('; ') || 'None';
                        // Use helper function for channel cost extraction
                        const channelCost = getChannelCostValue(ch);
                        csv += `${ch},${channelCost},"${categoryOverrides}","${specialOverrides}"\n`;
                    });
                    
                } else if (analyticsView === 'usecase') {
                    csv += '=== MULTI-BENEFIT USE CASE ANALYSIS ===\n';
                    csv += 'Note: Each use case can have multiple benefits. Values include cost savings + quality improvements + revenue generation.\n\n';
                    
                    // Add benefit contribution breakdown
                    csv += '=== BENEFIT CONTRIBUTION BREAKDOWN ===\n';
                    csv += 'Use Case,Total Savings ($),Top Contributing Benefit,Top Contribution (%),Benefit Breakdown\n';
                    
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        let totalSavings = 0;
                        const benefitSavings = {};
                        
                        // Calculate total savings per benefit across all months
                        filteredMonths.forEach(month => {
                            const breakdown = calculateSavingsBreakdown(uc, month.id);
                            totalSavings += breakdown.total;
                            breakdown.breakdown.forEach(item => {
                                if (!benefitSavings[item.metric]) {
                                    benefitSavings[item.metric] = 0;
                                }
                                benefitSavings[item.metric] += item.savings;
                            });
                        });
                        
                        // Find top contributor and format breakdown
                        let topContributor = { metric: 'N/A', percentage: 0 };
                        const breakdownParts = [];
                        
                        Object.entries(benefitSavings).forEach(([metric, savings]) => {
                            const percentage = totalSavings > 0 ? (savings / totalSavings * 100) : 0;
                            breakdownParts.push(`${metric}: $${Math.round(savings)} (${percentage.toFixed(1)}%)`);
                            if (percentage > topContributor.percentage) {
                                topContributor = { metric, percentage };
                            }
                        });
                        
                        const breakdownStr = breakdownParts.join('; ');
                        csv += `"${uc.name}",${totalSavings.toFixed(2)},"${topContributor.metric}",${topContributor.percentage.toFixed(1)}%,"${breakdownStr}"\n`;
                    });
                    
                    csv += '\n';
                    
                    // Add monthly trends for each use case
                    csv += '=== MONTHLY VALUE TRENDS BY USE CASE ===\n';
                    csv += 'Month';
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        csv += `,"${uc.name}" (${normalizedUC.benefits.length} benefits) ($)`;
                    });
                    csv += ',Total Value ($)\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotal = 0;
                        
                        filteredUseCases.forEach(uc => {
                            const savings = calculateSavings(uc, month.id);
                            csv += `,${savings.toFixed(2)}`;
                            monthTotal += savings;
                        });
                        
                        csv += `,${monthTotal.toFixed(2)}\n`;
                    });
                    
                    csv += '\n=== MONTHLY VOLUME TRENDS BY USE CASE ===\n';
                    csv += 'Month';
                    filteredUseCases.forEach(uc => {
                        csv += `,${uc.name} (contacts)`;
                    });
                    csv += ',Total Contacts\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotalVolume = 0;
                        
                        filteredUseCases.forEach(uc => {
                            const md = uc.data[month.id] || {};
                            const volume = getTotalVolumeForUseCaseMonth(uc, md);
                            csv += `,${volume}`;
                            monthTotalVolume += volume;
                        });
                        
                        csv += `,${monthTotalVolume}\n`;
                    });
                    
                    csv += '\n=== BENEFIT DETAILS BY USE CASE ===\n';
                    csv += 'Use Case,Benefit Number,Metric Type,Unit,Baseline,Value Driver Type\n';
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        normalizedUC.benefits.forEach((benefit, index) => {
                            let unit = '%';
                            if (benefit.metric.includes('AHT Reduction')) unit = 'minutes';
                            else if (benefit.metric.includes('NPS Improvement')) unit = 'points';
                            
                            let valueDriverType = 'Cost Savings';
                            if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) {
                                valueDriverType = 'Quality Improvement';
                            } else if (benefit.metric.includes('FCR')) {
                                valueDriverType = 'Cost Savings';
                            } else if (benefit.metric.includes('Conversion Rate')) {
                                valueDriverType = 'Revenue Generation';
                            } else if (benefit.metric.includes('Agent Retention')) {
                                valueDriverType = 'Cost Avoidance';
                            } else if (benefit.metric.includes('Compliance')) {
                                valueDriverType = 'Risk Reduction';
                            }
                            
                            csv += `"${uc.name}",${index + 1},"${benefit.metric}",${unit},${benefit.baselineValue},"${valueDriverType}"\n`;
                        });
                    });
                    
                    csv += '\n=== MULTI-BENEFIT USE CASE PERFORMANCE SUMMARY ===\n';
                    csv += 'Use Case,Category,Channel,Total Benefits,Special Group,Total Volume (contacts),Total Value ($),% of Total Value,Primary Value Driver Type\n';
                    const totalSavingsAll = calculateTotalSavings();
                    
                    // Calculate how many use cases have savings
                    const useCasesWithSavings = filteredUseCases.filter(uc => {
                        let ucSavings = 0;
                        filteredMonths.forEach(month => {
                            ucSavings += calculateSavings(uc, month.id);
                        });
                        return ucSavings > 0;
                    }).length;
                    
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        let totalVolume = 0, totalSavings = 0;
                        
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            totalVolume += getTotalVolumeForUseCaseMonth(uc, md);
                            totalSavings += calculateSavings(uc, month.id);
                        });
                        
                        let pct = '0';
                        if (totalSavingsAll > 0) {
                            const percentage = (totalSavings / totalSavingsAll * 100);
                            if (percentage > 0 && percentage < 0.1) {
                                pct = '<0.1';
                            } else if (percentage > 99.9 && percentage < 100 && useCasesWithSavings > 1) {
                                pct = '>99.9';
                            } else {
                                pct = percentage.toFixed(1);
                            }
                        }
                        
                        // Determine primary value driver type
                        const valueDriverCounts = { 'Cost Savings': 0, 'Quality Improvement': 0, 'Revenue Generation': 0, 'Cost Avoidance': 0, 'Risk Reduction': 0 };
                        normalizedUC.benefits.forEach(benefit => {
                            let valueDriverType = 'Cost Savings';
                            if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) {
                                valueDriverType = 'Quality Improvement';
                            } else if (benefit.metric.includes('FCR')) {
                                valueDriverType = 'Cost Savings';
                            } else if (benefit.metric.includes('Conversion Rate')) {
                                valueDriverType = 'Revenue Generation';
                            } else if (benefit.metric.includes('Agent Retention')) {
                                valueDriverType = 'Cost Avoidance';
                            } else if (benefit.metric.includes('Compliance')) {
                                valueDriverType = 'Risk Reduction';
                            }
                            valueDriverCounts[valueDriverType]++;
                        });
                        const primaryValueDriver = Object.entries(valueDriverCounts).reduce((a, b) => valueDriverCounts[a[0]] > valueDriverCounts[b[0]] ? a : b)[0];
                        
                        csv += `"${uc.name}",${uc.category},${uc.channel},${normalizedUC.benefits.length},${uc.specialGroup || 'None'},${Math.round(totalVolume)},${Math.round(totalSavings)},${pct}%,"${primaryValueDriver}"\n`;
                    });
                    
                    csv += '\n=== DETAILED MONTHLY BREAKDOWN BY USE CASE ===\n';
                    csv += 'Use Case,Month,Volume,Benefits,Improvements,Baselines,Net Improvements,Effective Cost,Savings\n';
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        const ahtUsed = getApplicableAHT(uc);
                        
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            const volume = getTotalVolumeForUseCaseMonth(uc, md);
                            const savings = calculateSavings(uc, month.id);
                            
                            // Collect improvements for each benefit
                            const improvementDetails = normalizedUC.benefits.map((benefit, index) => {
                                const fieldKey = normalizedUC.benefits.length === 1 
                                    ? `improvement_${benefit.metric}`
                                    : `improvement_${index}_${benefit.metric}`;
                                const improvement = parseFloat(md[fieldKey]) || 0;
                                const baseline = benefit.baselineValue || 0;
                                const netImprovement = Math.max(0, improvement - baseline);
                                
                                let unit = '%';
                                if (benefit.metric.includes('min')) unit = 'min';
                                else if (benefit.metric.includes('points')) unit = 'pts';
                                
                                return {
                                    metric: benefit.metric,
                                    improvement: `${improvement.toFixed(1)} ${unit}`,
                                    baseline: `${baseline} ${unit}`,
                                    netImprovement: `${netImprovement.toFixed(1)} ${unit}`
                                };
                            });
                            
                            const benefitsStr = improvementDetails.map(d => d.metric).join(' + ');
                            const improvementsStr = improvementDetails.map(d => d.improvement).join(' / ');
                            const baselinesStr = improvementDetails.map(d => d.baseline).join(' / ');
                            const netImprovementsStr = improvementDetails.map(d => d.netImprovement).join(' / ');
                            
                            csv += `"${uc.name}",${month.month} ${month.year},${volume},"${benefitsStr}","${improvementsStr}","${baselinesStr}","${netImprovementsStr}",$${effectiveCost},$${savings.toFixed(2)}\n`;
                        });
                    });
                    
                    csv += '\n=== USE CASE CONFIGURATION & BASELINE EXPLANATION ===\n';
                    csv += 'Use Case,Benefits,Baselines,Baseline Interpretations,Cost Source Details,Formulas Used\n';
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        
                        // Process each benefit
                        const benefitDetails = normalizedUC.benefits.map(benefit => {
                            let unit = '%';
                            if (benefit.metric.includes('min')) unit = 'minutes';
                            else if (benefit.metric.includes('points')) unit = 'points';
                            
                            let interpretation = '';
                            if (benefit.metric.includes('Deflection')) interpretation = 'Current deflection rate without AI';
                            else if (benefit.metric.includes('AHT')) interpretation = 'Current time savings without AI';
                            else if (benefit.metric.includes('Automation')) interpretation = 'Current automation rate without AI';
                            else if (benefit.metric.includes('Self-Service')) interpretation = 'Current self-service success rate';
                            else if (benefit.metric.includes('Transfer')) interpretation = 'Current transfer reduction without AI';
                            else if (benefit.metric.includes('NPS')) interpretation = 'Current NPS baseline';
                            else if (benefit.metric.includes('CSAT')) interpretation = 'Current satisfaction baseline';
                            else if (benefit.metric.includes('FCR')) interpretation = 'Current first call resolution baseline';
                            else interpretation = 'Current baseline without AI';
                            
                            return {
                                metric: benefit.metric,
                                baseline: `${benefit.baselineValue || 0} ${unit}`,
                                interpretation: interpretation
                            };
                        });
                        
                        const benefitsStr = benefitDetails.map(d => d.metric).join(' + ');
                        const baselinesStr = benefitDetails.map(d => d.baseline).join(' / ');
                        const interpretationsStr = benefitDetails.map(d => d.interpretation).join('; ');
                        
                        let costSourceDetails = '';
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        const ahtUsed = getApplicableAHT(uc);
                        
                        if (categoryCosts[uc.category]) {
                            const categoryData = categoryCosts[uc.category];
                            
                            // Check for special group within category-channel (highest priority)
                            if (uc.specialGroup && categoryData[uc.channel] && categoryData[uc.channel]._specialGroups && categoryData[uc.channel]._specialGroups[uc.specialGroup]) {
                                const sgData = categoryData[uc.channel]._specialGroups[uc.specialGroup];
                                if (sgData.costType === 'hourly') {
                                    costSourceDetails = `Special Group (${uc.category}-${uc.channel}): $${sgData.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact`;
                                } else {
                                    costSourceDetails = `Special Group (${uc.category}-${uc.channel}): $${sgData.value}/contact`;
                                }
                            }
                            // Category-Channel specific cost
                            else if (categoryData[uc.channel] && categoryData[uc.channel]._default) {
                                const channelCost = categoryData[uc.channel]._default;
                                if (channelCost.costType === 'hourly') {
                                    costSourceDetails = `Category-Channel: $${channelCost.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact (${uc.category}-${uc.channel})`;
                                } else {
                                    costSourceDetails = `Category-Channel: $${channelCost.value}/contact (${uc.category}-${uc.channel})`;
                                }
                            }
                            // Category default cost
                            else {
                                const defaultCost = categoryData._default || categoryData;
                                if (defaultCost && defaultCost.costType) {
                                    if (defaultCost.costType === 'hourly') {
                                        costSourceDetails = `Category Default: $${defaultCost.value}/hr × ${ahtUsed}min ÷ 60 = $${effectiveCost}/contact (${uc.category})`;
                                    } else {
                                        costSourceDetails = `Category Default: $${defaultCost.value}/contact (${uc.category})`;
                                    }
                                }
                            }
                        } else {
                            costSourceDetails = `Channel Default: $${getChannelCostValue(uc.channel)}/contact`;
                        }
                        
                        // Build formulas for each benefit
                        const formulas = normalizedUC.benefits.map(benefit => {
                            if (benefit.metric.includes('AHT') || benefit.metric.includes('min')) {
                                return `${benefit.metric}: Volume × (Improvement - Baseline) minutes × (Cost ÷ AHT) per minute`;
                            } else if (benefit.metric.includes('NPS') || benefit.metric.includes('points')) {
                                return `${benefit.metric}: Improvement points × Configured value per point`;
                            } else {
                                return `${benefit.metric}: Volume × (Improvement% - Baseline%) × Cost per Contact`;
                            }
                        });
                        const formulasStr = formulas.join('; ');
                        
                        csv += `"${uc.name}","${benefitsStr}","${baselinesStr}","${interpretationsStr}","${costSourceDetails}","${formulasStr}"\n`;
                    });
                    
                } else if (analyticsView === 'specialgroup') {
                    csv += '=== SPECIAL GROUP ANALYSIS ===\n';
                    csv += 'Note: Special groups have highest priority in cost hierarchy. Use cases without special groups use category or channel defaults.\n\n';
                    
                    // Add monthly trends first
                    csv += '=== MONTHLY SAVINGS TRENDS BY GROUP ===\n';
                    csv += 'Month';
                    const allGroups = [...getAllSpecialGroups(), 'No Special Group'];
                    allGroups.forEach(group => csv += `,${group} ($)`);
                    csv += ',Total ($)\n';
                    
                    filteredMonths.forEach(month => {
                        csv += `${month.month} ${month.year}`;
                        let monthTotal = 0;
                        
                        allGroups.forEach(group => {
                            let groupSavings = 0;
                            const groupUseCases = group === 'No Special Group' 
                                ? filteredUseCases.filter(uc => !uc.specialGroup)
                                : filteredUseCases.filter(uc => uc.specialGroup === group);
                                
                            groupUseCases.forEach(uc => {
                                groupSavings += calculateSavings(uc, month.id);
                            });
                            
                            csv += `,${groupSavings.toFixed(2)}`;
                            monthTotal += groupSavings;
                        });
                        
                        csv += `,${monthTotal.toFixed(2)}\n`;
                    });
                    
                    csv += '\n=== GROUP PERFORMANCE SUMMARY ===\n';
                    csv += 'Group,Primary Cost Type,Effective Rate,Use Cases,Total Volume,Total Savings,% of Total,Use Case Names\n';
                    
                    const groupStats = {};
                    
                    // Initialize all special groups from the nested structure
                    getAllSpecialGroups().forEach(g => {
                        let groupFound = false;
                        let groupCostType = 'Varies';
                        let groupValue = 'See details';
                        
                        // Try to find a representative cost for this special group
                        Object.values(categoryCosts).forEach(categoryData => {
                            if (!groupFound) {
                                Object.values(categoryData).forEach(channelData => {
                                    if (!groupFound && channelData && channelData._specialGroups && channelData._specialGroups[g]) {
                                        const groupCost = channelData._specialGroups[g];
                                        groupCostType = groupCost.costType === 'hourly' ? 'Hourly' : 'Per Contact';
                                        groupValue = groupCost.value;
                                        groupFound = true;
                                    }
                                });
                            }
                        });
                        
                        groupStats[g] = { costType: groupCostType, value: groupValue, useCases: [], volume: 0, savings: 0 };
                    });
                    
                    // Initialize "No Special Group"
                    groupStats['No Special Group'] = { 
                        costType: 'Mixed (Category/Channel defaults)', 
                        value: 'See breakdown below', 
                        useCases: [], 
                        volume: 0, 
                        savings: 0 
                    };
                    
                    // Populate stats from use cases
                    filteredUseCases.forEach(uc => {
                        const key = uc.specialGroup || 'No Special Group';
                        if (!groupStats[key]) {
                            groupStats[key] = { costType: 'Unknown', value: '-', useCases: [], volume: 0, savings: 0 };
                        }
                        groupStats[key].useCases.push(uc.name);
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            groupStats[key].volume += getTotalVolumeForUseCaseMonth(uc, md);
                            groupStats[key].savings += calculateSavings(uc, month.id);
                        });
                    });
                    
                    const totalSavingsAll = Object.values(groupStats).reduce((s, v) => s + v.savings, 0);
                    
                    // Check if multiple groups have savings for percentage adjustment
                    const groupsWithSavings = Object.values(groupStats).filter(s => s.savings > 0).length;
                    
                    Object.entries(groupStats).forEach(([g, stats]) => {
                        if (stats.useCases.length > 0) {
                            let pct = '0';
                            if (totalSavingsAll > 0) {
                                const percentage = (stats.savings / totalSavingsAll * 100);
                                if (percentage > 0 && percentage < 0.1) {
                                    pct = '<0.1';
                                } else if (percentage > 99.9 && percentage < 100 && groupsWithSavings > 1) {
                                    pct = '>99.9';
                                } else {
                                    pct = percentage.toFixed(1);
                                }
                            }
                            const rate = stats.value;
                            const useCaseNames = stats.useCases.join('; ');
                            csv += `${g},${stats.costType},${rate},${stats.useCases.length},${Math.round(stats.volume)},${Math.round(stats.savings)},${pct}%,"${useCaseNames}"\n`;
                        }
                    });
                    
                    csv += '\n=== SPECIAL GROUP COST DETAILS ===\n';
                    csv += 'Special Group,Category,Channel,Cost Type,Rate,AHT (min),Converted Cost per Contact\n';
                    
                    // Extract all special group cost details from the nested structure
                    Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([channel, channelData]) => {
                            if (channel !== '_default' && channelData && channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = groupData.ahtMinutes || 10;
                                    const convertedCost = groupData.costType === 'hourly' ? (groupData.value * aht / 60).toFixed(2) : groupData.value;
                                    csv += `${group},${category},${channel},${groupData.costType},$${groupData.value},${aht},$${convertedCost}\n`;
                                });
                            }
                        });
                    });
                    
                    csv += '\n=== DETAILED BREAKDOWN: USE CASES WITHOUT SPECIAL GROUPS ===\n';
                    csv += 'Use Case,Category,Channel,Metric,Cost Source,Effective Cost ($/contact),AHT (min),Baseline,Avg Improvement,Total Volume,Total Savings,Calculation Method\n';
                    const noSpecialGroupUseCases = filteredUseCases.filter(uc => !uc.specialGroup);
                    noSpecialGroupUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        let totalVolume = 0, totalSavings = 0;
                        const benefitImprovements = {};
                        
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            totalVolume += getTotalVolumeForUseCaseMonth(uc, md);
                            totalSavings += calculateSavings(uc, month.id);
                            
                            // Collect improvements for each benefit
                            normalizedUC.benefits.forEach((benefit, index) => {
                                const fieldKey = normalizedUC.benefits.length === 1 
                                    ? `improvement_${benefit.metric}`
                                    : `improvement_${index}_${benefit.metric}`;
                                if (!benefitImprovements[benefit.metric]) {
                                    benefitImprovements[benefit.metric] = [];
                                }
                                if (md[fieldKey] != null) {
                                    benefitImprovements[benefit.metric].push(parseFloat(md[fieldKey]) || 0);
                                }
                            });
                        });
                        
                        const costSource = getCostSourceDescription(uc, uc.channel);
                        const effectiveCost = getEffectiveCost(uc, uc.channel);
                        let costDetail = `$${getChannelCostValue(uc.channel)}/contact`;
                        
                        if (categoryCosts[uc.category]) {
                            const categoryData = categoryCosts[uc.category];
                            
                            // Check for special group first
                            if (uc.specialGroup && categoryData[uc.channel] && categoryData[uc.channel]._specialGroups && categoryData[uc.channel]._specialGroups[uc.specialGroup]) {
                                const sgData = categoryData[uc.channel]._specialGroups[uc.specialGroup];
                                const sgAht = sgData.ahtMinutes || getApplicableAHT(uc);
                                if (sgData.costType === 'hourly') {
                                    costDetail = `$${sgData.value}/hr (${sgAht}min AHT) = $${effectiveCost}/contact`;
                                } else {
                                    costDetail = `$${sgData.value}/contact`;
                                }
                            }
                            // Then category-channel
                            else if (categoryData[uc.channel] && categoryData[uc.channel]._default) {
                                const channelCost = categoryData[uc.channel]._default;
                                const costAht = channelCost.ahtMinutes || getApplicableAHT(uc);
                                if (channelCost.costType === 'hourly') {
                                    costDetail = `$${channelCost.value}/hr (${costAht}min AHT) = $${effectiveCost}/contact`;
                                } else {
                                    costDetail = `$${channelCost.value}/contact`;
                                }
                            }
                            // Then category default
                            else {
                                const defaultCost = categoryData._default || categoryData;
                                if (defaultCost && defaultCost.costType) {
                                    const costAht = defaultCost.ahtMinutes || getApplicableAHT(uc);
                                    if (defaultCost.costType === 'hourly') {
                                        costDetail = `$${defaultCost.value}/hr (${costAht}min AHT) = $${effectiveCost}/contact`;
                                    } else {
                                        costDetail = `$${defaultCost.value}/contact`;
                                    }
                                }
                            }
                        }
                        
                        const ahtUsed = getApplicableAHT(uc);
                        
                        // Format benefits for CSV
                        const benefitSummary = normalizedUC.benefits.map(b => b.metric).join(' + ');
                        const baselineSummary = normalizedUC.benefits.map(b => b.baselineValue || 0).join(' / ');
                        
                        // Calculate average improvements for each benefit
                        const avgImprovements = normalizedUC.benefits.map(benefit => {
                            const improvements = benefitImprovements[benefit.metric] || [];
                            const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                            if (benefit.metric.includes('min')) return `${avg.toFixed(1)} min`;
                            if (benefit.metric.includes('points')) return `${avg.toFixed(1)} pts`;
                            return `${avg.toFixed(1)}%`;
                        });
                        const avgImpFormatted = avgImprovements.join(' / ');
                        
                        // Build calculation method description for multiple benefits
                        const calculationMethods = normalizedUC.benefits.map(benefit => {
                            const improvements = benefitImprovements[benefit.metric] || [];
                            const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                            
                            if (benefit.metric.includes('Deflection') || benefit.metric.includes('Rate')) {
                                return `${benefit.metric}: Volume × (${avg.toFixed(1)}% - ${benefit.baselineValue}%) × $${effectiveCost}`;
                            } else if (benefit.metric.includes('AHT') || benefit.metric.includes('min')) {
                                return `${benefit.metric}: Volume × (${avg.toFixed(1)} - ${benefit.baselineValue}) min × $${(effectiveCost/ahtUsed).toFixed(3)}/min`;
                            } else if (benefit.metric.includes('NPS') || benefit.metric.includes('points')) {
                                return `${benefit.metric}: ${avg.toFixed(1)} points × configured value`;
                            } else {
                                return `${benefit.metric}: Volume × (${avg.toFixed(1)}% - ${benefit.baselineValue}%) × $${effectiveCost}`;
                            }
                        });
                        const calculationMethod = calculationMethods.join('; ');
                        
                        csv += `"${uc.name}",${uc.category},${uc.channel},"${benefitSummary}",${costSource},"${costDetail}",${ahtUsed},"${baselineSummary}","${avgImpFormatted}",${Math.round(totalVolume)},$${Math.round(totalSavings)},"${calculationMethod}"\n`;
                    });
                    
                    csv += '\n=== CATEGORY COST CONFIGURATIONS & USAGE ===\n';
                    csv += 'Category,Cost Type,Rate,AHT (min),Converted Cost per Contact,Use Cases Using This,Total Volume,Total Savings\n';
                    Object.entries(categoryCosts).forEach(([category, data]) => {
                        const aht = data.ahtMinutes || defaultAHT;
                        const convertedCost = data.costType === 'hourly' ? (data.value * aht / 60).toFixed(2) : data.value;
                        const useCasesUsingThis = filteredUseCases.filter(uc => uc.category === category && !uc.specialGroup);
                        const useCaseNames = useCasesUsingThis.map(uc => uc.name).join('; ') || 'None';
                        
                        let totalCatVolume = 0, totalCatSavings = 0;
                        useCasesUsingThis.forEach(uc => {
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            totalCatVolume += getTotalVolumeForUseCaseMonth(uc, md);
                            totalCatSavings += calculateSavings(uc, month.id);
                        });
                        });
                        
                        csv += `${category},${data.costType},$${data.value},${aht},$${convertedCost},"${useCaseNames}",${Math.round(totalCatVolume)},$${Math.round(totalCatSavings)}\n`;
                    });
                    
                    csv += '\n=== CHANNEL DEFAULT COSTS (Fallback) ===\n';
                    csv += 'Channel,Default Cost ($/contact),AHT (min),Use Cases Using Default,Volume,Savings\n';
                    Object.entries(channelCosts).forEach(([channel, cost]) => {
                        const useCasesUsingDefault = filteredUseCases.filter(uc => 
                            uc.channel === channel && !uc.specialGroup && !categoryCosts[uc.category]
                        );
                        const useCaseNames = useCasesUsingDefault.map(uc => uc.name).join('; ') || 'None';
                        
                        let channelVolume = 0, channelSavings = 0;
                        useCasesUsingDefault.forEach(uc => {
                        filteredMonths.forEach(month => {
                            const md = uc.data[month.id] || {};
                            channelVolume += getTotalVolumeForUseCaseMonth(uc, md);
                            channelSavings += calculateSavings(uc, month.id);
                        });
                        });
                        
                        csv += `${channel},$${cost},${defaultAHT},"${useCaseNames}",${Math.round(channelVolume)},$${Math.round(channelSavings)}\n`;
                    });
                    
                    csv += '\n=== ENHANCED CALCULATION METHODOLOGY ===\n';
                    csv += 'Priority,Cost Source,Description,When Applied,Example\n';
                    csv += '1,Special Groups,"Override ALL other costs for specific agent groups","When use case has specialGroup assigned","Tier 1 Agents override everything"\n';
                    csv += '2,Category-Channel,"Category-specific cost for specific channel","When category has channel-specific cost AND no special group","Pre-Sales Phone has specific rate"\n';
                    csv += '3,Category Default,"Category fallback for unspecified channels","When category has default cost AND no special group or channel-specific","Pre-Sales default applies to email"\n';
                    csv += '4,Channel Default,"Base cost per communication channel","When no special group or category configuration exists","Generic phone cost applies"\n';
                    csv += '\nFormula Examples:\n';
                    csv += 'Metric Type,Formula,Example\n';
                    csv += 'Deflection Rate,"Volume × (Improvement% - Baseline%) × Cost/Contact","1000 contacts × (60% - 10%) × $4.50 = $2,250"\n';
                    csv += 'AHT Reduction,"Volume × (Minutes - Baseline) × Cost/Minute","500 contacts × (2.5 - 0.5) min × $0.75/min = $750"\n';
                    csv += 'Other Metrics,"Volume × (Improvement% - Baseline%) × Cost/Contact","2000 contacts × (40% - 15%) × $3.00 = $1,500"\n';
                }

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `analytics_${analyticsView}_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            // Export Analytics view to Excel with formulas
            const exportAnalyticsExcel = () => {
                const TAB = '\t';
                let excel = '';
                
                // Header
                excel += `AI ROI CALCULATOR - ${analyticsView.toUpperCase()} ANALYTICS\n`;
                excel += `Export Date${TAB}${new Date().toISOString().split('T')[0]}\n`;
                excel += `Analysis Period${TAB}${analyticsDateRange.start} to ${analyticsDateRange.end}\n`;
                excel += '\n';
                
                // Get filtered data
                const filteredUseCases = getFilteredUseCases();
                const filteredMonths = getFilteredMonths();
                
                if (analyticsView === 'overall' || analyticsView === 'benefit') {
                    // Detailed calculation view with formulas
                    excel += `Use Case${TAB}Category${TAB}Channel${TAB}Benefit${TAB}Month${TAB}Volume${TAB}Improvement${TAB}Baseline${TAB}Net Improvement${TAB}Cost${TAB}Savings\n`;
                    
                    let row = 6; // Data starts at row 6
                    const startRow = row;
                    
                    filteredUseCases.forEach(uc => {
                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                        normalizedUC.benefits.forEach((benefit, idx) => {
                            filteredMonths.forEach(month => {
                                const monthData = uc.data[month.id] || {};
                                const volumeKey = normalizedUC.benefits.length === 1 
                                    ? `volume_${benefit.metric}` 
                                    : `volume_${idx}_${benefit.metric}`;
                                const improvementKey = normalizedUC.benefits.length === 1 
                                    ? `improvement_${benefit.metric}` 
                                    : `improvement_${idx}_${benefit.metric}`;
                                
                                const volume = parseFloat(monthData[volumeKey] || 0);
                                const improvement = parseFloat(monthData[improvementKey] || 0);
                                const baseline = benefit.baselineValue || 0;
                                const cost = getEffectiveCost(uc, uc.channel);
                                
                                // Generate appropriate formula based on metric type
                                const metricConfig = METRIC_CONFIG[benefit.metric];
                                let savingsFormula;
                                
                                if (!metricConfig) {
                                    savingsFormula = `=G${row}*(I${row}/100)*J${row}`;
                                } else {
                                    switch (metricConfig.type) {
                                        case 'time_cost':
                                            const aht = getApplicableAHT(uc) || 10;
                                            const costPerMin = cost / aht;
                                            savingsFormula = `=G${row}*MIN(I${row},${aht})*${costPerMin.toFixed(4)}`;
                                            break;
                                        case 'percentage_cost':
                                            savingsFormula = `=G${row}*(I${row}/100)*J${row}`;
                                            break;
                                        case 'fcr_special':
                                            savingsFormula = `=G${row}*(I${row}/100)*J${row}*0.3`;
                                            break;
                                        case 'points_value':
                                            const pointValue = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                            savingsFormula = `=G${row}*I${row}*${pointValue}`;
                                            break;
                                        case 'percentage_value':
                                            const pctValue = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                            savingsFormula = `=G${row}*(I${row}/100)*${pctValue}`;
                                            break;
                                        default:
                                            savingsFormula = `=G${row}*(I${row}/100)*J${row}`;
                                    }
                                }
                                
                                excel += `${uc.name}${TAB}${uc.category}${TAB}${uc.channel}${TAB}${benefit.metric}${TAB}${month.month} ${month.year}${TAB}`;
                                excel += `${volume}${TAB}${improvement}${TAB}${baseline}${TAB}=MAX(0,G${row}-H${row})${TAB}${cost.toFixed(2)}${TAB}${savingsFormula}\n`;
                                row++;
                            });
                        });
                    });
                    
                    // Summary
                    excel += '\n';
                    excel += `TOTAL SAVINGS${TAB}=SUM(K${startRow}:K${row-1})\n`;
                    
                } else {
                    // Aggregated view by category/channel/use case
                    excel += `${analyticsView === 'category' ? 'Category' : analyticsView === 'channel' ? 'Channel' : analyticsView === 'usecase' ? 'Use Case' : 'Special Group'}${TAB}Volume${TAB}Savings${TAB}Percentage\n`;
                    
                    let row = 5;
                    const dataRows = [];
                    
                    if (analyticsView === 'category') {
                        categories.forEach(category => {
                            const catUseCases = filteredUseCases.filter(uc => uc.category === category);
                            let volume = 0, savings = 0;
                            catUseCases.forEach(uc => {
                                filteredMonths.forEach(month => {
                                    const monthData = uc.data[month.id] || {};
                                    volume += getTotalVolumeForUseCaseMonth(uc, monthData);
                                    savings += calculateSavings(uc, month.id);
                                });
                            });
                            if (savings > 0) {
                                dataRows.push({ name: category, volume, savings, row });
                                excel += `${category}${TAB}${Math.round(volume)}${TAB}${Math.round(savings)}${TAB}`;
                                row++;
                            }
                        });
                    } else if (analyticsView === 'channel') {
                        ALL_CHANNELS.forEach(ch => {
                            const channelUseCases = filteredUseCases.filter(uc => uc.channel === ch.id);
                            let volume = 0, savings = 0;
                            channelUseCases.forEach(uc => {
                                filteredMonths.forEach(month => {
                                    const monthData = uc.data[month.id] || {};
                                    volume += getTotalVolumeForUseCaseMonth(uc, monthData);
                                    savings += calculateSavings(uc, month.id);
                                });
                            });
                            if (savings > 0) {
                                dataRows.push({ name: ch.name, volume, savings, row });
                                excel += `${ch.name}${TAB}${Math.round(volume)}${TAB}${Math.round(savings)}${TAB}`;
                                row++;
                            }
                        });
                    }
                    
                    // Add percentage formulas
                    const startDataRow = 5;
                    const endDataRow = row - 1;
                    dataRows.forEach((data, idx) => {
                        const currentRow = startDataRow + idx;
                        excel += `=C${currentRow}/SUM(C${startDataRow}:C${endDataRow})*100\n`;
                    });
                    
                    // Total row
                    excel += `\nTOTAL${TAB}=SUM(B${startDataRow}:B${endDataRow})${TAB}=SUM(C${startDataRow}:C${endDataRow})${TAB}100\n`;
                }
                
                // Download as Excel
                const blob = new Blob([excel], { type: 'application/vnd.ms-excel' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `analytics_${analyticsView}_excel_${new Date().toISOString().split('T')[0]}.xls`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            // Excel export with live formulas for full traceability and automatic calculations
            const exportToExcel = () => {
                // Create a tab-separated file for better Excel formula recognition
                const TAB = '\t';
                let csv = '';
                
                // Simple header section
                csv += 'AI ROI CALCULATOR - EXCEL EXPORT WITH LIVE FORMULAS\n'; // Row 1
                csv += `Export Date${TAB}${new Date().toISOString().split('T')[0]}\n`; // Row 2
                csv += `Analysis Period${TAB}${dateRange.start} to ${dateRange.end}\n`; // Row 3
                csv += '\n'; // Row 4 (blank)
                
                // Main calculations section with headers
                csv += `Use Case${TAB}Category${TAB}Channel${TAB}Special Group${TAB}Benefit${TAB}Month${TAB}Volume${TAB}Improvement${TAB}Baseline${TAB}Net Improvement${TAB}Effective Cost${TAB}Savings\n`; // Row 5 - Column Headers
                
                // Data starts at row 6
                let currentRow = 6;
                const calcStartRow = currentRow; // Track where calculations start
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            
                            const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                            const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                            const baseline = benefit.baselineValue || 0;
                            const effectiveCost = getEffectiveCost(uc, uc.channel);
                            
                            // Net Improvement formula (Excel will calculate this)
                            const netImprovementFormula = `=MAX(0,H${currentRow}-I${currentRow})`;
                            
                            // Create Excel formula using centralized metric configuration
                            let savingsFormula;
                            const metricConfig = METRIC_CONFIG[benefit.metric];
                            
                            if (!metricConfig) {
                                console.warn(`No configuration found for metric: ${benefit.metric}, using default formula`);
                                savingsFormula = `=G${currentRow}*(J${currentRow}/100)*K${currentRow}`;
                            } else {
                                // Generate formula based on metric type
                                switch (metricConfig.type) {
                                    case 'time_cost': {
                                        const aht = getApplicableAHT(uc) || 10;
                                        const costPerMinute = effectiveCost / aht;
                                        savingsFormula = metricConfig.excelFormula(currentRow, { 
                                            aht: aht.toFixed(2), 
                                            rate: costPerMinute.toFixed(4) 
                                        });
                                        break;
                                    }
                                    
                                    case 'percentage_cost':
                                    case 'fcr_special':
                                        savingsFormula = metricConfig.excelFormula(currentRow);
                                        break;
                                    
                                    case 'points_value':
                                    case 'percentage_value': {
                                        const value = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                        savingsFormula = metricConfig.excelFormula(currentRow, value);
                                        break;
                                    }
                                    
                                    default:
                                        console.warn(`Unknown metric type: ${metricConfig.type}`);
                                        savingsFormula = `=G${currentRow}*(J${currentRow}/100)*K${currentRow}`;
                                }
                            }
                            
                            // Output row with formulas
                            csv += `${uc.name}${TAB}${uc.category}${TAB}${uc.channel}${TAB}${uc.specialGroup || 'None'}${TAB}${benefit.metric}${TAB}${month.month} ${month.year}${TAB}`;
                            csv += `${volume}${TAB}${improvement}${TAB}${baseline}${TAB}${netImprovementFormula}${TAB}${effectiveCost.toFixed(2)}${TAB}${savingsFormula}\n`;
                            currentRow++;
                        });
                    });
                });
                
                const calcEndRow = currentRow - 1;
                
                // SECTION 3: Summary with formulas
                csv += '\n';
                csv += 'SUMMARY\n';
                csv += `Total Savings Across All Use Cases${TAB}=SUM(L${calcStartRow}:L${calcEndRow})\n`;
                csv += `Average Savings per Month${TAB}=AVERAGE(L${calcStartRow}:L${calcEndRow})\n`;
                csv += `Number of Calculations${TAB}=COUNT(L${calcStartRow}:L${calcEndRow})\n`;
                csv += '\n';
                
                // Instructions
                csv += 'INSTRUCTIONS FOR USE\n';
                csv += '1. Save and open this file in Microsoft Excel\n';
                csv += '2. All formulas in columns J (Net Improvement) and L (Savings) are live and will recalculate automatically\n';
                csv += '3. You can modify Volume or Improvement values to see instant updates\n';
                csv += '4. The Effective Cost column shows the actual per-contact cost after all overrides\n';
                csv += '5. Total Savings at the bottom sums all individual savings calculations\n';
                
                // Download the file as .xls for better Excel compatibility
                const blob = new Blob([csv], { type: 'application/vnd.ms-excel' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_calculator_excel_${new Date().toISOString().split('T')[0]}.xls`;
                a.click();
                window.URL.revokeObjectURL(url);
            };
            
            // Deprecated - keeping for backward compatibility only
            const exportToExcelTraceableCSV = () => {
                // This creates a CSV with formula documentation that can be imported to Excel
                // and manually converted to formulas if needed, without maintenance overhead
                let csv = '=== AI ROI CALCULATOR - TRACEABLE EXPORT ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                csv += `Analysis Period: ${dateRange.start} to ${dateRange.end}\n\n`;
                
                // Section 1: Cost Configuration Reference
                csv += '=== COST CONFIGURATION (For Formula Reference) ===\n';
                csv += 'Config Type,Category,Channel,Special Group,Cost Type,Value ($),AHT (min),Priority,Cell Ref\n';
                
                let configRow = 7; // Starting row for config data
                
                // Category costs with cell references (no channel defaults anymore)
                Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        csv += `Category Default,${category},All,,${defaultCost.costType},${defaultCost.value},${defaultCost.ahtMinutes || defaultAHT},3,B${configRow}\n`;
                        configRow++;
                    }
                    
                    Object.entries(categoryData).forEach(([channel, channelData]) => {
                        if (channel !== '_default' && channelData) {
                            if (channelData._default) {
                                csv += `Category-Channel,${category},${channel},,${channelData._default.costType},${channelData._default.value},${channelData._default.ahtMinutes || 10},2,B${configRow}\n`;
                                configRow++;
                            }
                            if (channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    csv += `Special Group,${category},${channel},${group},${groupData.costType},${groupData.value},${groupData.ahtMinutes || 10},1 (Highest),B${configRow}\n`;
                                    configRow++;
                                });
                            }
                        }
                    });
                });
                
                csv += '\n=== CALCULATION DETAILS WITH FORMULA DOCUMENTATION ===\n';
                csv += 'Use Case,Benefit,Month,Volume,Improvement,Baseline,Net Improvement,Effective Cost ($),Formula Used,Calculated Savings ($),Cost Source\n';
                
                useCases.forEach(uc => {
                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                    normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                        months.forEach(month => {
                            const monthData = uc.data[month.id] || {};
                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                ? `volume_${benefit.metric}`
                                : `volume_${benefitIndex}_${benefit.metric}`;
                            const improvementFieldKey = normalizedUC.benefits.length === 1 
                                ? `improvement_${benefit.metric}`
                                : `improvement_${benefitIndex}_${benefit.metric}`;
                            
                            const volume = parseFloat(monthData[volumeFieldKey] || monthData.volume) || 0;
                            const improvement = parseFloat(monthData[improvementFieldKey]) || 0;
                            const netImprovement = Math.max(0, improvement - benefit.baselineValue);
                            const effectiveCost = getEffectiveCost(uc, uc.channel);
                            const savings = calculateBenefitSavings(normalizedUC, benefit, monthData, benefitIndex);
                            const costSource = getCostSourceDescription(uc, uc.channel);
                            
                            // Document the formula using centralized metric configuration
                            let formula = '';
                            const metricConfig = METRIC_CONFIG[benefit.metric];
                            
                            if (!metricConfig) {
                                formula = `${volume} × (${netImprovement}% / 100) × $${effectiveCost.toFixed(2)}`;
                            } else {
                                switch (metricConfig.type) {
                                    case 'time_cost': {
                                        const costPerMin = effectiveCost / (getApplicableAHT(uc) || 10);
                                        const cappedMinutes = Math.min(netImprovement, getApplicableAHT(uc) || 10);
                                        formula = `${volume} × ${cappedMinutes} min × $${costPerMin.toFixed(3)}/min`;
                                        break;
                                    }
                                    case 'percentage_cost':
                                        formula = `${volume} × (${netImprovement}% / 100) × $${effectiveCost.toFixed(2)}`;
                                        break;
                                    case 'fcr_special':
                                        formula = `${volume} × (${netImprovement}% / 100) × $${effectiveCost.toFixed(2)} × ${metricConfig.repeatCallFactor}`;
                                        break;
                                    case 'points_value': {
                                        const value = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                        formula = `${volume} × ${netImprovement} points × $${value}/point`;
                                        break;
                                    }
                                    case 'percentage_value': {
                                        const value = getEffectiveMetricValue(metricConfig.metricKey, uc);
                                        formula = `${volume} × (${netImprovement}% / 100) × $${value}`;
                                        break;
                                    }
                                    default:
                                        formula = `${volume} × (${netImprovement}% / 100) × $${effectiveCost.toFixed(2)}`;
                                }
                            }
                            
                            csv += `"${uc.name}","${benefit.metric}",${month.month} ${month.year},${volume},${improvement},${benefit.baselineValue},${netImprovement},${effectiveCost.toFixed(2)},"${formula}",${savings.toFixed(2)},"${costSource}"\n`;
                        });
                    });
                });
                
                csv += '\n=== SUMMARY BY CATEGORY ===\n';
                csv += 'Category,Total Savings ($),% of Total,Use Case Count\n';
                
                const categoryTotals = {};
                const categoryCounts = {};
                useCases.forEach(uc => {
                    if (!categoryTotals[uc.category]) {
                        categoryTotals[uc.category] = 0;
                        categoryCounts[uc.category] = 0;
                    }
                    categoryCounts[uc.category]++;
                    months.forEach(month => {
                        categoryTotals[uc.category] += calculateSavings(uc, month.id);
                    });
                });
                
                const grandTotal = Object.values(categoryTotals).reduce((sum, val) => sum + val, 0);
                Object.entries(categoryTotals).forEach(([category, total]) => {
                    const percentage = grandTotal > 0 ? ((total / grandTotal) * 100).toFixed(1) : '0';
                    csv += `${category},${total.toFixed(2)},${percentage}%,${categoryCounts[category]}\n`;
                });
                
                csv += `\nGRAND TOTAL,${grandTotal.toFixed(2)},100%,${useCases.length}\n`;
                
                // Add instructions for Excel users
                csv += '\n=== EXCEL CONVERSION INSTRUCTIONS ===\n';
                csv += '"To convert formulas to live Excel formulas:"\n';
                csv += '"1. Import this CSV into Excel"\n';
                csv += '"2. Create named ranges for cost configuration values"\n';
                csv += '"3. Replace formula documentation with actual Excel formulas"\n';
                csv += '"4. Use VLOOKUP or INDEX/MATCH to reference cost configuration"\n';
                csv += '"Example: Convert ""1000 × (70% / 100) × $4.50"" to ""=D2*(E2/100)*VLOOKUP(B2,CostConfig,2,FALSE)"""\n';
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_traceable_export_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const exportToJSON = () => {
                const dataToExport = {
                    categories,
                    channelCosts,
                    categoryCosts,
                    useCases,
                    dateRange,
                    financialSettings,
                    ahtNegotiationMode,
                    // defaultAHT and agentUtilization removed - now in category config
                    metricValues,
                    dataTemplates,
                    exportDate: new Date().toISOString(),
                    version: '4.1',
                    description: 'Multi-benefit AI ROI calculator backup with quality metrics support',
                    features: {
                        multiBenefitSupport: true,
                        qualityMetrics: true,
                        agentUtilization: true,
                        bulkDataEntry: true,
                        categoryChannelHierarchy: true
                    }
                };
                
                const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roi_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const importJSON = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            // Track what was imported for user feedback
                            const importSummary = [];
                            
                            // Import core data
                            if (importedData.channelCosts) {
                                setChannelCosts(importedData.channelCosts);
                                importSummary.push(`${Object.keys(importedData.channelCosts).length} channel costs`);
                            }
                            if (importedData.categoryCosts) {
                                setCategoryCosts(importedData.categoryCosts);
                                importSummary.push(`${Object.keys(importedData.categoryCosts).length} category configurations`);
                                
                                // Sync categories from both sources
                                const importedCategories = importedData.categories || [];
                                const categoriesFromCosts = Object.keys(importedData.categoryCosts);
                                const allCategories = Array.from(new Set([...importedCategories, ...categoriesFromCosts]));
                                setCategories(allCategories);
                                importSummary.push(`${allCategories.length} total categories`);
                            } else if (importedData.categories) {
                                setCategories(importedData.categories);
                                importSummary.push(`${importedData.categories.length} categories`);
                            }
                            if (importedData.useCases) {
                                // Count total benefits in imported use cases
                                const totalBenefits = importedData.useCases.reduce((sum, uc) => {
                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                    return sum + normalizedUC.benefits.length;
                                }, 0);
                                setUseCases(importedData.useCases);
                                importSummary.push(`${importedData.useCases.length} use cases with ${totalBenefits} total benefits`);
                            }
                            if (importedData.dateRange) {
                                setDateRange(importedData.dateRange);
                                setMonths(generateMonthsFromRange(importedData.dateRange.start, importedData.dateRange.end));
                                const monthCount = generateMonthsFromRange(importedData.dateRange.start, importedData.dateRange.end).length;
                                importSummary.push(`${monthCount} months of analysis period`);
                            }
                            // Global defaults removed - configuration at category-channel level
                            if (importedData.metricValues) {
                                setMetricValues(importedData.metricValues);
                                importSummary.push(`${Object.keys(importedData.metricValues).length} quality metric values`);
                            }
                            if (importedData.dataTemplates) {
                                setDataTemplates(importedData.dataTemplates);
                                importSummary.push(`${Object.keys(importedData.dataTemplates).length} data templates`);
                            }
                            if (importedData.financialSettings) {
                                setFinancialSettings(importedData.financialSettings);
                                const hasCategoryBilling = importedData.financialSettings.useCategoryBilling ? 'category-based' : 'global';
                                importSummary.push(`Financial settings (${hasCategoryBilling} billing)`);
                            }
                            if (typeof importedData.ahtNegotiationMode === 'boolean') {
                                setAhtNegotiationMode(importedData.ahtNegotiationMode);
                                if (importedData.ahtNegotiationMode) {
                                    importSummary.push('AHT negotiation mode enabled');
                                }
                            }
                            
                            // Show detailed import summary
                            const version = importedData.version || 'Unknown';
                            const featureInfo = importedData.features ? 
                                `\n\nFeatures: ${Object.entries(importedData.features).filter(([k,v]) => v).map(([k]) => k).join(', ')}` : '';
                            alert(`Data imported successfully!\n\nVersion: ${version}\nImported: ${importSummary.join(', ')}${featureInfo}`);
                        } catch (error) {
                            alert(`Error importing file: ${error.message}\n\nPlease ensure it's a valid JSON backup file from the AI ROI Calculator.`);
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
                // Reset the file input
                event.target.value = '';
            };

            // Export comprehensive cost configuration including quality metrics
            const exportCostConfigurationCSV = () => {
                let csv = '=== AI ROI CALCULATOR COST & VALUE CONFIGURATION EXPORT ===\n';
                csv += `Export Date: ${new Date().toISOString()}\n`;
                // Global defaults removed - configuration at category-channel level
                csv += '\n';
                
                // Quality Metric Values
                csv += '=== QUALITY METRIC VALUES ===\n';
                csv += 'Metric Name,Dollar Value (USD),Unit,Description,Usage\n';
                Object.entries(metricValues).forEach(([key, config]) => {
                    let usage = '';
                    switch(key) {
                        case 'npsImprovement': usage = 'Multiply by NPS points improved'; break;
                        case 'csatImprovement': usage = 'Multiply by CSAT percentage improved'; break;
                        case 'fcrImprovement': usage = 'Multiply by FCR percentage improved'; break;
                        case 'conversionRate': usage = 'Average deal value for conversion improvements'; break;
                        case 'agentRetention': usage = 'Cost to replace one agent'; break;
                        case 'complianceRate': usage = 'Cost per compliance violation avoided'; break;
                        default: usage = 'Per unit improvement value';
                    }
                    csv += `"${config.label}",${config.value},USD,"Quality improvement monetary value","${usage}"\n`;
                });
                
                // Channel Costs
                csv += '\n=== CHANNEL DEFAULT COSTS ===\n';
                csv += 'Channel,Cost Type,Value (USD),AHT (min),Effective $/Contact,Priority Level,Calculation Formula\n';
                Object.entries(channelCosts).forEach(([channel, costData]) => {
                    const normalized = typeof costData === 'object' ? costData : { costType: 'perContact', value: costData, ahtMinutes: defaultAHT };
                    let effectiveCost = normalized.value;
                    let formula = 'Direct per-contact cost';
                    
                    if (normalized.costType === 'hourly') {
                        const aht = normalized.ahtMinutes || defaultAHT;
                        const utilization = normalized.utilization || 75;
                        effectiveCost = (normalized.value * aht / 60) * (100 / utilization);
                        formula = `(Hourly_Rate × AHT_Minutes / 60) × (100 / Agent_Utilization%)`;
                    }
                    
                    csv += `${channel},${normalized.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${normalized.value},${normalized.ahtMinutes || defaultAHT},${effectiveCost.toFixed(2)},4 (Lowest),"${formula}"\n`;
                });
                
                // Category Costs with detailed hierarchy
                csv += '\n=== CATEGORY COST HIERARCHY ===\n';
                csv += 'Category,Channel,Special Group,Cost Type,Value,AHT (min),Priority Level,Scope\n';
                
                Object.entries(categoryCosts).forEach(([category, categoryData]) => {
                    // Category defaults
                    const defaultCost = categoryData._default || categoryData;
                    if (defaultCost && defaultCost.costType) {
                        const aht = typeof defaultCost.ahtMinutes === 'number' ? defaultCost.ahtMinutes : 10;
                        csv += `${category},All Channels,,${defaultCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${defaultCost.value},${aht},3 (Medium),Category default for all channels\n`;
                    }
                    
                    // Category-Channel specifics
                    Object.entries(categoryData).forEach(([channel, channelData]) => {
                        if (channel !== '_default' && channelData && channelData._default) {
                            const channelCost = channelData._default;
                            const aht = typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : 10;
                            csv += `${category},${channel},,${channelCost.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${channelCost.value},${aht},2 (High),Category-channel specific\n`;
                            
                            // Special groups
                            if (channelData._specialGroups) {
                                Object.entries(channelData._specialGroups).forEach(([group, groupData]) => {
                                    const aht = typeof groupData.ahtMinutes === 'number' ? groupData.ahtMinutes : 10;
                                    csv += `${category},${channel},${group},${groupData.costType === 'hourly' ? 'Hourly' : 'Per Contact'},${groupData.value},${aht},1 (Highest),Special group override\n`;
                                });
                            }
                        }
                    });
                });
                
                // Cost Calculation Examples
                csv += '\n=== COST CALCULATION EXAMPLES ===\n';
                csv += 'Scenario,Formula,Example Calculation,Result\n';
                csv += 'Hourly Rate Cost per Contact,"(Hourly Rate × AHT) / 60","($30/hr × 8 min) / 60","$4.00 per contact"\n';
                csv += 'Hourly Rate Cost per Minute,"Hourly Rate / 60","$30/hr / 60","$0.50 per minute"\n';
                csv += 'Deflection Savings,"Volume × (Rate% - Baseline%) × Cost","1000 × (70% - 10%) × $4.00","$2,400"\n';
                csv += 'NPS Value,"Volume × Points × Value per Point","1000 × 2 points × $50","$100,000"\n';
                csv += 'CSAT Value,"Volume × (Rate% - Baseline%) × Value per Point","1000 × (85% - 75%) × $25","$2,500"\n';
                
                // Configuration Summary
                csv += '\n=== CONFIGURATION SUMMARY ===\n';
                csv += 'Setting,Value,Impact\n';
                csv += `Total Channels,${Object.keys(channelCosts).length},Base cost options\n`;
                csv += `Total Categories,${Object.keys(categoryCosts).length},Category-specific overrides\n`;
                
                // Count special groups
                let totalSpecialGroups = 0;
                Object.values(categoryCosts).forEach(categoryData => {
                    Object.values(categoryData).forEach(channelData => {
                        if (channelData && channelData._specialGroups) {
                            totalSpecialGroups += Object.keys(channelData._specialGroups).length;
                        }
                    });
                });
                csv += `Total Special Groups,${totalSpecialGroups},Highest priority overrides\n`;
                csv += `Quality Metrics,${Object.keys(metricValues).length},Non-cost value drivers\n`;
                
                // Priority explanation
                csv += '\n=== COST PRIORITY EXPLANATION ===\n';
                csv += 'Priority,Source,Description,When Used\n';
                csv += '1 (Highest),Special Group,Agent group-specific costs,When use case has special group assigned\n';
                csv += '2 (High),Category-Channel,Category and channel specific,When category has channel-specific cost\n';
                csv += '3 (Medium),Category Default,Category fallback cost,When category exists but no channel override\n';
                csv += '4 (Lowest),Channel Default,Base channel cost,When no category overrides exist\n';
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cost_configuration_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
            };

            const clearAllDataAndReset = () => {
                if (window.confirm('Clear all data? This cannot be undone.')) {
                    localStorage.removeItem('aiValueCalculatorData');
                    window.location.reload();
                }
            };

            // Guidance Modal Component
            const GuidanceModal = () => {
                if (!showGuidanceModal || !selectedMetricGuide) return null;
                
                const guide = InputGuidance[selectedMetricGuide];
                if (!guide) return null;
                
                return (
                    <div className="modal-overlay" onClick={() => setShowGuidanceModal(false)}>
                        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                            <div className="modal-close" onClick={() => setShowGuidanceModal(false)}>
                                <Icons.Close />
                            </div>
                            
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">
                                Input Guide: {selectedMetricGuide}
                            </h2>
                            
                            <div className="space-y-4">
                                {/* Calculation Formula */}
                                {guide.improvement && guide.improvement.formula && (
                                    <div className="guidance-card" style={{borderLeftColor: '#10B981', backgroundColor: '#F0FDF4'}}>
                                        <div className="guidance-title">🧮 How ROI is Calculated</div>
                                        <div className="guidance-content">
                                            <div className="example-box" style={{backgroundColor: '#DCFCE7'}}>
                                                <strong>Formula:</strong> {guide.improvement.formula}
                                            </div>
                                            {selectedMetricGuide && selectedMetricGuide.includes('FCR') && (
                                                <p className="text-sm mt-2 text-green-700">
                                                    FCR improvements prevent repeat calls, saving contact handling costs
                                                </p>
                                            )}
                                            {selectedMetricGuide && selectedMetricGuide.includes('NPS') && (
                                                <p className="text-sm mt-2 text-blue-700">
                                                    NPS improvements increase customer lifetime value and reduce churn
                                                </p>
                                            )}
                                            {selectedMetricGuide && selectedMetricGuide.includes('CSAT') && (
                                                <p className="text-sm mt-2 text-purple-700">
                                                    CSAT improvements drive retention and positive word-of-mouth
                                                </p>
                                            )}
                                            {guide.improvement.dollarConversion && (
                                                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                    <p className="text-sm text-yellow-800">
                                                        {guide.improvement.dollarConversion}
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Volume Warning */}
                                {guide.volume && (guide.volume.warning || guide.volume.note) && (
                                    <div className="guidance-card" style={{borderLeftColor: guide.volume.warning ? '#FBbD23' : '#3B82F6'}}>
                                        <div className="guidance-content">
                                            {guide.volume.warning && (
                                                <div className="p-3 bg-yellow-50 border border-yellow-200 rounded">
                                                    {guide.volume.warning}
                                                </div>
                                            )}
                                            {guide.volume.note && (
                                                <div className="p-3 bg-blue-50 border border-blue-200 rounded mt-2">
                                                    {guide.volume.note}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">📊 Baseline Value</div>
                                    <div className="guidance-content">
                                        <p>{guide.baseline.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.baseline.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.baseline.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">📈 Volume Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.volume.description}</p>
                                        <div className="example-box">
                                            <strong>Calculation:</strong> {guide.volume.calculation}
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.volume.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">✅ Improvement Input</div>
                                    <div className="guidance-content">
                                        <p>{guide.improvement.description}</p>
                                        <div className="metric-guide">
                                            <div className="metric-item">
                                                <div className="metric-label">Typical Range</div>
                                                <div className="metric-value">{guide.improvement.typical}</div>
                                            </div>
                                        </div>
                                        <div className="example-box">
                                            <strong>Example:</strong> {guide.improvement.example}
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="guidance-card">
                                    <div className="guidance-title">🏆 Industry Benchmarks</div>
                                    <div className="guidance-content">
                                        <div className="grid grid-cols-2 gap-3">
                                            {Object.entries(guide.industryBenchmarks).map(([useCase, benchmark]) => (
                                                <div key={useCase} className="metric-item">
                                                    <div className="metric-label">{useCase}</div>
                                                    <div className="metric-value">{benchmark}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className={`min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 ${isMobile ? 'p-0' : 'p-2 lg:p-4'}`}>
                    {/* Sponsor Overlay */}
                    {showSponsorOverlay && (
                        <div className={`sponsor-overlay ${isClosingWithHearts ? 'closing' : ''}`} 
                             onClick={() => setShowSponsorOverlay(false)}
                             id="sponsor-overlay">
                            <div className="sponsor-content" onClick={(e) => e.stopPropagation()}>
                                <div className="heart-icon">
                                    <svg className="w-24 h-24 mx-auto mb-6" fill="currentColor" viewBox="0 0 20 20">
                                        <path fillRule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clipRule="evenodd" />
                                    </svg>
                                </div>
                                <h2 className="text-3xl font-bold mb-4">Thank You for Supporting!</h2>
                                <p className="text-lg mb-6 opacity-90">
                                    Your sponsorship helps keep this ROI Calculator free and continuously improved.
                                    Every contribution enables new features and better analytics.
                                </p>
                                <div className="flex gap-4 justify-center">
                                    <a
                                        href="https://github.com/sponsors/Maniwar"
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="px-6 py-3 bg-white text-purple-600 rounded-lg font-semibold hover:bg-gray-100 transition-colors"
                                        onClick={() => setShowSponsorOverlay(false)}
                                    >
                                        Continue to GitHub Sponsors →
                                    </a>
                                    <button
                                        onClick={() => {
                                            // Create floating hearts
                                            const overlay = document.getElementById('sponsor-overlay');
                                            for (let i = 0; i < 8; i++) {
                                                setTimeout(() => {
                                                    const heart = document.createElement('div');
                                                    heart.className = 'floating-heart';
                                                    heart.style.left = `${Math.random() * 100}%`;
                                                    heart.style.top = `${50 + Math.random() * 30}%`;
                                                    heart.style.setProperty('--float-x', `${(Math.random() - 0.5) * 100}px`);
                                                    heart.style.fontSize = `${20 + Math.random() * 30}px`;
                                                    heart.innerHTML = '♥';
                                                    overlay.appendChild(heart);
                                                }, i * 100);
                                            }
                                            
                                            // Start fade out animation
                                            setIsClosingWithHearts(true);
                                            setTimeout(() => {
                                                setShowSponsorOverlay(false);
                                                setIsClosingWithHearts(false);
                                            }, 800);
                                        }}
                                        className="px-6 py-3 bg-transparent border-2 border-white text-white rounded-lg font-semibold hover:bg-white hover:bg-opacity-10 transition-colors"
                                    >
                                        Maybe Later
                                    </button>
                                </div>
                                <p className="text-sm mt-6 opacity-75">
                                    Join other businesses saving millions with data-driven ROI insights
                                </p>
                            </div>
                        </div>
                    )}
                    
                    <div className="w-full px-2 lg:px-4">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-3 mb-3">
                            <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex justify-between items-center'} mb-4`}>
                                <div>
                                    <h1 className={`${isMobile ? 'text-2xl' : 'text-3xl'} font-bold flex items-center gap-3`}>
                                        <span className="logo-animated">
                                            <svg width={isMobile ? "30" : "40"} height={isMobile ? "30" : "40"} viewBox="0 0 40 40" className="logo-rotate">
                                                <defs>
                                                    <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                        <stop offset="0%" stopColor="#3B82F6" />
                                                        <stop offset="50%" stopColor="#8B5CF6" />
                                                        <stop offset="100%" stopColor="#EC4899" />
                                                    </linearGradient>
                                                </defs>
                                                <circle cx="20" cy="20" r="18" fill="none" stroke="url(#logoGradient)" strokeWidth="2" strokeDasharray="5 2" />
                                                <circle cx="20" cy="12" r="3" fill="url(#logoGradient)" />
                                                <circle cx="13" cy="23" r="3" fill="url(#logoGradient)" />
                                                <circle cx="27" cy="23" r="3" fill="url(#logoGradient)" />
                                                <path d="M20 12 L13 23 L27 23 Z" fill="none" stroke="url(#logoGradient)" strokeWidth="1.5" />
                                                <circle cx="20" cy="20" r="2" fill="url(#logoGradient)" opacity="0.8">
                                                    <animate attributeName="r" values="2;4;2" dur="2s" repeatCount="indefinite" />
                                                    <animate attributeName="opacity" values="0.8;0.3;0.8" dur="2s" repeatCount="indefinite" />
                                                </circle>
                                            </svg>
                                        </span>
                                        <span className="title-gradient">{isMobile ? 'AI ROI Calculator' : 'AI Contact Center ROI Calculator'}</span>
                                    </h1>
                                    <p className={`text-gray-600 mt-2 flex items-center gap-2 ${isMobile ? 'text-sm' : ''}`}>
                                        <span className="inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                                        {isMobile ? 'Advanced cost modeling' : 'Advanced cost modeling with category and group pricing'}
                                    </p>
                                    {showSaveIndicator && (
                                        <p className="text-green-600 text-sm mt-1 flex items-center gap-1">
                                            <Icons.Save /> Auto-saved
                                        </p>
                                    )}
                                </div>
                                <div className={`${isMobile ? 'grid grid-cols-2 gap-2 w-full' : 'flex gap-3'} no-print`}>
                                    <button
                                        onClick={() => setShowSettings(!showSettings)}
                                        className={`flex items-center ${isMobile ? 'justify-center px-3 py-1.5' : 'px-4 py-2'} gap-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700`}
                                    >
                                        <Icons.Settings /> <span className={isMobile ? 'text-xs' : ''}>Cost Settings</span>
                                    </button>
                                    <button
                                        onClick={clearAllDataAndReset}
                                        className={`flex items-center ${isMobile ? 'justify-center px-3 py-1.5' : 'px-4 py-2'} gap-2 bg-red-600 text-white rounded-lg hover:bg-red-700`}
                                    >
                                        <Icons.Clear /> <span className={isMobile ? 'text-xs' : ''}>Clear All</span>
                                    </button>
                                </div>
                            </div>
                            
                            {/* Tabs */}
                            <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex gap-2 justify-between items-center'} mb-4`}>
                                <div className={`${isMobile ? 'tab-container' : 'flex gap-2'}`}>
                                    <button
                                        onClick={() => setActiveTab('data')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'data' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Data Entry
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('analytics')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'analytics' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Analytics & Reports
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('financial')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'financial' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Financial Analysis
                                    </button>
                                    <button
                                        onClick={() => setActiveTab('guidance')}
                                        className={`px-4 py-2 rounded-lg ${activeTab === 'guidance' ? 'tab-active' : 'tab-inactive'}`}
                                    >
                                        Input Guidance
                                    </button>
                                </div>
                                {!isMobile && (
                                    <button
                                        onClick={() => setShowSponsorOverlay(true)}
                                        className="flex items-center gap-1 px-3 py-1.5 text-sm bg-gradient-to-r from-pink-500 to-purple-600 text-white rounded-lg hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-sm"
                                        title="Support this free tool with GitHub Sponsors"
                                    >
                                        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clipRule="evenodd" />
                                        </svg>
                                        <span>Sponsor</span>
                                    </button>
                                )}
                            </div>
                            
                            {/* Action Buttons */}
                            {activeTab === 'data' && (
                                <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-3 items-center'}`}>
                                    <button
                                        onClick={exportToCSV}
                                        className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                                        title="Export raw data as CSV for further analysis"
                                    >
                                        <Icons.Download /> Export CSV
                                    </button>
                                    <button
                                        onClick={exportToExcel}
                                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        title="Export to Excel with live formulas - all calculations are automatic and traceable!"
                                    >
                                        <Icons.Chart /> Export to Excel
                                    </button>
                                    <button
                                        onClick={exportToJSON}
                                        className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                                        title="Export complete backup including all data, settings, and use cases (JSON format, importable)"
                                    >
                                        <Icons.FileText /> Full Backup (JSON)
                                    </button>
                                    <button
                                        onClick={exportCostConfigurationCSV}
                                        className="flex items-center gap-2 px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700"
                                        title="Export cost configuration report for documentation (CSV format, read-only)"
                                    >
                                        <Icons.Settings /> Config Report (CSV)
                                    </button>
                                    <button
                                        onClick={() => fileInputRef.current.click()}
                                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                                        title="Import a previously exported JSON backup file"
                                    >
                                        <Icons.Upload /> Import Backup
                                    </button>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept=".json"
                                        onChange={importJSON}
                                        style={{ display: 'none' }}
                                    />
                                </div>
                            )}
                            
                            {/* Summary Cards with Date Range */}
                            <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex gap-4'} mt-4`}>
                                {/* Stats Cards */}
                                <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'grid grid-cols-4 gap-4'} flex-1`}>
                                    <div className="bg-blue-50 rounded-lg p-4">
                                        <p className="text-blue-600 text-sm">Use Cases</p>
                                        <p className="text-2xl font-bold">{useCases.length}</p>
                                    </div>
                                    <div className="bg-green-50 rounded-lg p-4">
                                        <p className="text-green-600 text-sm">Months</p>
                                        <p className="text-2xl font-bold">{months.length}</p>
                                    </div>
                                    <div className="bg-purple-50 rounded-lg p-4">
                                        <p className="text-purple-600 text-sm">Monthly Avg</p>
                                        <p className="text-2xl font-bold">
                                            ${months.length > 0 ? Math.round(calculateTotalSavings() / months.length).toLocaleString() : 0}
                                        </p>
                                    </div>
                                    <div className="bg-yellow-50 rounded-lg p-4">
                                        <p className="text-yellow-600 text-sm">Total Savings</p>
                                        <p className="text-2xl font-bold">
                                            ${Math.round(calculateTotalSavings()).toLocaleString()}
                                        </p>
                                    </div>
                                </div>
                                
                                {/* Date Range Selector */}
                                <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-2'} bg-gray-50 rounded-lg p-4`}>
                                    <div className="flex items-center gap-2">
                                        <Icons.Calendar className="text-gray-500" />
                                        <span className="text-sm font-medium text-gray-700">Date Range</span>
                                    </div>
                                    <div className={`${isMobile ? 'flex flex-col gap-2 w-full' : 'flex items-center gap-2'}`}>
                                        <input
                                            type="month"
                                            value={dateRange.start}
                                            onChange={(e) => setDateRange({ ...dateRange, start: e.target.value })}
                                            className={`px-2 py-1 text-sm border rounded bg-white ${isMobile ? 'w-full' : ''}`}
                                            title="Start Month"
                                        />
                                        <span className={`text-sm text-gray-500 ${isMobile ? 'text-center' : ''}`}>to</span>
                                        <input
                                            type="month"
                                            value={dateRange.end}
                                            onChange={(e) => setDateRange({ ...dateRange, end: e.target.value })}
                                            className={`px-2 py-1 text-sm border rounded bg-white ${isMobile ? 'w-full' : ''}`}
                                            title="End Month"
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Advanced Settings Panel */}
                        {showSettings && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Advanced Settings</h2>
                                {/* Global defaults removed - all configuration at category level including quality metrics */}
                                
                                {/* Category Manager */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Plus /> Manage Categories
                                    </h3>
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>📁 Categories:</strong> Add, edit, or remove business categories. Categories organize your use cases and cost configurations.
                                    </div>
                                    
                                    <div className="space-y-3">
                                        {/* Add new category */}
                                        <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex gap-2'}`}>
                                            <input
                                                type="text"
                                                value={newCategoryName}
                                                onChange={(e) => setNewCategoryName(e.target.value)}
                                                placeholder="Enter new category name..."
                                                className="flex-1 px-3 py-2 border rounded"
                                                onKeyPress={(e) => {
                                                    if (e.key === 'Enter' && newCategoryName.trim()) {
                                                        addCategory(newCategoryName.trim());
                                                        setNewCategoryName('');
                                                    }
                                                }}
                                            />
                                            <button
                                                onClick={() => {
                                                    if (newCategoryName.trim()) {
                                                        addCategory(newCategoryName.trim());
                                                        setNewCategoryName('');
                                                    }
                                                }}
                                                className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                            >
                                                <Icons.Plus /> Add Category
                                            </button>
                                        </div>
                                        
                                        {/* List existing categories */}
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-2 gap-2'}`}>
                                            {categories.map(category => (
                                                <div key={category} className="flex items-center justify-between p-2 bg-white border rounded">
                                                    {editingCategory === category ? (
                                                        <input
                                                            type="text"
                                                            defaultValue={category}
                                                            className="flex-1 px-2 py-1 border rounded mr-2"
                                                            autoFocus
                                                            onBlur={(e) => {
                                                                if (e.target.value.trim() && e.target.value !== category) {
                                                                    editCategory(category, e.target.value.trim());
                                                                }
                                                                setEditingCategory(null);
                                                            }}
                                                            onKeyPress={(e) => {
                                                                if (e.key === 'Enter') {
                                                                    if (e.target.value.trim() && e.target.value !== category) {
                                                                        editCategory(category, e.target.value.trim());
                                                                    }
                                                                    setEditingCategory(null);
                                                                }
                                                            }}
                                                        />
                                                    ) : (
                                                        <>
                                                            <span className="font-medium">{category}</span>
                                                            <div className="flex gap-1">
                                                                <button
                                                                    onClick={() => setEditingCategory(category)}
                                                                    className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                                                                    title="Edit category"
                                                                >
                                                                    ✏️
                                                                </button>
                                                                <button
                                                                    onClick={() => removeCategory(category)}
                                                                    className="p-1 text-red-600 hover:bg-red-50 rounded"
                                                                    title="Delete category"
                                                                >
                                                                    🗑️
                                                                </button>
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                        
                                        {categories.length === 0 && (
                                            <div className="text-gray-500 italic">No categories defined. Add your first category above.</div>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Category-Specific Metric Values */}
                                <div className="settings-section">
                                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                                        <Icons.Chart /> Category-Specific Metric Values
                                    </h3>
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>💡 Category Metric Values:</strong> Set NPS values, agent retention costs, etc. for each category.
                                        These values are required for quality metric calculations to work.
                                    </div>
                                    
                                    {categories.length === 0 ? (
                                        <div className="text-gray-500 italic">No categories defined. Add categories above to configure metric values.</div>
                                    ) : (
                                        <div className="space-y-4">
                                            {categories.map(category => (
                                                <div key={category} className="border rounded-lg p-4">
                                                    <h4 className="font-medium mb-3 text-blue-700 text-sm">{category}</h4>
                                                    <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-2 gap-4'}`}>
                                                        {Object.entries(METRIC_DEFINITIONS).map(([key, def]) => {
                                                            const categoryMetricValue = categoryCosts[category]?.metricValues?.[key];
                                                            return (
                                                                <div key={key} className="flex items-center gap-2">
                                                                    <label className="text-xs flex-1">{def.label}:</label>
                                                                    <input
                                                                        type="number"
                                                                        placeholder="Required"
                                                                        value={categoryMetricValue?.value || ''}
                                                                        onChange={(e) => {
                                                                            const newValue = e.target.value ? parseFloat(e.target.value) : 0;
                                                                            setCategoryCosts(prev => ({
                                                                                ...prev,
                                                                                [category]: {
                                                                                    ...prev[category],
                                                                                    metricValues: {
                                                                                        ...(prev[category]?.metricValues || {}),
                                                                                        [key]: { ...def, value: newValue }
                                                                                    }
                                                                                }
                                                                            }));
                                                                        }}
                                                                        className="settings-input w-28"
                                                                        step="0.01"
                                                                        min="0"
                                                                    />
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Category-Channel Cost Matrix */}
                                <div className="settings-section">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Category-Channel Cost Matrix (overrides channel defaults)
                                        </h3>
                                        {needsMigration() && (
                                            <button
                                                onClick={migrateCategoryCosts}
                                                className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                                            >
                                                Migrate to New Structure
                                            </button>
                                        )}
                                    </div>
                                    
                                    <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                        <strong>💡 Cost Configuration:</strong> Set different costs for each category-channel combination.
                                        <div className="mt-2">
                                            <strong>Blue checkmarks (✓):</strong> Indicate channels that have active use cases in that category. This helps you see which configurations are actually being used.
                                        </div>
                                        <div className="mt-2">
                                            <strong>For Hourly Costs:</strong>
                                            <ul className="ml-4 mt-1">
                                                <li>• <strong>AHT (Average Handle Time):</strong> Minutes per contact</li>
                                                <li>• <strong>Utilization %:</strong> Agent productive time (typically 60-85%)</li>
                                                <li>• <strong>Formula:</strong> (Hourly Rate × AHT ÷ 60) × (100 ÷ Utilization%)</li>
                                                <li>• <strong>Example:</strong> $30/hr × 10min ÷ 60 × (100÷75%) = $6.67/contact</li>
                                            </ul>
                                        </div>
                                        <div className="mt-2">
                                            <strong>For Per-Contact Costs:</strong> Fixed cost per interaction (utilization not applicable)
                                        </div>
                                    </div>
                                    
                                    {Object.keys(categoryCosts).length === 0 ? (
                                        <div className="text-gray-500 italic">No categories configured. Add use cases to see category cost options.</div>
                                    ) : (
                                        <div className="space-y-6">
                                            {Object.entries(categoryCosts).map(([category, categoryData]) => {
                                                const isNewFormat = categoryData._default || Object.keys(categoryData).some(key => !['costType', 'value', 'ahtMinutes'].includes(key));
                                                const defaultCost = isNewFormat ? (categoryData._default || {}) : categoryData;
                                                const channels = getUniqueChannels();
                                                
                                                return (
                                                    <div key={category} className="border rounded-lg p-4 bg-gray-50">
                                                        <h4 className="font-semibold text-lg mb-3">{category}</h4>
                                                        
                                                        {/* Channel-Specific Costs - Now Required for Each Category */}
                                                        <div className="space-y-2">
                                                            <h5 className="font-medium text-sm text-gray-700">Channel Costs for {category}:</h5>
                                                            {channels.map(channel => {
                                                                // Get channel cost from category configuration
                                                                const channelSpecificData = categoryData[channel];
                                                                
                                                                // Use category-channel cost if exists, otherwise default empty
                                                                const channelCost = (channelSpecificData && typeof channelSpecificData === 'object') 
                                                                    ? channelSpecificData 
                                                                    : { costType: 'perContact', value: 0, ahtMinutes: 10 };
                                                                    
                                                                const hasUseCases = useCases.some(uc => uc.channel === channel && uc.category === category);
                                                                const isOverride = channelSpecificData && typeof channelSpecificData === 'object';
                                                                
                                                                return (
                                                                    <div key={channel} className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-3'} p-2 bg-white rounded border`}>
                                                                        <span className={`${isMobile ? 'text-xs' : 'w-20 text-sm'} font-medium ${hasUseCases ? 'text-blue-600' : 'text-gray-500'}`} 
                                                                              title={hasUseCases ? 'This channel has active use cases in this category' : 'No use cases for this channel in this category'}>
                                                                            {getChannelConfig(channel).label}{hasUseCases ? ' ✓' : ''}:
                                                                        </span>
                                                                        
                                                                        {(
                                                                            <div className={`${isMobile ? 'w-full space-y-2' : 'flex items-center gap-2 flex-1'}`}>
                                                                                <div className="cost-type-toggle">
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'perContact' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/contact
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, costType: 'hourly' } }
                                                                                        })}
                                                                                        className={`cost-type-btn text-xs ${channelCost.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                    >
                                                                                        $/hr
                                                                                    </button>
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-blue-600 font-medium">💰</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={channelCost.value || 0}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, value: parseFloat(e.target.value) || 0 } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-20'}`}
                                                                                        step="0.01"
                                                                                        placeholder="Cost"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-green-600 font-medium">⏱️</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={typeof channelCost.ahtMinutes === 'number' ? channelCost.ahtMinutes : 10}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, ahtMinutes: Math.max(0, parseFloat(e.target.value) || 0) } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-16'}`}
                                                                                        step="0.1"
                                                                                        placeholder="AHT min"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex items-center gap-1">
                                                                                    <span className="text-xs text-blue-600 font-medium" title="Agent Utilization %">Util:</span>
                                                                                    <input
                                                                                        type="number"
                                                                                        value={typeof channelCost.utilization === 'number' ? channelCost.utilization : 75}
                                                                                        onChange={(e) => setCategoryCosts({
                                                                                            ...categoryCosts,
                                                                                            [category]: { ...categoryData, [channel]: { ...channelCost, utilization: Math.max(0, Math.min(100, parseFloat(e.target.value) || 75)) } }
                                                                                        })}
                                                                                        className={`settings-input text-xs ${isMobile ? 'flex-1' : 'w-16'}`}
                                                                                        step="1"
                                                                                        placeholder="75"
                                                                                        title="Agent Utilization % (only affects hourly costs)"
                                                                                        min="0"
                                                                                        max="100"
                                                                                    />
                                                                                    <span className="text-xs text-gray-500">%</span>
                                                                                </div>
                                                                                <div className="text-xs text-gray-600">
                                                                                    {channelCost.costType === 'hourly' ? (
                                                                                        <span title="Effective cost calculation for hourly rate">
                                                                                            ${channelCost.value}/hr × {channelCost.ahtMinutes || 10}min ÷ 60 × {(100/(channelCost.utilization || 75)).toFixed(2)} = 
                                                                                            <strong> ${((channelCost.value * (channelCost.ahtMinutes || 10) / 60) * (100/(channelCost.utilization || 75))).toFixed(2)}/contact</strong>
                                                                                        </span>
                                                                                    ) : (
                                                                                        <span>${channelCost.value}/contact (utilization N/A)</span>
                                                                                    )}
                                                                                </div>
                                                                                <button
                                                                                    onClick={() => removeChannelCostFromCategory(category, channel)}
                                                                                    className="px-2 py-1 text-xs bg-red-100 text-red-600 rounded hover:bg-red-200"
                                                                                >
                                                                                    Remove
                                                                                </button>
                                                                                
                                                                                {/* Special Groups for this Category-Channel */}
                                                                                <div className="mt-3 pl-4 border-l-2 border-blue-200">
                                                                                    <div className="text-xs font-medium text-gray-600 mb-2">Special Groups:</div>
                                                                                    {channelCost._specialGroups && Object.entries(channelCost._specialGroups).map(([groupName, groupData]) => (
                                                                                        <div key={groupName} className="mb-2 bg-gray-50 p-2 rounded">
                                                                                            <div className="flex items-center gap-2 mb-1">
                                                                                                <span className="text-xs font-medium">{groupName}:</span>
                                                                                                <button
                                                                                                    onClick={() => {
                                                                                                        const newSpecialGroups = { ...channelCost._specialGroups };
                                                                                                        delete newSpecialGroups[groupName];
                                                                                                        setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: newSpecialGroups
                                                                                                                }
                                                                                                            }
                                                                                                        });
                                                                                                    }}
                                                                                                    className="text-xs text-red-600 hover:text-red-800 ml-auto"
                                                                                                >
                                                                                                    ✕
                                                                                                </button>
                                                                                            </div>
                                                                                            <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-2'}`}>
                                                                                                <div className="cost-type-toggle">
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'perContact' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'perContact' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/contact
                                                                                                    </button>
                                                                                                    <button
                                                                                                        onClick={() => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, costType: 'hourly' }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className={`cost-type-btn text-xs ${groupData.costType === 'hourly' ? 'cost-type-btn-active' : 'cost-type-btn-inactive'}`}
                                                                                                    >
                                                                                                        $/hr
                                                                                                    </button>
                                                                                                </div>
                                                                                                <div className={`flex items-center gap-1 ${isMobile ? 'w-full' : ''}`}>
                                                                                                    <span className="text-xs text-blue-600 font-medium" title="Cost Value">💰</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.value || 0}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, value: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input flex-1 min-w-0 text-xs"
                                                                                                        step="0.01"
                                                                                                        placeholder="Cost"
                                                                                                        title="Cost Value"
                                                                                                    />
                                                                                                </div>
                                                                                                <div className={`flex items-center gap-1 ${isMobile ? 'w-full' : ''}`}>
                                                                                                    <span className="text-xs text-green-600 font-medium" title="AHT (minutes)">⏱️</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.ahtMinutes || 10}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, ahtMinutes: parseFloat(e.target.value) || 0 }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-14 text-xs"
                                                                                                        step="0.1"
                                                                                                        placeholder="AHT"
                                                                                                        title="Average Handle Time (minutes)"
                                                                                                    />
                                                                                                    <span className="text-xs text-gray-500">min</span>
                                                                                                </div>
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <span className="text-xs text-blue-600 font-medium" title="Agent Utilization %">Util:</span>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        value={groupData.utilization || 75}
                                                                                                        onChange={(e) => setCategoryCosts({
                                                                                                            ...categoryCosts,
                                                                                                            [category]: {
                                                                                                                ...categoryData,
                                                                                                                [channel]: {
                                                                                                                    ...channelCost,
                                                                                                                    _specialGroups: {
                                                                                                                        ...channelCost._specialGroups,
                                                                                                                        [groupName]: { ...groupData, utilization: Math.max(0, Math.min(100, parseFloat(e.target.value) || 75)) }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        })}
                                                                                                        className="settings-input w-14 text-xs"
                                                                                                        step="1"
                                                                                                        placeholder="75"
                                                                                                        title="Agent Utilization % (only affects hourly costs)"
                                                                                                        min="0"
                                                                                                        max="100"
                                                                                                    />
                                                                                                    <span className="text-xs text-gray-500">%</span>
                                                                                                </div>
                                                                                                <div className="text-xs text-gray-600 col-span-2">
                                                                                                    {groupData.costType === 'hourly' ? (
                                                                                                        <span title="Effective cost calculation for hourly rate">
                                                                                                            ${groupData.value}/hr × {groupData.ahtMinutes || 10}min ÷ 60 × {(100/(groupData.utilization || 75)).toFixed(2)} = 
                                                                                                            <strong> ${((groupData.value * (groupData.ahtMinutes || 10) / 60) * (100/(groupData.utilization || 75))).toFixed(2)}/contact</strong>
                                                                                                        </span>
                                                                                                    ) : (
                                                                                                        <span>${groupData.value}/contact (utilization N/A)</span>
                                                                                                    )}
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    ))}
                                                                                    <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-2'}`}>
                                                                                        <input
                                                                                            type="text"
                                                                                            placeholder="Group name"
                                                                                            className={`settings-input ${isMobile ? 'w-full' : 'w-24'} text-xs`}
                                                                                            id={`newGroup-${category}-${channel}`}
                                                                                        />
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                const input = document.getElementById(`newGroup-${category}-${channel}`);
                                                                                                const groupName = input.value.trim();
                                                                                                if (groupName) {
                                                                                                    setCategoryCosts({
                                                                                                        ...categoryCosts,
                                                                                                        [category]: {
                                                                                                            ...categoryData,
                                                                                                            [channel]: {
                                                                                                                ...channelCost,
                                                                                                                _specialGroups: {
                                                                                                                    ...(channelCost._specialGroups || {}),
                                                                                                                    [groupName]: {
                                                                                                                        costType: channelCost.costType || 'perContact',
                                                                                                                        value: channelCost.value || 0,
                                                                                                                        ahtMinutes: channelCost.ahtMinutes || 10,
                                                                                                                        utilization: channelCost.utilization || 75
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    });
                                                                                                    input.value = '';
                                                                                                }
                                                                                            }}
                                                                                            className={`${isMobile ? 'w-full px-3 py-2' : 'px-2 py-1'} text-xs bg-blue-100 text-blue-600 rounded hover:bg-blue-200`}
                                                                                        >
                                                                                            + Add Group
                                                                                        </button>
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                        
                        {/* Data Entry Tab */}
                        {activeTab === 'data' && (
                            <>
                                {/* Templates Panel - Conditionally Rendered */}
                                {showTemplates && (
                                <div className="bg-white rounded-lg shadow-lg p-4 mb-6">
                                    <div className="flex items-center justify-between mb-4">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.FileText /> Data Templates
                                        </h3>
                                        <button
                                            onClick={() => setShowTemplates(false)}
                                            className="text-gray-500 hover:text-gray-700"
                                            title="Close templates"
                                        >
                                            ×
                                        </button>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                        {/* Save Template */}
                                        <div>
                                            <h4 className="font-medium mb-2">Save Current Data</h4>
                                            <div className="flex gap-2">
                                                <input
                                                    type="text"
                                                    placeholder="Template name..."
                                                    className="flex-1 px-3 py-2 text-sm border rounded"
                                                    onKeyDown={(e) => {
                                                        if (e.key === 'Enter' && e.target.value.trim()) {
                                                            saveAsTemplate(e.target.value.trim());
                                                            e.target.value = '';
                                                        }
                                                    }}
                                                />
                                                <button
                                                    onClick={(e) => {
                                                        const input = e.target.parentElement.querySelector('input');
                                                        if (input.value.trim()) {
                                                            saveAsTemplate(input.value.trim());
                                                            input.value = '';
                                                        }
                                                    }}
                                                    className="px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700"
                                                >
                                                    Save
                                                </button>
                                            </div>
                                            <p className="text-xs text-gray-600 mt-1">Saves all use cases without data values</p>
                                        </div>
                                        
                                        {/* Load Template */}
                                        <div>
                                            <h4 className="font-medium mb-2">Load Template</h4>
                                            <div className="space-y-2">
                                                {Object.keys(dataTemplates).map(templateName => (
                                                    <div key={templateName} className="flex items-center gap-2 p-2 bg-gray-50 rounded">
                                                        <span className="flex-1 text-sm font-medium">{templateName}</span>
                                                        <span className="text-xs text-gray-500">
                                                            {dataTemplates[templateName]?.useCases?.length || 0} use cases
                                                        </span>
                                                        <button
                                                            onClick={() => loadTemplate(templateName)}
                                                            className="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700"
                                                        >
                                                            Load
                                                        </button>
                                                        <button
                                                            onClick={() => deleteTemplate(templateName)}
                                                            className="px-2 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
                                                        >
                                                            ×
                                                        </button>
                                                    </div>
                                                ))}
                                                {Object.keys(dataTemplates).length === 0 && (
                                                    <p className="text-sm text-gray-500 italic">No templates saved yet</p>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                )}
                                
                                {/* Bulk Edit Help Panel */}
                                {bulkEditMode && (
                                    <div className="bg-blue-50 rounded-lg p-4 mb-6 border border-blue-200">
                                        <h3 className="font-semibold mb-3 text-blue-800 flex items-center gap-2">
                                            <Icons.Help /> Bulk Edit Mode - Quick Reference
                                        </h3>
                                        
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Keyboard Shortcuts</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+Z</kbd> Undo</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+Shift+Z</kbd> Redo</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Ctrl+A</kbd> Select All</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Enter</kbd> Next Field</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Tab</kbd> Navigate</li>
                                                    <li><kbd className="bg-gray-200 px-1 rounded">Esc</kbd> Finish Editing</li>
                                                </ul>
                                            </div>
                                            
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Copy & Paste</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li>• Copy from Excel/Google Sheets</li>
                                                    <li>• Paste with <kbd className="bg-gray-200 px-1 rounded">Ctrl+V</kbd></li>
                                                    <li>• Data fills automatically</li>
                                                    <li>• First column = Volume</li>
                                                    <li>• Other columns = Improvement</li>
                                                </ul>
                                            </div>
                                            
                                            <div className="bg-white p-3 rounded">
                                                <h4 className="font-medium mb-2 text-blue-700">Quick Actions</h4>
                                                <ul className="space-y-1 text-xs">
                                                    <li>• <strong>→All:</strong> Apply to all months</li>
                                                    <li>• <strong>←Copy:</strong> Copy previous month</li>
                                                    <li>• <strong>Fill Down:</strong> Apply to selected</li>
                                                    <li>• <strong>Batch Update:</strong> Change multiple</li>
                                                    <li>• Visual feedback for unsaved changes</li>
                                                </ul>
                                            </div>
                                        </div>
                                        
                                        <div className="mt-3 p-2 bg-yellow-100 rounded text-xs text-yellow-800">
                                            <strong>💡 Pro Tip:</strong> Select multiple use cases with checkboxes to perform batch operations. 
                                            Hover over data cells to see quick action buttons. All changes are automatically tracked for undo/redo.
                                        </div>
                                    </div>
                                )}
                                
                                {/* Bulk Operations Panel */}
                                {bulkEditMode && (
                                    <div className="bg-white rounded-lg shadow p-2 mb-3">
                                        <h3 className="font-semibold mb-4 flex items-center gap-2">
                                            <Icons.Settings /> Bulk Operations
                                            {selectedUseCases.size > 0 && (
                                                <span className="text-sm text-blue-600">({selectedUseCases.size} selected)</span>
                                            )}
                                        </h3>
                                        
                                        <div className="grid grid-cols-1 lg:grid-cols-2 items-start gap-6">
                                            {/* Quick Actions */}
                                            <div>
                                                <h4 className="font-medium mb-3">Quick Actions</h4>
                                                <div className="space-y-2">
                                                    <button
                                                        onClick={() => clearAllData(Array.from(selectedUseCases))}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Clear Selected Data
                                                    </button>
                                                    <button
                                                        onClick={batchDuplicate}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Duplicate Selected
                                                    </button>
                                                    <button
                                                        onClick={batchDelete}
                                                        disabled={selectedUseCases.size === 0}
                                                        className={`w-full px-3 py-2 rounded text-sm ${selectedUseCases.size > 0 ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    >
                                                        Delete Selected
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            {/* Batch Updates */}
                                            <div>
                                                <h4 className="font-medium mb-3">Batch Updates</h4>
                                                <div className="space-y-3">
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Category</label>
                                                        <select
                                                            onChange={(e) => e.target.value && batchUpdateCategory(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select category...</option>
                                                            {categories.map(cat => (
                                                                <option key={cat} value={cat}>{cat}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Channel</label>
                                                        <select
                                                            onChange={(e) => e.target.value && batchUpdateChannel(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select channel...</option>
                                                            {ALL_CHANNELS.map(channel => (
                                                                <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700 mb-1">Special Group</label>
                                                        <select
                                                            onChange={(e) => batchUpdateSpecialGroup(e.target.value)}
                                                            className="w-full px-2 py-1 text-sm border rounded"
                                                            disabled={selectedUseCases.size === 0}
                                                        >
                                                            <option value="">Select special group...</option>
                                                            <option value="">Remove Special Group</option>
                                                            {/* Add available special groups based on selected use cases */}
                                                            {Array.from(new Set(
                                                                useCases
                                                                    .filter(uc => selectedUseCases.has(uc.id))
                                                                    .flatMap(uc => getAvailableSpecialGroups(uc.category, uc.channel))
                                                            )).map(group => (
                                                                <option key={group} value={group}>{group}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Fill Down - full width row */}
                                            <div className="lg:col-span-2">
                                                {/* Fill Down Controls */}
                                                {selectedUseCases.size > 0 && (() => {
                                                    // Collect all unique benefits from selected use cases
                                                    const fillDownInputs = {};
                                                    const allBenefits = new Map();
                                                    
                                                    Array.from(selectedUseCases).forEach(ucId => {
                                                        const uc = useCases.find(u => u.id === ucId);
                                                        if (uc) {
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            normalizedUC.benefits.forEach((benefit, index) => {
                                                                if (!allBenefits.has(benefit.metric)) {
                                                                    allBenefits.set(benefit.metric, []);
                                                                }
                                                                allBenefits.get(benefit.metric).push({
                                                                    ucId,
                                                                    ucName: uc.name,
                                                                    benefitIndex: index,
                                                                    fieldKey: normalizedUC.benefits.length === 1 
                                                                        ? `improvement_${benefit.metric}`
                                                                        : `improvement_${index}_${benefit.metric}`
                                                                });
                                                            });
                                                        }
                                                    });
                                                    
                                                    const handleApplyIndividualMetric = (metric, type, instances) => {
                                                        // Save current state to undo stack before making changes
                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                        setRedoStack([]);
                                                        
                                                        const updatedUseCases = deepCopyUseCases(useCases);
                                                        
                                                        if (fillMode === 'constant' || fillMode === 'adjust') {
                                                            // Constant or Adjust mode
                                                            instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                if (ucIndex >= 0) {
                                                                    const uc = updatedUseCases[ucIndex];
                                                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                    
                                                                    // Apply volume if requested
                                                                    if (type === 'volume' || type === 'both') {
                                                                        const volumeInput = document.getElementById(`filldown-volume-${metric}`);
                                                                        if (volumeInput && volumeInput.value) {
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            
                                                                            const adjustment = parseFloat(volumeInput.value);
                                                                            
                                                                            months.forEach(month => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                if (fillMode === 'adjust') {
                                                                                    // Add/subtract from existing value
                                                                                    const currentValue = parseFloat(updatedUseCases[ucIndex].data[month.id][volumeFieldKey]) || 0;
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = Math.max(0, currentValue + adjustment).toString();
                                                                                } else {
                                                                                    // Replace with new value
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = volumeInput.value;
                                                                                }
                                                                            });
                                                                        }
                                                                    }
                                                                    
                                                                    // Apply improvement if requested
                                                                    if (type === 'improvement' || type === 'both') {
                                                                        const improvementInput = document.getElementById(`filldown-${metric}`);
                                                                        if (improvementInput && improvementInput.value) {
                                                                            const adjustment = parseFloat(improvementInput.value);
                                                                            
                                                                            months.forEach(month => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                if (fillMode === 'adjust') {
                                                                                    // Add/subtract from existing value
                                                                                    const currentValue = parseFloat(updatedUseCases[ucIndex].data[month.id][fieldKey]) || 0;
                                                                                    const newValue = currentValue + adjustment;
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                        metric.includes('min') ? newValue.toFixed(1) : newValue.toString();
                                                                                } else {
                                                                                    // Replace with new value
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = improvementInput.value;
                                                                                }
                                                                            });
                                                                        }
                                                                    }
                                                                }
                                                            });
                                                        } else {
                                                            // Gradual increase mode
                                                            const totalMonths = months.length;
                                                            
                                                            instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                if (ucIndex >= 0) {
                                                                    const uc = updatedUseCases[ucIndex];
                                                                    const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                    
                                                                    months.forEach((month, monthIndex) => {
                                                                        if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                            updatedUseCases[ucIndex].data[month.id] = {};
                                                                        }
                                                                        
                                                                        const progress = totalMonths > 1 ? monthIndex / (totalMonths - 1) : 0;
                                                                        
                                                                        // Apply volume if requested
                                                                        if (type === 'volume' || type === 'both') {
                                                                            const volumeStartInput = document.getElementById(`filldown-volume-start-${metric}`);
                                                                            const volumeEndInput = document.getElementById(`filldown-volume-end-${metric}`);
                                                                            
                                                                            if (volumeStartInput?.value && volumeEndInput?.value) {
                                                                                const startVal = parseFloat(volumeStartInput.value);
                                                                                const endVal = parseFloat(volumeEndInput.value);
                                                                                const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                    ? `volume_${metric}`
                                                                                    : `volume_${benefitIndex}_${metric}`;
                                                                                
                                                                                const interpolatedVolume = Math.round(interpolateValue(startVal, endVal, progress, curveType));
                                                                                updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = interpolatedVolume;
                                                                            }
                                                                        }
                                                                        
                                                                        // Apply improvement if requested
                                                                        if (type === 'improvement' || type === 'both') {
                                                                            const improvementStartInput = document.getElementById(`filldown-start-${metric}`);
                                                                            const improvementEndInput = document.getElementById(`filldown-end-${metric}`);
                                                                            
                                                                            if (improvementStartInput?.value && improvementEndInput?.value) {
                                                                                const startVal = parseFloat(improvementStartInput.value);
                                                                                const endVal = parseFloat(improvementEndInput.value);
                                                                                const interpolatedImprovement = interpolateValue(startVal, endVal, progress, curveType);
                                                                                
                                                                                updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                    metric.includes('min') ? interpolatedImprovement.toFixed(1) : Math.round(interpolatedImprovement);
                                                                            }
                                                                        }
                                                                    });
                                                                }
                                                            });
                                                        }
                                                        
                                                        setUseCases(updatedUseCases);
                                                    };
                                                    
                                                    const handleApplyAll = () => {
                                                        if (fillMode === 'constant') {
                                                            // Original constant value logic
                                                            const operations = [];
                                                            
                                                            allBenefits.forEach((instances, metric) => {
                                                                const volumeInput = document.getElementById(`filldown-volume-${metric}`);
                                                                if (volumeInput && volumeInput.value) {
                                                                    instances.forEach(({ucId, benefitIndex}) => {
                                                                        const uc = useCases.find(u => u.id === ucId);
                                                                        if (uc) {
                                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            operations.push({
                                                                                useCaseId: ucId,
                                                                                field: volumeFieldKey,
                                                                                value: volumeInput.value
                                                                            });
                                                                        }
                                                                    });
                                                                }
                                                                
                                                                const improvementInput = document.getElementById(`filldown-${metric}`);
                                                                if (improvementInput && improvementInput.value) {
                                                                    instances.forEach(({ucId, fieldKey}) => {
                                                                        operations.push({
                                                                            useCaseId: ucId,
                                                                            field: fieldKey,
                                                                            value: improvementInput.value
                                                                        });
                                                                    });
                                                                }
                                                            });
                                                            
                                                            if (operations.length > 0) {
                                                                batchFillDown(operations);
                                                            }
                                                        } else {
                                                            // Gradual increase logic
                                                            // Save current state to undo stack BEFORE making changes
                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                            setRedoStack([]);
                                                            
                                                            const updatedUseCases = deepCopyUseCases(useCases);
                                                            const totalMonths = months.length;
                                                            
                                                            allBenefits.forEach((instances, metric) => {
                                                                // Get start and end values for volumes
                                                                const volumeStartInput = document.getElementById(`filldown-volume-start-${metric}`);
                                                                const volumeEndInput = document.getElementById(`filldown-volume-end-${metric}`);
                                                                const hasVolumeGradual = volumeStartInput?.value && volumeEndInput?.value;
                                                                
                                                                // Get start and end values for improvements
                                                                const improvementStartInput = document.getElementById(`filldown-start-${metric}`);
                                                                const improvementEndInput = document.getElementById(`filldown-end-${metric}`);
                                                                const hasImprovementGradual = improvementStartInput?.value && improvementEndInput?.value;
                                                                
                                                                if (hasVolumeGradual || hasImprovementGradual) {
                                                                    instances.forEach(({ucId, benefitIndex, fieldKey}) => {
                                                                        const ucIndex = updatedUseCases.findIndex(u => u.id === ucId);
                                                                        if (ucIndex >= 0) {
                                                                            const uc = updatedUseCases[ucIndex];
                                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                                            const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                                ? `volume_${metric}`
                                                                                : `volume_${benefitIndex}_${metric}`;
                                                                            
                                                                            months.forEach((month, monthIndex) => {
                                                                                if (!updatedUseCases[ucIndex].data[month.id]) {
                                                                                    updatedUseCases[ucIndex].data[month.id] = {};
                                                                                }
                                                                                
                                                                                // Calculate interpolated values
                                                                                const progress = totalMonths > 1 ? monthIndex / (totalMonths - 1) : 0;
                                                                                
                                                                                if (hasVolumeGradual) {
                                                                                    const startVal = parseFloat(volumeStartInput.value);
                                                                                    const endVal = parseFloat(volumeEndInput.value);
                                                                                    const interpolatedVolume = Math.round(interpolateValue(startVal, endVal, progress, curveType));
                                                                                    updatedUseCases[ucIndex].data[month.id][volumeFieldKey] = interpolatedVolume;
                                                                                }
                                                                                
                                                                                if (hasImprovementGradual) {
                                                                                    const startVal = parseFloat(improvementStartInput.value);
                                                                                    const endVal = parseFloat(improvementEndInput.value);
                                                                                    const interpolatedImprovement = interpolateValue(startVal, endVal, progress, curveType);
                                                                                    updatedUseCases[ucIndex].data[month.id][fieldKey] = 
                                                                                        metric.includes('min') ? interpolatedImprovement.toFixed(1) : Math.round(interpolatedImprovement);
                                                                                }
                                                                            });
                                                                        }
                                                                    });
                                                                }
                                                            });
                                                            
                                                            // Don't save to undo stack here - we already saved before making changes
                                                            setUseCases(updatedUseCases);
                                                        }
                                                        
                                                        // Clear all inputs
                                                        document.querySelectorAll('[id^="filldown-"]').forEach(input => {
                                                            input.value = '';
                                                        });
                                                    };
                                                    
                                                    return (
                                                        <div className="mt-4 p-3 bg-blue-50 rounded">
                                                            <h5 className="font-medium text-sm mb-2">Fill Down</h5>
                                                            <p className="text-[10px] text-gray-600 mb-2">Enter values to apply to all selected use cases across all months</p>
                                                            
                                                            {/* Mode Toggle */}
                                                            <div className="mb-3">
                                                                <label className="block text-[10px] text-gray-600 mb-1">Fill Mode</label>
                                                                <div className="grid grid-cols-3 gap-1">
                                                                    <button
                                                                        onClick={() => setFillMode('constant')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'constant' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Replace all values with a constant"
                                                                    >
                                                                        Replace
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setFillMode('adjust')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'adjust' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Add or subtract from existing values"
                                                                    >
                                                                        Adjust ±
                                                                    </button>
                                                                    <button
                                                                        onClick={() => setFillMode('gradual')}
                                                                        className={`px-2 py-1 text-[10px] rounded ${fillMode === 'gradual' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                                                        title="Gradual increase from start to end"
                                                                    >
                                                                        Gradual
                                                                    </button>
                                                                </div>
                                                                {fillMode === 'adjust' && (
                                                                    <div className="mt-2 p-2 bg-yellow-50 rounded">
                                                                        <p className="text-[10px] text-yellow-800">
                                                                            <strong>Adjust Mode:</strong> Enter positive values to add, negative to subtract from existing values
                                                                        </p>
                                                                    </div>
                                                                )}
                                                            </div>
                                                            
                                                            {/* Curve Type Selector - Only show when in gradual mode */}
                                                            {fillMode === 'gradual' && (
                                                                <div className="mb-3">
                                                                    <label className="block text-[10px] text-gray-600 mb-1">Curve Type</label>
                                                                    <select
                                                                        value={curveType}
                                                                        onChange={(e) => setCurveType(e.target.value)}
                                                                        className="w-full px-2 py-1 text-xs border rounded bg-white"
                                                                    >
                                                                        <option value="linear">Linear (Steady Growth)</option>
                                                                        <option value="exponential">Exponential (Slow Start, Rapid End)</option>
                                                                        <option value="scurve">S-Curve (Slow-Fast-Slow)</option>
                                                                        <option value="logarithmic">Logarithmic (Fast Start, Slow End)</option>
                                                                        <option value="custom">Custom (Fine Control)</option>
                                                                    </select>
                                                                    <div className="mt-2 p-2 bg-blue-50 rounded text-[10px] text-gray-700">
                                                                        {curveType === 'linear' && (
                                                                            <div>
                                                                                <strong>Linear Growth:</strong> Values increase uniformly across all months.
                                                                                <div className="text-[10px] mt-1">Example: 10% → 60% over 12 months = +4.5% each month</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'exponential' && (
                                                                            <div>
                                                                                <strong>Exponential Growth:</strong> Slow initial adoption, rapid acceleration near end.
                                                                                <div className="text-[10px] mt-1">Ideal for: Technology adoption, viral growth patterns</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'scurve' && (
                                                                            <div>
                                                                                <strong>S-Curve (Sigmoid):</strong> Classic adoption curve with three phases.
                                                                                <div className="text-[10px] mt-1">Phase 1: Slow start | Phase 2: Rapid growth | Phase 3: Plateau</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'logarithmic' && (
                                                                            <div>
                                                                                <strong>Logarithmic Growth:</strong> Quick initial gains, then diminishing returns.
                                                                                <div className="text-[10px] mt-1">Ideal for: Quick wins, immediate impact scenarios</div>
                                                                            </div>
                                                                        )}
                                                                        {curveType === 'custom' && (
                                                                            <div>
                                                                                <strong>Custom Control:</strong> Set specific percentages for key milestones.
                                                                                <div className="text-[10px] mt-1">Define values at Month 3, 6, 9 for fine-grained control</div>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    
                                                                    {/* Custom milestone controls */}
                                                                    {curveType === 'custom' && (
                                                                        <div className="mt-2 p-2 bg-gray-50 rounded">
                                                                            <div className="text-[10px] font-medium mb-2">Milestone Percentages</div>
                                                                            <div className="grid grid-cols-3 gap-2">
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 3 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-3"
                                                                                        placeholder="25"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 6 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-6"
                                                                                        placeholder="50"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                                <div>
                                                                                    <label className="text-[10px] text-gray-600">Month 9 (%)</label>
                                                                                    <input
                                                                                        type="number"
                                                                                        id="custom-milestone-9"
                                                                                        placeholder="75"
                                                                                        className="w-full px-1 py-0.5 text-xs border rounded"
                                                                                        min="0" max="100"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                            <div className="text-[8px] text-gray-500 mt-1">
                                                                                Percentages represent progress from start to end value
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}
                                                            
                                                            {/* Benefit-specific Volume and Improvement Inputs - Responsive Grid */}
                                                            <div className="grid gap-3 mb-3 grid-cols-[repeat(auto-fit,minmax(280px,1fr))]">
                                                                {Array.from(allBenefits.entries()).map(([metric, instances]) => {
                                                                    const volumeLabel = getVolumeLabel(metric);
                                                                    return (
                                                                        <div key={metric} className="p-2 bg-white rounded border border-gray-200">
                                                                            <div className="text-[11px] font-semibold text-blue-700 mb-2 flex items-center justify-between">
                                                                                <span>{metric}</span>
                                                                                <span className="text-[10px] text-gray-500">({instances.length} use case{instances.length > 1 ? 's' : ''})</span>
                                                                            </div>
                                                                        
                                                                            {/* Volume Input for this metric */}
                                                                            <div className="mb-1.5">
                                                                                <label className="block text-[10px] text-gray-600 mb-0.5 font-medium">
                                                                                    📊 {volumeLabel} {fillMode === 'gradual' && '(Start → End)'} {fillMode === 'adjust' && '(± Adjustment)'}
                                                                                </label>
                                                                            {fillMode === 'constant' || fillMode === 'adjust' ? (
                                                                                <input
                                                                                    id={`filldown-volume-${metric}`}
                                                                                    type="number"
                                                                                    placeholder={fillMode === 'adjust' ? `± ${volumeLabel.toLowerCase()} adjustment` : `Number of ${volumeLabel.toLowerCase()}`}
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    title={fillMode === 'adjust' ? `Add/subtract ${volumeLabel} for ${metric}` : `Volume of ${volumeLabel} for ${metric}`}
                                                                                />
                                                                            ) : (
                                                                                <div className="flex gap-1">
                                                                                    <input
                                                                                        id={`filldown-volume-start-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="Start"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Starting volume for ${metric}`}
                                                                                    />
                                                                                    <span className="text-xs self-center">→</span>
                                                                                    <input
                                                                                        id={`filldown-volume-end-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="End"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Ending volume for ${metric}`}
                                                                                    />
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                        
                                                                            {/* Improvement Input for this metric */}
                                                                            <div className="mb-1.5">
                                                                                <label className="block text-[10px] text-gray-600 mb-0.5 font-medium">
                                                                                    🎯 Improvement {fillMode === 'gradual' && '(Start → End)'} {fillMode === 'adjust' && '(± Adjustment)'}
                                                                                </label>
                                                                            {fillMode === 'constant' || fillMode === 'adjust' ? (
                                                                                <input
                                                                                    id={`filldown-${metric}`}
                                                                                    type="number"
                                                                                    placeholder={fillMode === 'adjust' 
                                                                                        ? (metric.includes('min') ? '± Minutes' : metric.includes('points') ? '± Points' : '± Percentage')
                                                                                        : (metric.includes('min') ? 'Minutes' : metric.includes('points') ? 'Points' : 'Percentage')}
                                                                                    className="w-full px-2 py-1 text-xs border rounded"
                                                                                    title={fillMode === 'adjust' 
                                                                                        ? `Add/subtract to: ${instances.map(i => i.ucName).join(', ')}`
                                                                                        : `Apply to: ${instances.map(i => i.ucName).join(', ')}`}
                                                                                />
                                                                            ) : (
                                                                                <div className="flex gap-1">
                                                                                    <input
                                                                                        id={`filldown-start-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="Start"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Starting improvement for ${metric}`}
                                                                                    />
                                                                                    <span className="text-xs self-center">→</span>
                                                                                    <input
                                                                                        id={`filldown-end-${metric}`}
                                                                                        type="number"
                                                                                        placeholder="End"
                                                                                        className="w-20 px-2 py-1 text-xs border rounded"
                                                                                        title={`Ending improvement for ${metric}`}
                                                                                    />
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                        
                                                                            {/* Individual Apply Buttons - Compact */}
                                                                            <div className="flex gap-1 mt-1.5">
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'volume', instances)}
                                                                                    className="flex-1 px-1.5 py-0.5 bg-green-600 text-white text-[10px] rounded hover:bg-green-700 transition-colors"
                                                                                    title={`Apply only ${volumeLabel} values for ${metric}`}
                                                                                >
                                                                                    📊 {volumeLabel}
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'improvement', instances)}
                                                                                    className="flex-1 px-1.5 py-0.5 bg-blue-600 text-white text-[10px] rounded hover:bg-blue-700 transition-colors"
                                                                                    title={`Apply only improvement values for ${metric}`}
                                                                                >
                                                                                    🎯 Improvement
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => handleApplyIndividualMetric(metric, 'both', instances)}
                                                                                    className="px-1.5 py-0.5 bg-purple-600 text-white text-[10px] rounded hover:bg-purple-700 transition-colors"
                                                                                    title={`Apply both volume and improvement for ${metric}`}
                                                                                >
                                                                                    ✅ Both
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                            
                                                            {/* Apply All Button with warning */}
                                                            <div className="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded">
                                                                <p className="text-[10px] text-yellow-800 mb-2">
                                                                    ⚠️ <strong>Apply All:</strong> This will overwrite ALL volume and improvement values for ALL benefits
                                                                </p>
                                                                <button
                                                                    onClick={handleApplyAll}
                                                                    className="w-full px-3 py-1 bg-orange-600 text-white text-xs rounded hover:bg-orange-700"
                                                                >
                                                                    Apply All Values (Overwrites Everything)
                                                                </button>
                                                            </div>
                                                            
                                                            <p className="text-[10px] text-gray-500 mt-2">
                                                                💡 Tip: Use individual Apply buttons above to update specific metrics without overwriting others
                                                            </p>
                                                        </div>
                                                    );
                                                })()}
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* Table Controls */}
                                <div className="bg-white rounded-lg shadow p-3 mb-4">
                                    {isMobile ? (
                                        // Mobile layout - stack controls vertically
                                        <div className="flex flex-col gap-3">
                                            {/* Bulk Edit Row */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <div className="flex items-center justify-center gap-2 bg-gray-50 rounded p-2 min-h-[44px]">
                                                    <input
                                                        type="checkbox"
                                                        id="bulkEditMode"
                                                        checked={bulkEditMode}
                                                        onChange={(e) => {
                                                            setBulkEditMode(e.target.checked);
                                                            setSelectedUseCases(new Set());
                                                        }}
                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                    />
                                                    <label htmlFor="bulkEditMode" className="text-sm font-medium text-gray-700">
                                                        Bulk Edit
                                                    </label>
                                                </div>
                                                
                                                {/* AHT Mode for mobile - simplified */}
                                                {hasAHTWithPerContactBilling() && (
                                                    <div className="flex items-center justify-center gap-2 bg-gray-50 rounded p-2 min-h-[44px]">
                                                        <input
                                                            type="checkbox"
                                                            id="ahtMode"
                                                            checked={ahtNegotiationMode}
                                                            onChange={(e) => setAhtNegotiationMode(e.target.checked)}
                                                            className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                        />
                                                        <label htmlFor="ahtMode" className="text-sm font-medium text-gray-700">
                                                            AHT Mode
                                                        </label>
                                                    </div>
                                                )}
                                            </div>
                                            
                                            {/* Undo/Redo Row */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <button
                                                    onClick={undo}
                                                    disabled={undoStack.length === 0}
                                                    className={`px-2 py-1 rounded text-sm flex items-center justify-center gap-1 min-h-[32px] ${undoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    title="Undo (Ctrl+Z)"
                                                >
                                                    ↶ Undo
                                                </button>
                                                <button
                                                    onClick={redo}
                                                    disabled={redoStack.length === 0}
                                                    className={`px-2 py-1 rounded text-sm flex items-center justify-center gap-1 min-h-[32px] ${redoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                    title="Redo (Ctrl+Shift+Z)"
                                                >
                                                    ↷ Redo
                                                </button>
                                            </div>
                                            
                                            {/* Unsaved changes indicator for mobile */}
                                            {unsavedChanges.size > 0 && (
                                                <div className="bg-yellow-100 text-yellow-800 px-3 py-2 rounded text-sm text-center">
                                                    {unsavedChanges.size} unsaved change{unsavedChanges.size > 1 ? 's' : ''}
                                                </div>
                                            )}
                                            
                                            {/* Templates and Add Use Case Row - moved to bottom on mobile */}
                                            <div className="grid grid-cols-2 gap-2">
                                                <button
                                                    onClick={() => setShowTemplates(!showTemplates)}
                                                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 flex items-center justify-center gap-2 text-sm min-h-[44px]"
                                                >
                                                    <Icons.FileText /> <span>{showTemplates ? 'Hide' : 'Templates'}</span>
                                                </button>
                                                <button
                                                    onClick={() => setShowAddUseCase(!showAddUseCase)}
                                                    className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center justify-center gap-2 text-sm min-h-[44px]"
                                                >
                                                    <span className="text-lg">+</span> <span>Add Use Case</span>
                                                </button>
                                            </div>
                                        </div>
                                    ) : (
                                        // Desktop layout - horizontal arrangement
                                        <div className="flex gap-3 items-center justify-between">
                                            <div className="flex gap-3 items-center">
                                                {/* Bulk Edit Mode Toggle */}
                                                <div className="flex items-center gap-2">
                                                    <input
                                                        type="checkbox"
                                                        id="bulkEditMode"
                                                        checked={bulkEditMode}
                                                        onChange={(e) => {
                                                            setBulkEditMode(e.target.checked);
                                                            setSelectedUseCases(new Set());
                                                        }}
                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                    />
                                                    <label htmlFor="bulkEditMode" className="text-sm font-medium text-gray-700">
                                                        Bulk Edit Mode
                                                    </label>
                                                </div>
                                                
                                                {/* Undo/Redo Buttons */}
                                                <div className="flex gap-1">
                                                    <button
                                                        onClick={undo}
                                                        disabled={undoStack.length === 0}
                                                        className={`px-3 py-2 rounded text-sm ${undoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                        title="Undo (Ctrl+Z)"
                                                    >
                                                        ↶ Undo
                                                    </button>
                                                    <button
                                                        onClick={redo}
                                                        disabled={redoStack.length === 0}
                                                        className={`px-3 py-2 rounded text-sm ${redoStack.length > 0 ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}
                                                        title="Redo (Ctrl+Shift+Z)"
                                                    >
                                                        ↷ Redo
                                                    </button>
                                                </div>
                                                
                                                {/* Show Unsaved Changes Indicator */}
                                                {unsavedChanges.size > 0 && (
                                                    <div className="bg-yellow-100 text-yellow-800 px-3 py-1 rounded text-sm">
                                                        {unsavedChanges.size} unsaved change{unsavedChanges.size > 1 ? 's' : ''}
                                                    </div>
                                                )}
                                                
                                                {/* AHT Negotiation Mode Toggle */}
                                                {hasAHTWithPerContactBilling() && (
                                                    <div className="flex items-center gap-2 ml-4">
                                                        <label className="flex items-center gap-2 cursor-pointer" title="When enabled, calculates potential savings from AHT reductions even with per-contact billing (for contract negotiations)">
                                                            <input
                                                                type="checkbox"
                                                                checked={ahtNegotiationMode}
                                                                onChange={(e) => setAhtNegotiationMode(e.target.checked)}
                                                                className="form-checkbox h-4 w-4 text-blue-600"
                                                            />
                                                            <span className="text-sm font-medium">AHT Negotiation Mode</span>
                                                        </label>
                                                        {ahtNegotiationMode ? (
                                                            <span className="text-xs text-green-600 bg-green-50 px-2 py-1 rounded">
                                                                Calculating negotiation leverage
                                                            </span>
                                                        ) : (
                                                            <span className="text-xs text-amber-600 bg-amber-50 px-2 py-1 rounded">
                                                                ⚠️ AHT savings benefit vendor (per-contact billing)
                                                            </span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            
                                            {/* Action buttons on the right */}
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => setShowTemplates(!showTemplates)}
                                                    className="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 flex items-center gap-2 text-sm"
                                                >
                                                    <Icons.FileText /> {showTemplates ? 'Hide' : 'Show'} Templates
                                                </button>
                                                <button
                                                    onClick={() => setShowAddUseCase(!showAddUseCase)}
                                                    className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center gap-2 text-sm"
                                                >
                                                    <span className="text-lg">+</span> Add Use Case
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Add Use Case Form */}
                                {showAddUseCase && (
                                    <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
                                        <div className="bg-blue-50 px-6 py-4 rounded">
                                            {/* Basic Use Case Info */}
                                            <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-4 gap-3'} mb-4`}>
                                                <select
                                                    value={newUseCase.category}
                                                    onChange={(e) => setNewUseCase({...newUseCase, category: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    {categories.map(cat => (
                                                        <option key={cat} value={cat}>{cat}</option>
                                                    ))}
                                                </select>
                                                <input
                                                    type="text"
                                                    placeholder="Use Case Name"
                                                    value={newUseCase.name}
                                                    onChange={(e) => setNewUseCase({...newUseCase, name: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                />
                                                <select
                                                    value={newUseCase.channel}
                                                    onChange={(e) => setNewUseCase({...newUseCase, channel: e.target.value})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    {ALL_CHANNELS.map(channel => (
                                                        <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                    ))}
                                                </select>
                                                <select
                                                    value={newUseCase.specialGroup || ''}
                                                    onChange={(e) => setNewUseCase({...newUseCase, specialGroup: e.target.value || null})}
                                                    className="px-3 py-2 border rounded"
                                                >
                                                    <option value="">No Special Group</option>
                                                    {getAvailableSpecialGroups(newUseCase.category, newUseCase.channel).map(group => (
                                                        <option key={group} value={group}>{group}</option>
                                                    ))}
                                                </select>
                                            </div>

                                            {/* Benefits Section */}
                                            <div className="mb-4">
                                                <h4 className="font-medium mb-2">Benefits (Value Drivers)</h4>
                                                {newUseCase.benefits.map((benefit, index) => (
                                                    <div key={index} className="mb-3">
                                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-2' : 'grid grid-cols-6 gap-2'} mb-1 items-center`}>
                                                            <select
                                                                value={benefit.metric}
                                                                onChange={(e) => {
                                                                    const updatedBenefits = [...newUseCase.benefits];
                                                                    updatedBenefits[index].metric = e.target.value;
                                                                    setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                }}
                                                                className={`px-2 py-1 border rounded text-sm ${isMobile ? 'w-full' : 'col-span-3'}`}
                                                            >
                                                                {getAvailableMetrics().map(metric => (
                                                                    <option key={metric} value={metric} disabled={newUseCase.benefits.some((b, idx) => idx !== index && b.metric === metric)}>{metric}</option>
                                                                ))}
                                                            </select>
                                                            <div className={`${isMobile ? 'w-full' : 'col-span-2'}`}>
                                                                <label className="text-xs text-gray-600 block mb-1">
                                                                    Baseline {benefit.metric.includes('min') ? '(minutes)' : benefit.metric.includes('points') ? '(points)' : '(%)'}
                                                                </label>
                                                                <input
                                                                    type="number"
                                                                    placeholder={
                                                                        benefit.metric.includes('min') ? 'Minutes' : 
                                                                        benefit.metric.includes('points') ? 'Points' : 
                                                                        'Percent'
                                                                    }
                                                                    value={benefit.baselineValue}
                                                                    onChange={(e) => {
                                                                        const updatedBenefits = [...newUseCase.benefits];
                                                                        updatedBenefits[index].baselineValue = parseFloat(e.target.value) || 0;
                                                                        setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                    }}
                                                                    className="px-2 py-1 border rounded text-sm w-full"
                                                                    step="0.01"
                                                                />
                                                            </div>
                                                            <button
                                                                onClick={() => {
                                                                    if (newUseCase.benefits.length > 1) {
                                                                        const updatedBenefits = newUseCase.benefits.filter((_, i) => i !== index);
                                                                        setNewUseCase({...newUseCase, benefits: updatedBenefits});
                                                                    }
                                                                }}
                                                                className="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                                disabled={newUseCase.benefits.length === 1}
                                                            >
                                                                Remove
                                                            </button>
                                                        </div>
                                                    </div>
                                                ))}
                                                <button
                                                    onClick={() => {
                                                        // Find a metric that isn't already used
                                                        const availableMetrics = getAvailableMetrics().filter(m => 
                                                            !newUseCase.benefits.some(b => b.metric === m)
                                                        );
                                                        if (availableMetrics.length > 0) {
                                                            setNewUseCase({
                                                                ...newUseCase, 
                                                                benefits: [...newUseCase.benefits, {metric: availableMetrics[0], baselineValue: 0}]
                                                            });
                                                        } else {
                                                            alert('All available metrics have been added.');
                                                        }
                                                    }}
                                                    className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                                                    disabled={newUseCase.benefits.length >= getAvailableMetrics().length}
                                                >
                                                    Add Benefit
                                                </button>
                                            </div>

                                            <div className="flex justify-end gap-2">
                                                <button
                                                    onClick={() => setShowAddUseCase(false)}
                                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={addUseCase}
                                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                                >
                                                    Add Use Case
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                <div className="bg-white rounded-lg shadow-lg overflow-hidden">
                                    <div className="overflow-x-auto relative max-h-[80vh] overflow-y-auto">
                                        <table className="w-full">
                                            <thead className="bg-gradient-to-r from-blue-700 to-indigo-700 text-white sticky top-0 z-20 shadow-lg">
                                                <tr>
                                                    {bulkEditMode && (
                                                        <th className={`px-2 py-2 text-center sticky left-0 z-30 bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg`}>
                                                            <input
                                                                type="checkbox"
                                                                checked={useCases.length > 0 && selectedUseCases.size === useCases.length}
                                                                onChange={(e) => {
                                                                    if (e.target.checked) {
                                                                        setSelectedUseCases(new Set(useCases.map(uc => uc.id)));
                                                                    } else {
                                                                        setSelectedUseCases(new Set());
                                                                    }
                                                                }}
                                                                className="w-4 h-4 rounded"
                                                            />
                                                        </th>
                                                    )}
                                                    <th className={`px-2 py-2 text-left text-xs sticky left-0 z-30 bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[120px]`}>Category</th>
                                                    <th className={`px-2 py-2 text-left text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-36' : 'left-28'} z-30` : ''} bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[200px]`}>Use Case</th>
                                                    <th className={`px-2 py-2 text-left text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-80' : 'left-72'} z-30` : ''} bg-gradient-to-r from-blue-700 to-indigo-700 shadow-lg min-w-[140px]`}>Channel & Group</th>
                                                    {months.map(month => (
                                                        <th key={month.id} className="px-1 py-1.5 text-center min-w-[140px] max-w-[160px]">
                                                            <div className="text-xs font-semibold">{month.month.substring(0, 3)} '{String(month.year).substring(2)}</div>
                                                        </th>
                                                    ))}
                                                    <th className="px-2 py-2 text-center text-xs">Total</th>
                                                    <th className="px-2 py-2 text-center text-xs">Actions</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {useCases.map((useCase, index) => {
                                                    const normalizedUseCase = ensureUseCaseHasBenefits(useCase);
                                                    const totalSavings = months.reduce((sum, month) => 
                                                        sum + calculateSavings(normalizedUseCase, month.id), 0
                                                    );

                                                    // Per-benefit totals across all shown months (no new calc functions)
                                                    const totalsByBenefit = new Map();
                                                    months.forEach(month => {
                                                        const monthData = normalizedUseCase.data[month.id] || {};
                                                        normalizedUseCase.benefits.forEach((benefit, benefitIndex) => {
                                                            const s = calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                                                            totalsByBenefit.set(benefit.metric, (totalsByBenefit.get(benefit.metric) || 0) + s);
                                                        });
                                                    });
                                                    const perBenefitTotals = Array.from(totalsByBenefit.entries()).sort((a, b) => b[1] - a[1]);

                                                    return (
                                                        <tr key={useCase.id} className={`${selectedUseCases.has(useCase.id) ? 'row-selected ring-2 ring-blue-300' : (index % 2 === 0 ? 'row-even' : 'row-odd')} transition-colors`} style={{borderBottom: '2px solid rgba(147, 197, 253, 0.5)'}}>
                                                            {bulkEditMode && (
                                                                <td className={`px-2 py-1.5 text-center sticky left-0 z-10`}>
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={selectedUseCases.has(useCase.id)}
                                                                        onChange={(e) => {
                                                                            const newSelected = new Set(selectedUseCases);
                                                                            if (e.target.checked) {
                                                                                newSelected.add(useCase.id);
                                                                            } else {
                                                                                newSelected.delete(useCase.id);
                                                                            }
                                                                            setSelectedUseCases(newSelected);
                                                                        }}
                                                                        className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                                                    />
                                                                </td>
                                                            )}
                                                            <td className={`px-2 py-1.5 text-xs sticky left-0 z-10 min-w-[120px]`}>
                                                                {isMobile ? (
                                                                    // Mobile: Use a basic select with no styling classes
                                                                    <select
                                                                        value={useCase.category}
                                                                        onChange={(e) => {
                                                                            // Save to undo stack before making changes
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            
                                                                            setUseCases(useCases.map(uc => 
                                                                                uc.id === useCase.id 
                                                                                    ? {...uc, category: e.target.value}
                                                                                    : uc
                                                                            ));
                                                                        }}
                                                                        style={{
                                                                            width: '100%',
                                                                            fontSize: '16px',
                                                                            padding: '8px',
                                                                            border: '1px solid #d1d5db',
                                                                            borderRadius: '4px',
                                                                            backgroundColor: 'white'
                                                                            // Don't set any appearance properties - let browser use native
                                                                        }}
                                                                    >
                                                                        {categories.map(cat => (
                                                                            <option key={cat} value={cat}>{cat}</option>
                                                                        ))}
                                                                    </select>
                                                                ) : (
                                                                    // Desktop: Keep the styled select
                                                                    <select
                                                                        value={useCase.category}
                                                                        onChange={(e) => {
                                                                            // Save to undo stack before making changes
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            
                                                                            setUseCases(useCases.map(uc => 
                                                                                uc.id === useCase.id 
                                                                                    ? {...uc, category: e.target.value}
                                                                                    : uc
                                                                            ));
                                                                        }}
                                                                        className="text-[11px] border rounded px-1 py-0.5 w-full"
                                                                    >
                                                                        {categories.map(cat => (
                                                                            <option key={cat} value={cat}>{cat}</option>
                                                                        ))}
                                                                    </select>
                                                                )}
                                                            </td>
                                                            <td className={`px-2 py-1.5 text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-36' : 'left-28'} z-10` : ''} min-w-[200px]`}>
                                                                <div title={useCase.name} className="font-medium truncate max-w-[180px]">{useCase.name}</div>
                                                                {normalizedUseCase.benefits.length > 0 && (
                                                                    <div className="mt-1 space-y-0.5">
                                                                        {normalizedUseCase.benefits.map((b, idx) => {
                                                                            const baseline = b.baselineValue || 0;
                                                                            const metricName = b.metric.split('(')[0].trim();
                                                                            const unit = b.metric.includes('min') ? 'min' : 
                                                                                        b.metric.includes('points') ? 'pts' : '%';
                                                                            
                                                                            // Calculate total for this benefit across all months
                                                                            let benefitTotal = 0;
                                                                            months.forEach(month => {
                                                                                const monthData = normalizedUseCase.data[month.id] || {};
                                                                                benefitTotal += calculateBenefitSavings(normalizedUseCase, b, monthData, idx);
                                                                            });
                                                                            
                                                                            const hasBaseline = baseline > 0;
                                                                            const tagColor = hasBaseline 
                                                                                ? 'bg-blue-100 text-blue-800 border-blue-200' 
                                                                                : 'bg-green-100 text-green-800 border-green-200';
                                                                            
                                                                            return (
                                                                                <div key={idx} className={`inline-flex items-center gap-1 ${tagColor} border rounded-full px-2 py-0.5 text-[10px] mr-1`}>
                                                                                    <span className="font-medium">{metricName}</span>
                                                                                    {baseline > 0 && (
                                                                                        <>
                                                                                            <span className="opacity-60">|</span>
                                                                                            <span className="opacity-80">base: {baseline}{unit}</span>
                                                                                        </>
                                                                                    )}
                                                                                    {benefitTotal > 0 && (
                                                                                        <>
                                                                                            <span className="opacity-60">|</span>
                                                                                            <span className="font-bold">${Math.round(benefitTotal / 1000)}k</span>
                                                                                        </>
                                                                                    )}
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>
                                                                )}
                                                            </td>
                                                            <td className={`px-2 py-1.5 text-xs ${!isMobile ? `sticky ${bulkEditMode ? 'left-80' : 'left-72'} z-10` : ''} min-w-[140px]`}>
                                                                <select
                                                                    value={useCase.channel}
                                                                    onChange={(e) => {
                                                                        // Save to undo stack before making changes
                                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                        setRedoStack([]);
                                                                        
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, channel: e.target.value}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="text-[11px] border rounded px-1 py-0.5 w-full capitalize"
                                                                >
                                                                    {ALL_CHANNELS.map(channel => (
                                                                        <option key={channel.id} value={channel.id}>{channel.label}</option>
                                                                    ))}
                                                                </select>
                                                                <div className="text-[10px] text-gray-600 mt-0.5">
                                                                    Cost: ${getEffectiveCost(useCase, useCase.channel).toFixed(2)}/contact
                                                                </div>
                                                                <select
                                                                    value={useCase.specialGroup || ''}
                                                                    onChange={(e) => {
                                                                        // Save to undo stack before making changes
                                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                        setRedoStack([]);
                                                                        
                                                                        setUseCases(useCases.map(uc => 
                                                                            uc.id === useCase.id 
                                                                                ? {...uc, specialGroup: e.target.value || null}
                                                                                : uc
                                                                        ));
                                                                    }}
                                                                    className="text-[10px] border rounded px-1 py-0.5 mt-0.5 w-full min-w-[120px]"
                                                                >
                                                                    <option value="">No Special Group</option>
                                                                    {getAvailableSpecialGroups(useCase.category, useCase.channel).map(group => (
                                                                        <option key={group} value={group}>{group}</option>
                                                                    ))}
                                                                </select>
                                                            </td>
                                                            {months.map(month => {
                                                                const monthData = normalizedUseCase.data[month.id] || {};
                                                                const savings = calculateSavings(normalizedUseCase, month.id);
                                                                
                                                                return (
                                                                    <td 
                                                                        key={month.id} 
                                                                        className="px-2 py-1.5 relative min-w-[140px] max-w-[160px]"
                                                                        onPaste={(e) => bulkEditMode && handlePaste(e, index, months.findIndex(m => m.id === month.id))}
                                                                    >
                                                                        <div className="space-y-2">
                                                                            {/* Benefit-specific Volume and Improvement Inputs */}
                                                                            {normalizedUseCase.benefits.length === 0 ? (
                                                                                <div className="text-xs text-gray-400 italic p-2">
                                                                                    No benefits defined
                                                                                </div>
                                                                            ) : (
                                                                                normalizedUseCase.benefits.map((benefit, benefitIndex) => {
                                                                                    const volumeFieldKey = normalizedUseCase.benefits.length === 1 
                                                                                        ? `volume_${benefit.metric}`
                                                                                        : `volume_${benefitIndex}_${benefit.metric}`;
                                                                                    const improvementFieldKey = normalizedUseCase.benefits.length === 1 
                                                                                        ? `improvement_${benefit.metric}`
                                                                                        : `improvement_${benefitIndex}_${benefit.metric}`;
                                                                                    const volumeLabel = getVolumeLabel(benefit.metric);
                                                                                    
                                                                                    return (
                                                                                        <div key={`${benefit.metric}-${benefitIndex}`} className="p-2 bg-white/70 rounded border border-gray-200 mb-3">
                                                                                            <div className="text-[10px] font-semibold text-blue-600 mb-1 flex justify-between items-start">
                                                                                                <span className="truncate pr-1">{benefit.metric}</span>
                                                                                                {(() => {
                                                                                                    const monthSavings = calculateBenefitSavings(normalizedUseCase, benefit, monthData, benefitIndex);
                                                                                                    return monthSavings > 0 ? (
                                                                                                        <span className="text-green-600 font-bold text-right whitespace-nowrap">
                                                                                                            ${Math.round(monthSavings).toLocaleString()}
                                                                                                        </span>
                                                                                                    ) : null;
                                                                                                })()
                                                                                                }
                                                                                            </div>
                                                                                            <div className="space-y-1">
                                                                                                {/* Volume Input for this benefit */}
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <label className="text-[10px] text-gray-600 min-w-[45px] flex-shrink-0" title={volumeLabel}>{volumeLabel}:</label>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        placeholder="0"
                                                                                                        value={monthData[volumeFieldKey] || ''}
                                                                                                        data-field-key={volumeFieldKey}
                                                                                                        onChange={(e) => updateUseCaseData(useCase.id, month.id, volumeFieldKey, e.target.value)}
                                                                                                        className={`flex-1 min-w-0 px-2 py-1 text-xs border rounded ${
                                                                                                            unsavedChanges.has(`${useCase.id}-${month.id}-${volumeFieldKey}`) ? 'border-yellow-400 bg-yellow-50' : 'border-gray-200'
                                                                                                        }`}
                                                                                                        title={`Number of ${volumeLabel} for ${benefit.metric}`}
                                                                                                    />
                                                                                                </div>
                                                                                                {/* Improvement Input for this benefit */}
                                                                                                <div className="flex items-center gap-1">
                                                                                                    <label className="text-[10px] text-gray-600 min-w-[45px] flex-shrink-0">Impact:</label>
                                                                                                    <input
                                                                                                        type="number"
                                                                                                        placeholder={benefit.metric.includes('min') ? '0 min' : benefit.metric.includes('points') ? '0 pts' : '0%'}
                                                                                                        value={monthData[improvementFieldKey] || ''}
                                                                                                        data-field-key={improvementFieldKey}
                                                                                                        onChange={(e) => updateUseCaseData(useCase.id, month.id, improvementFieldKey, e.target.value)}
                                                                                                        className={`flex-1 min-w-0 px-2 py-1 text-xs border rounded ${
                                                                                                            unsavedChanges.has(`${useCase.id}-${month.id}-${improvementFieldKey}`) ? 'border-yellow-400 bg-yellow-50' : 'border-gray-200'
                                                                                                        }`}
                                                                                                        title={`Improvement value for ${benefit.metric}`}
                                                                                                    />
                                                                                                </div>
                                                                                            </div>
                                                                                        </div>
                                                                                    );
                                                                                })
                                                                            )}
                                                                            
                                                                            {/* Monthly Savings Total */}
                                                                            {(savings > 0 || (normalizedUseCase.benefits.length > 0 && Object.keys(monthData).some(k => k.includes('volume') || k.includes('improvement')))) && (
                                                                                <div className="text-xs font-bold text-green-600 text-center mt-1 pt-1 border-t border-gray-300">
                                                                                    Total: ${Math.round(savings).toLocaleString()}
                                                                                </div>
                                                                            )}
                                                                            
                                                                            {/* Quick Action Buttons - Always visible in bulk mode */}
                                                                            {bulkEditMode && (
                                                                                <div className="mt-3 pt-2 border-t border-gray-200 flex gap-1 justify-center">
                                                                                    <button
                                                                                        onClick={() => applyToAllMonths(useCase.id, month.id)}
                                                                                        className="px-2 py-1 text-xs bg-blue-500 text-white hover:bg-blue-600 rounded"
                                                                                        title={`Copy all ${normalizedUseCase.benefits.length} benefit${normalizedUseCase.benefits.length > 1 ? 's' : ''} data (volumes & improvements) from ${month.month} to all other months`}
                                                                                    >
                                                                                        Fill→
                                                                                    </button>
                                                                                    <button
                                                                                        onClick={() => copyPreviousMonth(useCase.id, month.id)}
                                                                                        className="px-2 py-1 text-xs bg-gray-500 text-white hover:bg-gray-600 rounded"
                                                                                        title={`Copy all benefit data from previous month to ${month.month}`}
                                                                                        disabled={months.findIndex(m => m.id === month.id) === 0}
                                                                                    >
                                                                                        ←Copy
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </td>
                                                                );
                                                            })}
                                                            <td className="px-2 py-1.5 text-xs">
                                                                <div className="font-bold text-green-600">
                                                                    ${Math.round(totalSavings).toLocaleString()}
                                                                </div>
                                                                {normalizedUseCase.benefits.length > 1 && (
                                                                    <div className="mt-1 space-y-0.5 text-[10px] text-green-700">
                                                                        {perBenefitTotals.map(([metric, value]) => (
                                                                            <div key={metric} className="flex justify-between gap-2">
                                                                                <span className="truncate max-w-[140px]">{metric.split('(')[0].trim()}</span>
                                                                                <span>${Math.round(value).toLocaleString()}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                )}
                                                            </td>
                                                            <td className="px-2 py-1.5">
                                                                <div className="flex gap-0.5">
                                                                    {/* Edit Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            const normalizedUC = ensureUseCaseHasBenefits(useCase);
                                                                            setEditingUseCase({...normalizedUC});
                                                                            setShowEditModal(true);
                                                                        }}
                                                                        className="text-green-600 hover:text-green-800 p-1"
                                                                        title="Edit use case benefits"
                                                                    >
                                                                        <Icons.Edit />
                                                                    </button>
                                                                    
                                                                    {/* Duplicate Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                            setRedoStack([]);
                                                                            const duplicated = {
                                                                                ...useCase,
                                                                                id: Date.now() + Math.random(),
                                                                                name: `${useCase.name} (Copy)`
                                                                            };
                                                                            setUseCases([...useCases, duplicated]);
                                                                        }}
                                                                        className="text-blue-600 hover:text-blue-800 p-1"
                                                                        title="Duplicate use case"
                                                                    >
                                                                        <Icons.Copy />
                                                                    </button>
                                                                    
                                                                    {/* Clear Data for this Use Case */}
                                                                    <button
                                                                        onClick={() => {
                                                                            if (confirm('Clear all data for this use case?')) {
                                                                                setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                                                setRedoStack([]);
                                                                                setUseCases(useCases.map(uc => 
                                                                                    uc.id === useCase.id ? {...uc, data: {}} : uc
                                                                                ));
                                                                            }
                                                                        }}
                                                                        className="text-yellow-600 hover:text-yellow-800 p-1"
                                                                        title="Clear all data for this use case"
                                                                    >
                                                                        <Icons.RefreshCw />
                                                                    </button>
                                                                    
                                                                    {/* Delete Use Case */}
                                                                    <button
                                                                        onClick={() => removeUseCase(useCase.id)}
                                                                        className="text-red-600 hover:text-red-800 p-1"
                                                                        title="Delete use case"
                                                                    >
                                                                        <Icons.Trash />
                                                                    </button>
                                                                </div>
                                                            </td>
                                                        </tr>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </>
                        )}

                        {/* Analytics Tab */}
                        {activeTab === 'analytics' && (
                            <div className="space-y-6">
                                {/* Analytics Controls */}
                                <div className="bg-white rounded-lg shadow-lg p-4">
                                    {/* First Row: View Title and Tabs */}
                                    <div className="flex justify-between items-center mb-3">
                                        <h3 className="font-semibold flex items-center gap-2">
                                            <Icons.Chart /> Analytics View
                                        </h3>
                                        <div className={`${isMobile ? 'grid grid-cols-3 gap-1' : 'flex gap-1'}`}>
                                            <button onClick={() => setAnalyticsView('overall')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'overall' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Overall</button>
                                            <button onClick={() => setAnalyticsView('category')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'category' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Category</button>
                                            <button onClick={() => setAnalyticsView('channel')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'channel' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Channel</button>
                                            <button onClick={() => setAnalyticsView('benefit')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'benefit' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Benefit</button>
                                            <button onClick={() => setAnalyticsView('usecase')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'usecase' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Use Case</button>
                                            <button onClick={() => setAnalyticsView('specialgroup')} className={`px-3 py-1 text-xs rounded ${analyticsView === 'specialgroup' ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200'}`}>Special Group</button>
                                        </div>
                                    </div>

                                    {/* Second Row: Filters on same line */}
                                    <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-center gap-4'} pt-3 border-t`}>
                                        <span className={`text-xs font-medium text-gray-600 ${isMobile ? 'mb-2' : ''}`}>Filters:</span>
                                        
                                        <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-4 items-center'}`}>
                                            {/* Category Filter - Available for all views except 'category' */}
                                            {analyticsView !== 'category' && (
                                                <select value={selectedCategory} onChange={(e) => setSelectedCategory(e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                    <option value="all">All Categories</option>
                                                    {getCategories().map(cat => (<option key={cat} value={cat}>{cat}</option>))}
                                                </select>
                                            )}
                                            
                                            {/* Channel Filter - Available for all views except 'channel' */}
                                            {analyticsView !== 'channel' && (
                                                <select value={selectedChannel} onChange={(e) => setSelectedChannel(e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                    <option value="all">All Channels</option>
                                                    {ALL_CHANNELS.map(ch => (<option key={ch.id} value={ch.id} className="capitalize">{ch.label}</option>))}
                                                </select>
                                            )}
                                            
                                            {/* Special Group Filter - Available for all views except 'specialgroup' */}
                                            {analyticsView !== 'specialgroup' && (
                                                <select value={selectedSpecialGroup || 'all'} onChange={(e) => setSelectedSpecialGroup(e.target.value === 'all' ? null : e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                    <option value="all">All Groups</option>
                                                    <option value="none">No Special Group</option>
                                                    {getAllSpecialGroups().map(sg => (<option key={sg} value={sg}>{sg}</option>))}
                                                </select>
                                            )}
                                            
                                            {/* Metric Filter - Available for overall and usecase views */}
                                            {(analyticsView === 'overall' || analyticsView === 'usecase' || analyticsView === 'benefit') && (
                                                <select value={selectedMetric || 'all'} onChange={(e) => setSelectedMetric(e.target.value === 'all' ? null : e.target.value)} className="px-2 py-1 border rounded text-xs">
                                                    <option value="all">All Metrics</option>
                                                    {[...new Set(useCases.flatMap(uc => {
                                                            const normalized = ensureUseCaseHasBenefits(uc);
                                                            return normalized.benefits.map(benefit => benefit.metric);
                                                        }))].map(metric => (<option key={metric} value={metric}>{metric}</option>))}
                                                </select>
                                            )}
                                        </div>
                                        
                                        {/* Clear Filters Button */}
                                        <button 
                                            onClick={() => {
                                                setSelectedCategory('all');
                                                setSelectedChannel('all');
                                                setSelectedSpecialGroup(null);
                                                setSelectedMetric(null);
                                            }}
                                            className={`px-2 py-1 text-xs bg-gray-100 text-gray-600 rounded hover:bg-gray-200 ${isMobile ? 'col-span-2 mt-2' : 'ml-auto'}`}
                                            title="Clear all filters"
                                        >
                                            ✕ Clear
                                        </button>
                                        
                                        {/* Active Filters Count */}
                                        <div className="flex items-center text-xs text-blue-600">
                                            {(() => {
                                                let activeFilters = 0;
                                                if (selectedCategory !== 'all') activeFilters++;
                                                if (selectedChannel !== 'all') activeFilters++;
                                                if (selectedSpecialGroup) activeFilters++;
                                                if (selectedMetric) activeFilters++;
                                                return activeFilters > 0 ? `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active` : 'No filters applied';
                                            })()} • {getFilteredUseCases().length} of {useCases.length} use cases
                                        </div>
                                    </div>

                                    {/* Date Range Selector */}
                                    <div className={`mt-4 ${isMobile ? 'space-y-3' : 'date-range-picker'}`}>
                                        <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex gap-4'}`}>
                                            <div className="date-input-group flex-1">
                                                <label className="date-label text-xs">Start Month</label>
                                                <input type="month" value={analyticsDateRange.start} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, start: e.target.value })} className="date-input w-full" />
                                            </div>
                                            <div className="date-input-group flex-1">
                                                <label className="date-label text-xs">End Month</label>
                                                <input type="month" value={analyticsDateRange.end} onChange={(e) => setAnalyticsDateRange({ ...analyticsDateRange, end: e.target.value })} className="date-input w-full" />
                                            </div>
                                        </div>
                                        <div className={`${isMobile ? 'flex flex-col gap-2' : 'flex items-end'}`}>
                                            <div className={`px-4 py-2 bg-blue-100 text-blue-700 rounded ${isMobile ? 'text-center' : ''}`}>Analyzing {getFilteredMonths().length} months</div>
                                            <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'ml-auto flex gap-2'}`}>
                                                <button onClick={exportAnalyticsCSV} className="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm">Export CSV</button>
                                                <button onClick={exportAnalyticsExcel} className="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm">Export Excel</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Overall View - Charts */}
                                {analyticsView === 'overall' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'}`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Monthly Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.monthly}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Cumulative Savings</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.cumulative}></canvas></div>
                                            </div>
                                        </div>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'}`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Savings by Category</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.category}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channel}></canvas></div>
                                            </div>
                                        </div>
                                    </>
                                )}

                                {/* Category View - Charts and Table */}
                                {analyticsView === 'category' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Category Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.categoryBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Category Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Savings = Volume × (Improvement - Baseline) × Effective Cost per Contact. 
                                                Effective cost is determined by hierarchy: Special Group {'>'} Category {'>'} Channel defaults. 
                                                For AHT metrics, costs are converted to per-minute rates.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Category</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Avg Savings/Contact<br /><small>($/contact)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const categoryStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        if (!categoryStats[uc.category]) categoryStats[uc.category] = { useCases: [], volume: 0, savings: 0 };
                                                        categoryStats[uc.category].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            categoryStats[uc.category].volume += getTotalVolumeForUseCaseMonth(uc, md);
                                                            categoryStats[uc.category].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(categoryStats).map(([category, stats]) => (
                                                        <tr key={category}>
                                                            <td className="font-semibold">{category}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{stats.volume > 0 ? (stats.savings / stats.volume).toFixed(2) : '0.00'}</td>
                                                            <td>{(() => {
                                                                if (totalSavingsAll <= 0) return '0%';
                                                                const percentage = (stats.savings / totalSavingsAll * 100);
                                                                
                                                                // Check if there are other categories with non-zero savings
                                                                const otherCategoriesHaveSavings = Object.values(categoryStats).some(
                                                                    otherStats => otherStats !== stats && otherStats.savings > 0
                                                                );
                                                                
                                                                if (percentage > 0 && percentage < 0.1) {
                                                                    return '<0.1%';
                                                                } else if (percentage > 99.9 && percentage < 100 && otherCategoriesHaveSavings) {
                                                                    return '>99.9%';
                                                                }
                                                                return `${percentage.toFixed(1)}%`;
                                                            })()}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Channel View - Charts and Table */}
                                {analyticsView === 'channel' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Channel Performance</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.channelBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Channel Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Shows performance across communication channels. 
                                                Default costs can be overridden by category settings or special group pricing. 
                                                Improvement values shown are the average across all use cases in each channel.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Channel</th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>Default Cost<br /><small>($/contact)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const channelStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        if (!channelStats[uc.channel]) channelStats[uc.channel] = { useCases: [], volume: 0, savings: 0, improvements: [] };
                                                        channelStats[uc.channel].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            channelStats[uc.channel].volume += getTotalVolumeForUseCaseMonth(normalizedUC, md);
                                                            channelStats[uc.channel].savings += calculateSavings(uc, month.id);
                                                            // Collect improvements across benefits for averaging
                                                            (normalizedUC.benefits || []).forEach((benefit, i) => {
                                                                const fieldKey = (normalizedUC.benefits.length === 1)
                                                                    ? `improvement_${benefit.metric}`
                                                                    : `improvement_${i}_${benefit.metric}`;
                                                                if (md[fieldKey] != null) {
                                                                    channelStats[uc.channel].improvements.push(parseFloat(md[fieldKey]) || 0);
                                                                }
                                                            });
                                                        });
                                                    });
                                                    return Object.entries(channelStats).map(([channel, stats]) => {
                                                        const avgImprovement = stats.improvements.length ? (stats.improvements.reduce((a,b)=>a+b,0)/stats.improvements.length) : 0;
                                                        return (
                                                            <tr key={channel}>
                                                                <td className="font-semibold capitalize">{channel}</td>
                                                                <td>{stats.useCases.length}</td>
                                                                <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                                <td>{`$${getChannelCostValue(channel)}`}</td>
                                                                <td>{avgImprovement.toFixed(1)}%</td>
                                                                <td>{(() => {
                                                                    if (totalSavingsAll <= 0) return '0%';
                                                                    const percentage = (stats.savings / totalSavingsAll * 100);
                                                                    
                                                                    // Check if there are other channels with non-zero savings
                                                                    const otherChannelsHaveSavings = Object.values(channelStats).some(
                                                                        otherStats => otherStats !== stats && otherStats.savings > 0
                                                                    );
                                                                    
                                                                    if (percentage > 0 && percentage < 0.1) {
                                                                        return '<0.1%';
                                                                    } else if (percentage > 99.9 && percentage < 100 && otherChannelsHaveSavings) {
                                                                        return '>99.9%';
                                                                    }
                                                                    return `${percentage.toFixed(1)}%`;
                                                                })()}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                    </div>
                                    </>
                                )}

                                {/* Benefit View - Shows all benefits across use cases */}
                                {analyticsView === 'benefit' && (
                                    <>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Benefit Type Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>View Benefits Across All Use Cases:</strong> This view aggregates all benefits by type, showing which specific improvements drive the most value across your entire AI implementation.
                                                <div className="mt-2 text-xs">
                                                    <strong>Note on Percentages:</strong> The "% of Total Value" shows each benefit type's contribution to the overall savings. 
                                                    Since use cases can have multiple benefits, percentages may sum to more than 100%. For example, if one use case saves $1000 through 
                                                    both AHT reduction ($600) and deflection ($400), both benefits are credited with their respective contributions.
                                                </div>
                                            </div>
                                            <table className="analytics-table">
                                                <thead>
                                                    <tr>
                                                        <th>Benefit Type</th>
                                                        <th>Use Cases<br /><small>Using This Benefit</small></th>
                                                        <th>Total Volume<br /><small>(varies by type)</small></th>
                                                        <th>Avg Improvement<br /><small>(net of baseline)</small></th>
                                                        <th>Total Value<br /><small>($)</small></th>
                                                        <th>% of Total<br /><small>Value</small></th>
                                                        <th>Top Use Case<br /><small>(by value)</small></th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {(() => {
                                                        const filteredMonths = getFilteredMonths();
                                                        const benefitStats = {};
                                                        const totalSavingsAll = calculateTotalSavings();
                                                        
                                                        // Aggregate data by benefit type
                                                        const filteredUseCases = getFilteredUseCases();
                                                        filteredUseCases.forEach(uc => {
                                                            const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                            
                                                            normalizedUC.benefits.forEach((benefit, benefitIndex) => {
                                                                const metric = benefit.metric;
                                                                
                                                                // Skip if metric filter is set and doesn't match
                                                                if (selectedMetric && metric !== selectedMetric) {
                                                                    return;
                                                                }
                                                                
                                                                if (!benefitStats[metric]) {
                                                                    benefitStats[metric] = {
                                                                        useCases: [],
                                                                        volumes: [],
                                                                        improvements: [],
                                                                        savings: 0,
                                                                        useCaseValues: {}
                                                                    };
                                                                }
                                                                
                                                                benefitStats[metric].useCases.push(uc.name);
                                                                
                                                                // Calculate savings and collect data for this benefit
                                                                filteredMonths.forEach(month => {
                                                                    const md = uc.data[month.id] || {};
                                                                    const breakdown = calculateSavingsBreakdown(uc, month.id);
                                                                    
                                                                    // Find this specific benefit's contribution
                                                                    breakdown.breakdown.forEach(item => {
                                                                        if (item.metric === metric) {
                                                                            benefitStats[metric].savings += item.savings;
                                                                            
                                                                            if (!benefitStats[metric].useCaseValues[uc.name]) {
                                                                                benefitStats[metric].useCaseValues[uc.name] = 0;
                                                                            }
                                                                            benefitStats[metric].useCaseValues[uc.name] += item.savings;
                                                                        }
                                                                    });
                                                                    
                                                                    // Collect volume and improvement data
                                                                    const volumeFieldKey = normalizedUC.benefits.length === 1 
                                                                        ? `volume_${metric}`
                                                                        : `volume_${benefitIndex}_${metric}`;
                                                                    const improvementFieldKey = normalizedUC.benefits.length === 1 
                                                                        ? `improvement_${metric}`
                                                                        : `improvement_${benefitIndex}_${metric}`;
                                                                    
                                                                    const volume = parseFloat(md[volumeFieldKey]) || 0;
                                                                    const improvement = parseFloat(md[improvementFieldKey]) || 0;
                                                                    
                                                                    if (volume > 0) benefitStats[metric].volumes.push(volume);
                                                                    if (improvement !== 0) benefitStats[metric].improvements.push(improvement);
                                                                });
                                                            });
                                                        });
                                                        
                                                        // Sort by total savings
                                                        const sortedBenefits = Object.entries(benefitStats)
                                                            .sort((a, b) => b[1].savings - a[1].savings);
                                                        
                                                        return sortedBenefits.map(([metric, stats]) => {
                                                            const uniqueUseCases = [...new Set(stats.useCases)];
                                                            const avgImprovement = stats.improvements.length 
                                                                ? stats.improvements.reduce((a, b) => a + b, 0) / stats.improvements.length 
                                                                : 0;
                                                            const totalVolume = stats.volumes.reduce((a, b) => a + b, 0);
                                                            
                                                            // Find top contributing use case
                                                            const topUseCase = Object.entries(stats.useCaseValues)
                                                                .sort((a, b) => b[1] - a[1])[0];
                                                            
                                                            // Format improvement display
                                                            let improvementStr = '';
                                                            if (metric.includes('min')) {
                                                                improvementStr = `${avgImprovement.toFixed(1)} minutes`;
                                                            } else if (metric.includes('points')) {
                                                                improvementStr = `${avgImprovement.toFixed(1)} points`;
                                                            } else {
                                                                improvementStr = `${avgImprovement.toFixed(1)}%`;
                                                            }
                                                            
                                                            // Get volume label
                                                            const volumeLabel = getVolumeLabel(metric);
                                                            
                                                            return (
                                                                <tr key={metric}>
                                                                    <td className="font-semibold">{metric}</td>
                                                                    <td title={uniqueUseCases.join(', ')}>
                                                                        {uniqueUseCases.length} use case{uniqueUseCases.length !== 1 ? 's' : ''}
                                                                    </td>
                                                                    <td>
                                                                        {Math.round(totalVolume).toLocaleString()}
                                                                        <br />
                                                                        <small className="text-gray-500">{volumeLabel}</small>
                                                                    </td>
                                                                    <td>{improvementStr}</td>
                                                                    <td className="font-bold text-green-600">
                                                                        ${Math.round(stats.savings).toLocaleString()}
                                                                    </td>
                                                                    <td>
                                                                        {totalSavingsAll > 0 
                                                                            ? `${(stats.savings / totalSavingsAll * 100).toFixed(1)}%`
                                                                            : '0%'}
                                                                    </td>
                                                                    <td className="text-sm">
                                                                        {topUseCase ? (
                                                                            <>
                                                                                {topUseCase[0]}
                                                                                <br />
                                                                                <small className="text-gray-500">
                                                                                    (${Math.round(topUseCase[1]).toLocaleString()})
                                                                                </small>
                                                                            </>
                                                                        ) : '-'}
                                                                    </td>
                                                                </tr>
                                                            );
                                                        });
                                                    })()}
                                                </tbody>
                                            </table>
                                        </div>
                                    </>
                                )}

                                {/* Use Case View - Charts and Table */}
                                {analyticsView === 'usecase' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Top 5 Use Cases Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Use Case Performance Ranking</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.usecaseBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Individual Use Case Performance</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Each use case's savings are calculated using its specific cost hierarchy. 
                                                Improvement values are net of baseline (e.g., if current deflection is 70% and baseline is 10%, net improvement is 60%). 
                                                For AHT metrics, improvements shown in minutes are converted to hourly cost savings.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Use Case</th><th>Category</th><th>Channel</th><th>Benefits</th><th>Special Group</th><th>Total Volume<br /><small>(contacts)</small></th><th>Avg Improvement<br /><small>(% or min)</small></th><th>Total Savings<br /><small>($)</small></th><th>Top Contributor<br /><small>(% of UC savings)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    const filteredUseCases = getFilteredUseCases();
                                                    return filteredUseCases.map(uc => {
                                                        const normalizedUC = ensureUseCaseHasBenefits(uc);
                                                        let totalVolume = 0, totalSavings = 0;
                                                        const benefitImprovements = {};
                                                        const benefitSavingsByMonth = {};
                                                        
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            totalVolume += getTotalVolumeForUseCaseMonth(uc, md);
                                                            totalSavings += calculateSavings(uc, month.id);
                                                            
                                                            // Get detailed breakdown for this month
                                                            const breakdown = calculateSavingsBreakdown(uc, month.id);
                                                            breakdown.breakdown.forEach(item => {
                                                                if (!benefitSavingsByMonth[item.metric]) {
                                                                    benefitSavingsByMonth[item.metric] = 0;
                                                                }
                                                                benefitSavingsByMonth[item.metric] += item.savings;
                                                            });
                                                            
                                                            // Collect improvements for each benefit
                                                            normalizedUC.benefits.forEach((benefit, index) => {
                                                                const fieldKey = normalizedUC.benefits.length === 1 
                                                                    ? `improvement_${benefit.metric}`
                                                                    : `improvement_${index}_${benefit.metric}`;
                                                                if (!benefitImprovements[benefit.metric]) {
                                                                    benefitImprovements[benefit.metric] = [];
                                                                }
                                                                if (md[fieldKey] != null) {
                                                                    benefitImprovements[benefit.metric].push(parseFloat(md[fieldKey]) || 0);
                                                                }
                                                            });
                                                        });
                                                        
                                                        // Find top contributing benefit
                                                        let topContributor = { metric: '-', percentage: 0 };
                                                        if (totalSavings > 0) {
                                                            Object.entries(benefitSavingsByMonth).forEach(([metric, savings]) => {
                                                                const percentage = (savings / totalSavings * 100);
                                                                if (percentage > topContributor.percentage) {
                                                                    topContributor = { metric, percentage };
                                                                }
                                                            });
                                                        }
                                                        
                                                        // Format benefits and average improvements for display with metric names
                                                        const benefitSummary = normalizedUC.benefits.map(b => b.metric).join(', ');
                                                        let avgImprovementStr = '';
                                                        let avgImprovementTitle = '';
                                                        if (normalizedUC.benefits.length === 1) {
                                                            // Single benefit - show just the value
                                                            const benefit = normalizedUC.benefits[0];
                                                            const improvements = benefitImprovements[benefit.metric] || [];
                                                            const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                            if (benefit.metric.includes('min')) avgImprovementStr = `${avg.toFixed(1)} min`;
                                                            else if (benefit.metric.includes('points')) avgImprovementStr = `${avg.toFixed(1)} pts`;
                                                            else avgImprovementStr = `${avg.toFixed(1)}%`;
                                                        } else {
                                                            // Multiple benefits - create mini tags for display
                                                            const breakdownParts = normalizedUC.benefits.slice(0, 3).map(benefit => {
                                                                const improvements = benefitImprovements[benefit.metric] || [];
                                                                const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                                const shortName = benefit.metric.split('(')[0].trim();
                                                                
                                                                // Pick a color based on metric type
                                                                let bgColor = 'bg-blue-100 text-blue-800';
                                                                if (benefit.metric.includes('AHT')) bgColor = 'bg-green-100 text-green-800';
                                                                else if (benefit.metric.includes('NPS') || benefit.metric.includes('CSAT')) bgColor = 'bg-purple-100 text-purple-800';
                                                                else if (benefit.metric.includes('Conversion') || benefit.metric.includes('Revenue')) bgColor = 'bg-yellow-100 text-yellow-800';
                                                                else if (benefit.metric.includes('Compliance')) bgColor = 'bg-red-100 text-red-800';
                                                                
                                                                let value = '';
                                                                if (benefit.metric.includes('min')) value = `${avg.toFixed(1)}min`;
                                                                else if (benefit.metric.includes('points')) value = `${avg.toFixed(1)}pts`;
                                                                else value = `${avg.toFixed(1)}%`;
                                                                
                                                                return { shortName, value, bgColor };
                                                            });
                                                            
                                                            // If more than 3 benefits, add a "+X more" indicator
                                                            const hasMore = normalizedUC.benefits.length > 3;
                                                            const moreCount = normalizedUC.benefits.length - 3;
                                                            
                                                            avgImprovementStr = breakdownParts;
                                                            avgImprovementTitle = normalizedUC.benefits.map(benefit => {
                                                                const improvements = benefitImprovements[benefit.metric] || [];
                                                                const avg = improvements.length ? (improvements.reduce((a,b)=>a+b,0)/improvements.length) : 0;
                                                                const shortName = benefit.metric.split('(')[0].trim();
                                                                if (benefit.metric.includes('min')) return `${shortName}: ${avg.toFixed(1)}min`;
                                                                if (benefit.metric.includes('points')) return `${shortName}: ${avg.toFixed(1)}pts`;
                                                                return `${shortName}: ${avg.toFixed(1)}%`;
                                                            }).join(', ');
                                                            
                                                            if (hasMore) {
                                                                avgImprovementStr.moreCount = moreCount;
                                                            }
                                                        }
                                                        
                                                        // Format top contributor display
                                                        const topContributorStr = topContributor.metric !== '-' 
                                                            ? `${topContributor.metric.split('(')[0].trim()} (${topContributor.percentage.toFixed(0)}%)`
                                                            : '-';
                                                        
                                                        return (
                                                            <tr key={uc.id}>
                                                                <td className="font-semibold">{uc.name}</td>
                                                                <td>{uc.category}</td>
                                                                <td className="capitalize">{uc.channel}</td>
                                                                <td title={benefitSummary}>{normalizedUC.benefits.length} benefit{normalizedUC.benefits.length !== 1 ? 's' : ''}</td>
                                                                <td>{uc.specialGroup || '-'}</td>
                                                                <td>{Math.round(totalVolume).toLocaleString()}</td>
                                                                <td title={avgImprovementTitle || null}>
                                                                    {typeof avgImprovementStr === 'string' ? (
                                                                        avgImprovementStr
                                                                    ) : (
                                                                        <div className="flex flex-wrap gap-1">
                                                                            {avgImprovementStr.map((item, idx) => (
                                                                                <span key={idx} className={`inline-block px-1.5 py-0.5 text-[10px] rounded ${item.bgColor}`}>
                                                                                    {item.shortName}: {item.value}
                                                                                </span>
                                                                            ))}
                                                                            {avgImprovementStr.moreCount && (
                                                                                <span className="inline-block px-1.5 py-0.5 text-[10px] rounded bg-gray-100 text-gray-600">
                                                                                    +{avgImprovementStr.moreCount} more
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                </td>
                                                                <td className="font-bold text-green-600">{`$${Math.round(totalSavings).toLocaleString()}`}</td>
                                                                <td className="text-sm">{topContributorStr}</td>
                                                                <td>{(() => {
                                                                    if (totalSavingsAll <= 0) return '0%';
                                                                    const percentage = (totalSavings / totalSavingsAll * 100);
                                                                    
                                                                    // Check if there are other use cases with non-zero savings
                                                                    const otherUseCasesHaveSavings = useCases.some(otherUC => {
                                                                        if (otherUC.id === uc.id) return false;
                                                                        let otherSavings = 0;
                                                                        filteredMonths.forEach(month => {
                                                                            otherSavings += calculateSavings(otherUC, month.id);
                                                                        });
                                                                        return otherSavings > 0;
                                                                    });
                                                                    
                                                                    if (percentage > 0 && percentage < 0.1) {
                                                                        return '<0.1%';
                                                                    } else if (percentage > 99.9 && percentage < 100 && otherUseCasesHaveSavings) {
                                                                        return '>99.9%';
                                                                    }
                                                                    return `${percentage.toFixed(1)}%`;
                                                                })()}</td>
                                                            </tr>
                                                        );
                                                    });
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}

                                {/* Special Group View - Charts and Table */}
                                {analyticsView === 'specialgroup' && (
                                    <>
                                        <div className={`${isMobile ? 'grid grid-cols-1 gap-4' : 'grid grid-cols-2 gap-6'} mb-6`}>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Savings Trend</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupTrend}></canvas></div>
                                            </div>
                                            <div className="bg-white rounded-lg shadow-lg p-6">
                                                <h3 className="text-lg font-semibold mb-4">Special Group Distribution</h3>
                                                <div className="chart-container"><canvas ref={chartRefs.specialgroupBreakdown}></canvas></div>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-2">Special Group Performance Analysis</h3>
                                            <div className="text-sm text-gray-600 mb-4 p-3 bg-blue-50 rounded">
                                                <strong>Calculation Note:</strong> Special groups have the highest priority in cost calculations, overriding both category and channel defaults. 
                                                Hourly rates are converted to per-contact costs using the group's configured AHT. 
                                                "No Special Group" shows use cases using category or channel default costs.
                                            </div>
                                        <table className="analytics-table">
                                            <thead>
                                                <tr>
                                                    <th>Special Group</th><th>Cost Type</th><th>Rate<br /><small>($/hr or $/contact)</small></th><th>Use Cases</th><th>Total Volume<br /><small>(contacts)</small></th><th>Total Savings<br /><small>($)</small></th><th>% of Total<br /><small>Savings</small></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {(() => {
                                                    const groupStats = {};
                                                    const totalSavingsAll = calculateTotalSavings();
                                                    const filteredMonths = getFilteredMonths();
                                                    // Initialize No Special Group
                                                    groupStats['No Special Group'] = { costType: 'varies', value: '-', useCases: [], volume: 0, savings: 0 };
                                                    
                                                    // Initialize all special groups with their cost info
                                                    getAllSpecialGroups().forEach(group => {
                                                        let groupFound = false;
                                                        let groupCostType = 'perContact';
                                                        let groupValue = 0;
                                                        
                                                        // Search through all category-channel combinations for this special group
                                                        Object.values(categoryCosts).forEach(categoryData => {
                                                            if (!groupFound) {
                                                                Object.values(categoryData).forEach(channelData => {
                                                                    if (!groupFound && channelData && channelData._specialGroups && channelData._specialGroups[group]) {
                                                                        const groupCost = channelData._specialGroups[group];
                                                                        groupCostType = groupCost.costType || 'perContact';
                                                                        groupValue = groupCost.value || 0;
                                                                        groupFound = true;
                                                                    }
                                                                });
                                                            }
                                                        });
                                                        
                                                        groupStats[group] = { 
                                                            costType: groupCostType,
                                                            value: groupValue,
                                                            useCases: [], 
                                                            volume: 0, 
                                                            savings: 0 
                                                        };
                                                    });
                                                    
                                                    const filteredUseCases = getFilteredUseCases();
                                                    filteredUseCases.forEach(uc => {
                                                        const key = uc.specialGroup || 'No Special Group';
                                                        
                                                        // Ensure the group exists in stats (in case of data inconsistency)
                                                        if (!groupStats[key]) {
                                                            groupStats[key] = { costType: 'perContact', value: 0, useCases: [], volume: 0, savings: 0 };
                                                        }
                                                        
                                                        groupStats[key].useCases.push(uc.name);
                                                        filteredMonths.forEach(month => {
                                                            const md = uc.data[month.id] || {};
                                                            groupStats[key].volume += getTotalVolumeForUseCaseMonth(uc, md);
                                                            groupStats[key].savings += calculateSavings(uc, month.id);
                                                        });
                                                    });
                                                    return Object.entries(groupStats).map(([group, stats]) => (
                                                        <tr key={group}>
                                                            <td className="font-semibold">{group}</td>
                                                            <td className="capitalize">{stats.costType}</td>
                                                            <td>{stats.value !== '-' ? `$${stats.value} ${stats.costType === 'hourly' ? '/hr' : '/contact'}` : '-'}</td>
                                                            <td>{stats.useCases.length}</td>
                                                            <td>{Math.round(stats.volume).toLocaleString()}</td>
                                                            <td className="font-bold text-green-600">{`$${Math.round(stats.savings).toLocaleString()}`}</td>
                                                            <td>{(() => {
                                                                if (totalSavingsAll <= 0) return '0%';
                                                                const percentage = (stats.savings / totalSavingsAll * 100);
                                                                
                                                                // Check if there are other groups with non-zero savings
                                                                const otherGroupsHaveSavings = Object.values(groupStats).some(
                                                                    otherStats => otherStats !== stats && otherStats.savings > 0
                                                                );
                                                                
                                                                if (percentage > 0 && percentage < 0.1) {
                                                                    return '<0.1%';
                                                                } else if (percentage > 99.9 && percentage < 100 && otherGroupsHaveSavings) {
                                                                    return '>99.9%';
                                                                }
                                                                return `${percentage.toFixed(1)}%`;
                                                            })()}</td>
                                                        </tr>
                                                    ));
                                                })()}
                                            </tbody>
                                        </table>
                                        </div>
                                    </>
                                )}
                            </div>
                        )}

                        {/* Financial Analysis Tab */}
                        {activeTab === 'financial' && (
                            <div className="space-y-6">
                                {/* Filter Controls */}
                                <div className="bg-white rounded-lg shadow-lg p-4">
                                    <div className={`${isMobile ? 'flex flex-col gap-3' : 'flex items-center gap-4'}`}>
                                        <div className={`${isMobile ? 'flex justify-between items-center' : 'flex items-center gap-4'}`}>
                                            <span className="text-sm font-medium text-gray-600">Filters:</span>
                                            {isMobile && (
                                                <button
                                                    onClick={() => {
                                                        setSelectedCategory('all');
                                                        setSelectedChannel('all');
                                                        setSelectedSpecialGroup(null);
                                                        setSelectedMetric(null);
                                                    }}
                                                    className="px-3 py-1 text-sm text-blue-600 hover:text-blue-700"
                                                >
                                                    Clear
                                                </button>
                                            )}
                                        </div>
                                        
                                        <div className={`${isMobile ? 'grid grid-cols-2 gap-2' : 'flex gap-4 items-center flex-1'}`}>
                                            {/* Category Filter */}
                                            <select 
                                                value={selectedCategory} 
                                                onChange={(e) => setSelectedCategory(e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Categories</option>
                                                {getCategories().map(cat => (
                                                    <option key={cat} value={cat}>{cat}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Channel Filter */}
                                            <select 
                                                value={selectedChannel} 
                                                onChange={(e) => setSelectedChannel(e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Channels</option>
                                                {ALL_CHANNELS.map(ch => (
                                                    <option key={ch.id} value={ch.id} className="capitalize">
                                                        {ch.label}
                                                    </option>
                                                ))}
                                            </select>
                                            
                                            {/* Special Group Filter */}
                                            <select 
                                                value={selectedSpecialGroup || ''} 
                                                onChange={(e) => setSelectedSpecialGroup(e.target.value || null)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="">All Groups</option>
                                                <option value="none">No Special Group</option>
                                                {Array.from(new Set(
                                                    useCases
                                                        .map(uc => uc.specialGroup)
                                                        .filter(sg => sg)
                                                )).sort().map(group => (
                                                    <option key={group} value={group}>{group}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Benefit/Metric Filter */}
                                            <select 
                                                value={selectedMetric || 'all'} 
                                                onChange={(e) => setSelectedMetric(e.target.value === 'all' ? null : e.target.value)} 
                                                className="px-3 py-1.5 border rounded text-sm"
                                            >
                                                <option value="all">All Metrics</option>
                                                {[...new Set(useCases.flatMap(uc => {
                                                    const normalized = ensureUseCaseHasBenefits(uc);
                                                    return normalized.benefits.map(benefit => benefit.metric);
                                                }))].sort().map(metric => (
                                                    <option key={metric} value={metric}>{metric}</option>
                                                ))}
                                            </select>
                                            
                                            {/* Clear Filters Button - Desktop Only */}
                                            {!isMobile && (
                                                <button
                                                    onClick={() => {
                                                        setSelectedCategory('all');
                                                        setSelectedChannel('all');
                                                        setSelectedSpecialGroup(null);
                                                        setSelectedMetric(null);
                                                    }}
                                                    className="px-3 py-1.5 text-sm text-blue-600 hover:text-blue-700"
                                                >
                                                    Clear Filters
                                                </button>
                                            )}
                                        </div>
                                        
                                        {/* Active Filter Count */}
                                        <div className={`text-sm text-gray-600 ${isMobile ? 'text-center' : 'ml-auto'}`}>
                                            {(() => {
                                                let activeFilters = 0;
                                                if (selectedCategory !== 'all') activeFilters++;
                                                if (selectedChannel !== 'all') activeFilters++;
                                                if (selectedSpecialGroup) activeFilters++;
                                                if (selectedMetric) activeFilters++;
                                                return activeFilters > 0 
                                                    ? `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active • ${getFilteredUseCases().length} of ${useCases.length} use cases`
                                                    : `Showing all ${useCases.length} use cases`;
                                            })()}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Financial Settings Panel */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold flex items-center gap-2">
                                            💰 Implementation & Ongoing Costs
                                        </h3>
                                        <label className="flex items-center gap-2 text-sm">
                                            <input
                                                type="checkbox"
                                                checked={financialSettings.useCategoryBilling}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    useCategoryBilling: e.target.checked
                                                })}
                                                className="rounded"
                                            />
                                            Configure by Category
                                        </label>
                                    </div>
                                    
                                    {/* Show notice when category billing is enabled */}
                                    {financialSettings.useCategoryBilling && (
                                        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                                            <p className="text-sm text-yellow-800">
                                                ⚠️ <strong>Note:</strong> Overall implementation costs below are <strong>disabled</strong> when "Configure by Category" is enabled. 
                                                Category-specific costs configured below will be used instead.
                                            </p>
                                        </div>
                                    )}
                                    
                                    <div className={`grid grid-cols-1 md:grid-cols-2 gap-4 ${financialSettings.useCategoryBilling ? 'opacity-50 pointer-events-none' : ''}`}>
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                Implementation Cost Type
                                                {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                            </label>
                                            <select
                                                value={financialSettings.costType}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    costType: e.target.value
                                                })}
                                                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                disabled={financialSettings.useCategoryBilling}
                                            >
                                                <option value="fixed">Fixed Amount ($)</option>
                                                <option value="percentage">% of First Year Benefits</option>
                                            </select>
                                        </div>
                                        
                                        {financialSettings.costType === 'fixed' ? (
                                            <div>
                                                <label className="block text-sm font-medium mb-2">
                                                    Implementation Cost ($)
                                                    <span className="text-xs text-gray-500 ml-2">(Software, Training, Integration)</span>
                                                    {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                                </label>
                                                <input
                                                    type="number"
                                                    value={financialSettings.implementationCost}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        implementationCost: parseFloat(e.target.value) || 0
                                                    })}
                                                    className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                    placeholder="50000"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                            </div>
                                        ) : (
                                            <div>
                                                <label className="block text-sm font-medium mb-2">
                                                    Cost Percentage (%)
                                                    <span className="text-xs text-gray-500 ml-2">(of First Year Benefits)</span>
                                                    {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                                </label>
                                                <input
                                                    type="number"
                                                    value={financialSettings.costPercentage}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        costPercentage: parseFloat(e.target.value) || 0
                                                    })}
                                                    className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                    placeholder="20"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                            </div>
                                        )}
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                Discount Rate (%)
                                                <span className="text-xs text-gray-500 ml-2">(Typically 8-12%)</span>
                                            </label>
                                            <input
                                                type="number"
                                                value={financialSettings.discountRate * 100}
                                                onChange={(e) => setFinancialSettings({
                                                    ...financialSettings,
                                                    discountRate: (parseFloat(e.target.value) || 10) / 100
                                                })}
                                                className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                                                placeholder="10"
                                            />
                                            <div className="mt-2 p-3 bg-blue-50 rounded-lg text-xs text-gray-700">
                                                <strong>What is Discount Rate?</strong> It's your company's cost of capital or required return rate. 
                                                It accounts for the time value of money - a dollar today is worth more than a dollar tomorrow.
                                                <div className="mt-2">
                                                    <strong>How to determine it:</strong>
                                                    <ul className="list-disc list-inside mt-1 space-y-1">
                                                        <li><strong>Use your WACC</strong> (Weighted Average Cost of Capital) - typically 8-12% for most companies</li>
                                                        <li><strong>Conservative approach:</strong> Use 10% as a standard business case rate</li>
                                                        <li><strong>Tech companies:</strong> Often use 12-15% due to higher risk/return expectations</li>
                                                        <li><strong>Stable industries:</strong> May use 6-8% for lower risk projects</li>
                                                    </ul>
                                                </div>
                                                <div className="mt-2 font-medium">
                                                    💡 Ask your Finance team for your company's standard discount rate for NPV calculations.
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                <input
                                                    type="checkbox"
                                                    checked={financialSettings.includeOngoingCosts}
                                                    onChange={(e) => setFinancialSettings({
                                                        ...financialSettings,
                                                        includeOngoingCosts: e.target.checked
                                                    })}
                                                    className="mr-2"
                                                    disabled={financialSettings.useCategoryBilling}
                                                />
                                                Include Ongoing Monthly Costs
                                                {financialSettings.useCategoryBilling && <span className="text-xs text-red-600 ml-2">(Disabled)</span>}
                                            </label>
                                            {financialSettings.includeOngoingCosts && (
                                                <>
                                                    <input
                                                        type="number"
                                                        value={financialSettings.ongoingCostMonthly}
                                                        onChange={(e) => setFinancialSettings({
                                                            ...financialSettings,
                                                            ongoingCostMonthly: parseFloat(e.target.value) || 0
                                                        })}
                                                        className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 mt-2"
                                                        placeholder="Monthly subscription/maintenance cost"
                                                        disabled={financialSettings.useCategoryBilling}
                                                    />
                                                    {!financialSettings.useCategoryBilling && (
                                                        <div className="mt-3">
                                                            <label className="block text-xs font-medium mb-1">Billing Cycle</label>
                                                            <select
                                                                value={financialSettings.billingCycle || 'monthly'}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    billingCycle: e.target.value,
                                                                    customMonths: e.target.value === 'custom' ? 
                                                                        (financialSettings.customMonths || 6) : 
                                                                        undefined
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            >
                                                                <option value="monthly">Monthly</option>
                                                                <option value="quarterly">Quarterly (3 mo)</option>
                                                                <option value="semiannual">Semi-Annual (6 mo)</option>
                                                                <option value="annual">Annual (12 mo)</option>
                                                                <option value="custom">Custom Period</option>
                                                            </select>
                                                            {financialSettings.billingCycle === 'custom' && (
                                                                <input
                                                                    type="number"
                                                                    min="1"
                                                                    value={financialSettings.customMonths || 6}
                                                                    onChange={(e) => setFinancialSettings({
                                                                        ...financialSettings,
                                                                        customMonths: parseInt(e.target.value) || 1
                                                                    })}
                                                                    className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500 mt-2"
                                                                    placeholder="Number of months"
                                                                />
                                                            )}
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Category-Specific Billing Configuration */}
                                {financialSettings.useCategoryBilling && (
                                    <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                                        <h3 className="text-lg font-semibold mb-4">📋 Category-Specific Implementation & Billing</h3>
                                        <div className="space-y-4">
                                            {categories.map(category => (
                                                <div key={category} className="border rounded-lg p-4 bg-gray-50">
                                                    <h4 className="font-semibold text-md mb-3 text-blue-700">{category}</h4>
                                                    <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Implementation Cost ($)</label>
                                                            <input
                                                                type="number"
                                                                value={financialSettings.categoryBilling?.[category]?.implementationCost || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            implementationCost: parseFloat(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Start Month</label>
                                                            <input
                                                                type="number"
                                                                min="0"
                                                                value={financialSettings.categoryBilling?.[category]?.implementationMonth || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            implementationMonth: parseInt(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                                title="Month when implementation starts (0 = first month)"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Ongoing Cost ($/mo)</label>
                                                            <input
                                                                type="number"
                                                                value={financialSettings.categoryBilling?.[category]?.ongoingCostMonthly || 0}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            ongoingCostMonthly: parseFloat(e.target.value) || 0
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="block text-xs font-medium mb-1">Billing Cycle</label>
                                                            <select
                                                                value={financialSettings.categoryBilling?.[category]?.billingCycle || 'monthly'}
                                                                onChange={(e) => setFinancialSettings({
                                                                    ...financialSettings,
                                                                    categoryBilling: {
                                                                        ...financialSettings.categoryBilling,
                                                                        [category]: {
                                                                            ...(financialSettings.categoryBilling?.[category] || {}),
                                                                            billingCycle: e.target.value,
                                                                            customMonths: e.target.value === 'custom' ? 
                                                                                (financialSettings.categoryBilling?.[category]?.customMonths || 6) : 
                                                                                undefined
                                                                        }
                                                                    }
                                                                })}
                                                                className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                            >
                                                                <option value="monthly">Monthly</option>
                                                                <option value="quarterly">Quarterly (3 mo)</option>
                                                                <option value="semiannual">Semi-Annual (6 mo)</option>
                                                                <option value="annual">Annual (12 mo)</option>
                                                                <option value="custom">Custom Period</option>
                                                            </select>
                                                        </div>
                                                        {financialSettings.categoryBilling?.[category]?.billingCycle === 'custom' && (
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Custom Period (months)</label>
                                                                <input
                                                                    type="number"
                                                                    min="1"
                                                                    value={financialSettings.categoryBilling?.[category]?.customMonths || 6}
                                                                    onChange={(e) => setFinancialSettings({
                                                                        ...financialSettings,
                                                                        categoryBilling: {
                                                                            ...financialSettings.categoryBilling,
                                                                            [category]: {
                                                                                ...(financialSettings.categoryBilling?.[category] || {}),
                                                                                customMonths: parseInt(e.target.value) || 1
                                                                            }
                                                                        }
                                                                    })}
                                                                    className="w-full px-2 py-1 text-sm border rounded focus:ring-1 focus:ring-blue-500"
                                                                    placeholder="Number of months"
                                                                />
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                                            <p className="text-sm text-blue-800">
                                                💡 <strong>Tip:</strong> Configure different implementation timelines and costs for each category. 
                                                Start Month determines when the implementation cost is incurred (0 = first month of analysis).
                                            </p>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Financial Metrics Display */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold">📊 Key Financial Metrics</h3>
                                        <button
                                            onClick={() => {
                                                const filteredUseCases = getFilteredUseCases();
                                                const financialCSV = generateFinancialAnalysisCSV(filteredUseCases, financialMetrics, financialSettings);
                                                downloadFile(financialCSV, `financial_analysis_${new Date().toISOString().split('T')[0]}.xls`, 'application/vnd.ms-excel');
                                            }}
                                            className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center gap-2"
                                        >
                                            <Icons.Download />
                                            Export to Excel
                                        </button>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Net Present Value (NPV)</div>
                                            <div className="text-2xl font-bold text-blue-600">
                                                ${financialMetrics.npv.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Value in today's dollars
                                            </div>
                                        </div>
                                        
                                        <div className="bg-green-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Internal Rate of Return (IRR)</div>
                                            <div className="text-2xl font-bold text-green-600">
                                                {financialMetrics.irr ? `${financialMetrics.irr.toFixed(1)}%` : 'N/A'}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Annual return rate
                                            </div>
                                        </div>
                                        
                                        <div className="bg-purple-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Payback Period</div>
                                            <div className="text-2xl font-bold text-purple-600">
                                                {financialMetrics.paybackPeriod !== null && financialMetrics.paybackPeriod !== undefined
                                                    ? `${Math.max(0.1, financialMetrics.paybackPeriod).toFixed(1)} mo`
                                                    : 'N/A'}
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Break-even point
                                            </div>
                                        </div>
                                        
                                        <div className="bg-orange-50 p-4 rounded-lg">
                                            <div className="text-sm text-gray-600 mb-1">Total ROI</div>
                                            <div className="text-2xl font-bold text-orange-600">
                                                {financialMetrics.totalROI.toFixed(0)}%
                                            </div>
                                            <div className="text-xs text-gray-500 mt-1">
                                                Return on investment
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {/* Calculation Breakdown Helper */}
                                    <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                                        <details className="cursor-pointer">
                                            <summary className="font-semibold text-sm text-gray-700 hover:text-gray-900">
                                                💡 How are these numbers calculated? (Click to expand)
                                            </summary>
                                            <div className="mt-3 space-y-3 text-sm text-gray-600">
                                                {(() => {
                                                    try {
                                                        // Calculate the breakdown values
                                                        const filteredMonths = getFilteredMonths();
                                                        const filteredUseCases = getFilteredUseCases();
                                                        
                                                        if (!filteredMonths || filteredMonths.length === 0) {
                                                            return <div>No data available for calculation breakdown.</div>;
                                                        }
                                                        let totalBenefits = 0;
                                                        let totalImplementation = 0;
                                                        let totalOngoing = 0;
                                                    
                                                        filteredMonths.forEach((month, index) => {
                                                            let monthlyBenefit = 0;
                                                            filteredUseCases.forEach(uc => {
                                                                monthlyBenefit += calculateSavings(uc, month.id);
                                                            });
                                                            totalBenefits += monthlyBenefit;
                                                        
                                                            if (financialSettings.useCategoryBilling) {
                                                                categories.forEach(category => {
                                                                    const catSettings = financialSettings.categoryBilling?.[category];
                                                                    if (catSettings) {
                                                                        if (index === catSettings.implementationMonth) {
                                                                            totalImplementation += catSettings.implementationCost || 0;
                                                                        }
                                                                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                        if (index > catSettings.implementationMonth && 
                                                                            ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                            totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                                        }
                                                                    }
                                                                });
                                                            } else {
                                                                if (index === 0) {
                                                                    totalImplementation = financialSettings.implementationCost || 0;
                                                                }
                                                                const cycleMonths = getBillingCycleMonths(
                                                                    financialSettings.billingCycle || 'monthly',
                                                                    financialSettings.customMonths
                                                                );
                                                                if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                                    totalOngoing += financialSettings.ongoingCostMonthly * cycleMonths;
                                                                }
                                                            }
                                                        });
                                                    
                                                        const totalCosts = totalImplementation + totalOngoing;
                                                        const netGain = totalBenefits - totalCosts;
                                                        
                                                        return (
                                                        <>
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">📈 ROI Calculation Breakdown</h4>
                                                                <div className="space-y-1">
                                                                    <div>Total Benefits: <span className="font-mono font-bold text-green-600">${totalBenefits.toLocaleString()}</span></div>
                                                                    <div>Implementation Cost: <span className="font-mono font-bold text-red-600">-${totalImplementation.toLocaleString()}</span></div>
                                                                    {totalOngoing > 0 && (
                                                                        <div>Total Ongoing Costs: <span className="font-mono font-bold text-red-600">-${totalOngoing.toLocaleString()}</span></div>
                                                                    )}
                                                                    <div className="border-t pt-1 mt-1">
                                                                        <div>Net Gain: <span className="font-mono font-bold">${netGain.toLocaleString()}</span></div>
                                                                        <div className="text-xs text-gray-500 mt-1">
                                                                            <strong>Formula:</strong> ROI = (Benefits - Costs) ÷ Costs × 100
                                                                        </div>
                                                                        <div className="text-xs text-gray-500">
                                                                            <strong>Calculation:</strong> ({totalBenefits.toLocaleString()} - {totalCosts.toLocaleString()}) ÷ {totalCosts.toLocaleString()} × 100 = <strong className="text-orange-600">{financialMetrics.totalROI.toFixed(1)}%</strong>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">💰 NPV (Net Present Value)</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>NPV discounts future cash flows to present value using discount rate: <strong>{(financialSettings.discountRate * 100).toFixed(1)}%</strong></div>
                                                                    <div><strong>Formula:</strong> NPV = Σ(Cash Flow ÷ (1 + rate)^period)</div>
                                                                    <div>Each month's benefit is discounted more the further in the future it occurs</div>
                                                                    <div className="text-blue-600 font-semibold">NPV = ${financialMetrics.npv.toLocaleString()}</div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">📊 IRR (Internal Rate of Return)</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>IRR is the discount rate that makes NPV = 0</div>
                                                                    <div>It represents the annual return rate of your investment</div>
                                                                    <div>Higher IRR means better investment performance</div>
                                                                    <div className="text-green-600 font-semibold">Annual IRR = {financialMetrics.irr ? `${financialMetrics.irr.toFixed(1)}%` : 'N/A'}</div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-white p-3 rounded border border-gray-200">
                                                                <h4 className="font-semibold text-gray-700 mb-2">⏱️ Payback Period</h4>
                                                                <div className="space-y-1 text-xs">
                                                                    <div>The point when cumulative benefits equal total costs</div>
                                                                    <div>Calculated by tracking when cumulative cash flow becomes positive</div>
                                                                    {financialMetrics.breakEvenMonth && (
                                                                        <div className="text-purple-600 font-semibold">Your investment breaks even in month {financialMetrics.breakEvenMonth}</div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            
                                                            <div className="bg-blue-100 p-3 rounded">
                                                                <div className="text-xs">
                                                                    <strong>💡 Pro Tip:</strong> Export to Excel to see the complete month-by-month calculation with formulas you can verify and modify. All calculations use the filtered data based on your current view settings.
                                                                </div>
                                                            </div>
                                                        </>
                                                    );
                                                    } catch (error) {
                                                        console.error('Error in calculation breakdown:', error);
                                                        return <div>Error calculating breakdown. Check console.</div>;
                                                    }
                                                })()}
                                            </div>
                                        </details>
                                    </div>
                                    
                                    {/* Payback Period Indicator */}
                                    {financialMetrics.paybackPeriod && (
                                        <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                                            <div className="text-sm font-medium mb-2">Payback Period Assessment:</div>
                                            <div className={`text-sm ${
                                                financialMetrics.paybackPeriod < 12 ? 'text-green-600' :
                                                financialMetrics.paybackPeriod < 18 ? 'text-yellow-600' :
                                                'text-red-600'
                                            }`}>
                                                {financialMetrics.paybackPeriod < 12 ? '✅ Excellent - Less than 12 months' :
                                                 financialMetrics.paybackPeriod < 18 ? '⚠️ Good - 12-18 months' :
                                                 '⚠️ Acceptable - More than 18 months'}
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* Cash Flow Table */}
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-lg font-semibold">💵 Cash Flow Analysis</h3>
                                        <button
                                            onClick={() => setFinancialSettings({
                                                ...financialSettings,
                                                showMonthlyBreakdown: !financialSettings.showMonthlyBreakdown
                                            })}
                                            className="text-sm text-blue-600 hover:text-blue-700"
                                        >
                                            {financialSettings.showMonthlyBreakdown ? 'Hide' : 'Show'} Monthly Details
                                        </button>
                                    </div>
                                    
                                    {financialSettings.showMonthlyBreakdown && financialMetrics.cashFlows.length > 0 && (
                                        <div className="overflow-x-auto">
                                            <table className="min-w-full">
                                                <thead className="bg-gray-50">
                                                    <tr>
                                                        <th className="text-left py-2 px-3">Month</th>
                                                        <th className="text-right py-2 px-3 text-green-700">Benefits</th>
                                                        <th className="text-right py-2 px-3 text-red-700">Implementation</th>
                                                        <th className="text-right py-2 px-3 text-red-700">Ongoing</th>
                                                        <th className="text-right py-2 px-3 font-semibold">Net Cash Flow</th>
                                                        <th className="text-right py-2 px-3">Cumulative</th>
                                                        <th className="text-right py-2 px-3">Present Value</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {financialMetrics.cashFlows.map((cf, index) => {
                                                        const cumulative = financialMetrics.cashFlows
                                                            .slice(0, index + 1)
                                                            .reduce((sum, val) => sum + val, 0);
                                                        const presentValue = cf / Math.pow(1 + financialSettings.discountRate/12, index);
                                                        
                                                        const filteredMonths = getFilteredMonths();
                                                        const filteredUseCases = getFilteredUseCases();
                                                        const monthLabel = filteredMonths[index] 
                                                            ? `${filteredMonths[index].month} ${filteredMonths[index].year}`
                                                            : `Month ${index + 1}`;
                                                        
                                                        // Calculate breakdown for this month
                                                        let monthlyBenefit = 0;
                                                        let implementationCost = 0;
                                                        let ongoingCost = 0;
                                                        
                                                        // Calculate benefits
                                                        if (filteredMonths[index]) {
                                                            filteredUseCases.forEach(uc => {
                                                                monthlyBenefit += calculateSavings(uc, filteredMonths[index].id);
                                                            });
                                                        }
                                                        
                                                        // Calculate costs based on billing mode
                                                        if (financialSettings.useCategoryBilling) {
                                                            // Only include costs for categories that have filtered use cases
                                                            const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                                                            activeCategories.forEach(category => {
                                                                const catSettings = financialSettings.categoryBilling?.[category];
                                                                if (catSettings) {
                                                                    if (index === catSettings.implementationMonth) {
                                                                        implementationCost += catSettings.implementationCost || 0;
                                                                    }
                                                                    const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                    if (index > catSettings.implementationMonth && 
                                                                        ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                        ongoingCost += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                                    }
                                                                }
                                                            });
                                                        } else {
                                                            if (index === 0) {
                                                                implementationCost = financialSettings.implementationCost || 0;
                                                            }
                                                            const cycleMonths = getBillingCycleMonths(
                                                                financialSettings.billingCycle || 'monthly',
                                                                financialSettings.customMonths
                                                            );
                                                            if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                                ongoingCost = financialSettings.ongoingCostMonthly * cycleMonths;
                                                            }
                                                        }
                                                        
                                                        return (
                                                            <tr key={index} className="border-b hover:bg-gray-50">
                                                                <td className="py-2 px-3">
                                                                    {monthLabel}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-green-600">
                                                                    ${monthlyBenefit.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-red-600">
                                                                    {implementationCost > 0 ? `-$${implementationCost.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-'}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-red-600">
                                                                    {ongoingCost > 0 ? `-$${ongoingCost.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-'}
                                                                </td>
                                                                <td className={`text-right py-2 px-3 font-bold ${cf < 0 ? 'text-red-600' : 'text-green-600'}`}>
                                                                    ${cf.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className={`text-right py-2 px-3 font-medium ${cumulative < 0 ? 'text-red-600' : 'text-green-600'}`}>
                                                                    ${cumulative.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                                <td className="text-right py-2 px-3 text-gray-600">
                                                                    ${presentValue.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                                </td>
                                                            </tr>
                                                        );
                                                    })}
                                                </tbody>
                                                <tfoot className="bg-gray-100 font-semibold">
                                                    <tr>
                                                        <td className="py-2 px-3">Total</td>
                                                        <td className="text-right py-2 px-3 text-green-700">
                                                            ${(() => {
                                                                let total = 0;
                                                                const filteredMonths = getFilteredMonths();
                                                                const filteredUseCases = getFilteredUseCases();
                                                                filteredMonths.forEach(month => {
                                                                    filteredUseCases.forEach(uc => {
                                                                        total += calculateSavings(uc, month.id);
                                                                    });
                                                                });
                                                                return total.toLocaleString(undefined, { maximumFractionDigits: 0 });
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-red-700">
                                                            -${(() => {
                                                                let total = 0;
                                                                if (financialSettings.useCategoryBilling) {
                                                                    // Only include costs for categories that have filtered use cases
                                                                    const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                                                                    activeCategories.forEach(category => {
                                                                        const catSettings = financialSettings.categoryBilling?.[category];
                                                                        if (catSettings) {
                                                                            total += catSettings.implementationCost || 0;
                                                                        }
                                                                    });
                                                                } else {
                                                                    total = financialSettings.implementationCost || 0;
                                                                }
                                                                return total.toLocaleString(undefined, { maximumFractionDigits: 0 });
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-red-700">
                                                            {(() => {
                                                                let total = 0;
                                                                const filteredMonths = getFilteredMonths();
                                                                
                                                                if (financialSettings.useCategoryBilling) {
                                                                    // Only include costs for categories that have filtered use cases
                                                                    const activeCategories = [...new Set(getFilteredUseCases().map(uc => uc.category))];
                                                                    activeCategories.forEach(category => {
                                                                        const catSettings = financialSettings.categoryBilling?.[category];
                                                                        if (catSettings) {
                                                                            const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                                            const monthlyCost = catSettings.ongoingCostMonthly || 0;
                                                                            for (let i = 0; i < filteredMonths.length; i++) {
                                                                                if (i > catSettings.implementationMonth && 
                                                                                    ((i - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                                                    total += monthlyCost * cycleMonths;
                                                                                }
                                                                            }
                                                                        }
                                                                    });
                                                                } else if (financialSettings.includeOngoingCosts) {
                                                                    const cycleMonths = getBillingCycleMonths(
                                                                        financialSettings.billingCycle || 'monthly',
                                                                        financialSettings.customMonths
                                                                    );
                                                                    for (let i = 1; i < filteredMonths.length; i++) {
                                                                        if ((i - 1) % cycleMonths === 0) {
                                                                            total += financialSettings.ongoingCostMonthly * cycleMonths;
                                                                        }
                                                                    }
                                                                }
                                                                return total > 0 ? `-$${total.toLocaleString(undefined, { maximumFractionDigits: 0 })}` : '-';
                                                            })()}
                                                        </td>
                                                        <td className="text-right py-2 px-3">
                                                            ${financialMetrics.cashFlows.reduce((sum, cf) => sum + cf, 0).toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                        </td>
                                                        <td className="text-right py-2 px-3">
                                                            -
                                                        </td>
                                                        <td className="text-right py-2 px-3 text-blue-600">
                                                            NPV: ${financialMetrics.npv.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                                                        </td>
                                                    </tr>
                                                </tfoot>
                                            </table>
                                        </div>
                                    )}
                                    
                                    {/* Quick Summary for non-detailed view */}
                                    {!financialSettings.showMonthlyBreakdown && (() => {
                                        // Calculate actual totals from the data
                                        const filteredMonths = getFilteredMonths();
                                        const filteredUseCases = getFilteredUseCases();
                                        let totalBenefits = 0;
                                        let totalImplementation = 0;
                                        let totalOngoing = 0;
                                        
                                        filteredMonths.forEach((month, index) => {
                                            let monthlyBenefit = 0;
                                            filteredUseCases.forEach(uc => {
                                                monthlyBenefit += calculateSavings(uc, month.id);
                                            });
                                            totalBenefits += monthlyBenefit;
                                            
                                            if (financialSettings.useCategoryBilling) {
                                                // Only include costs for categories that have filtered use cases
                                                const activeCategories = [...new Set(filteredUseCases.map(uc => uc.category))];
                                                activeCategories.forEach(category => {
                                                    const catSettings = financialSettings.categoryBilling?.[category];
                                                    if (catSettings) {
                                                        if (index === catSettings.implementationMonth) {
                                                            totalImplementation += catSettings.implementationCost || 0;
                                                        }
                                                        const cycleMonths = getBillingCycleMonths(catSettings.billingCycle, catSettings.customMonths);
                                                        if (index > catSettings.implementationMonth && 
                                                            ((index - catSettings.implementationMonth - 1) % cycleMonths === 0)) {
                                                            totalOngoing += (catSettings.ongoingCostMonthly || 0) * cycleMonths;
                                                        }
                                                    }
                                                });
                                            } else {
                                                if (index === 0) {
                                                    totalImplementation = financialSettings.implementationCost || 0;
                                                }
                                                const cycleMonths = getBillingCycleMonths(
                                                    financialSettings.billingCycle || 'monthly',
                                                    financialSettings.customMonths
                                                );
                                                if (financialSettings.includeOngoingCosts && index > 0 && ((index - 1) % cycleMonths === 0)) {
                                                    totalOngoing += financialSettings.ongoingCostMonthly * cycleMonths;
                                                }
                                            }
                                        });
                                        
                                        const netGain = totalBenefits - totalImplementation - totalOngoing;
                                        
                                        return (
                                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">
                                                        Implementation Cost
                                                        {financialSettings.useCategoryBilling && (
                                                            <span className="text-xs text-blue-600 ml-1">(Category Total)</span>
                                                        )}
                                                    </div>
                                                    <div className="text-lg font-semibold text-red-600">
                                                        -${totalImplementation.toLocaleString()}
                                                    </div>
                                                    {financialSettings.useCategoryBilling && (
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            From {categories.filter(cat => 
                                                                financialSettings.categoryBilling?.[cat]?.implementationCost > 0
                                                            ).length} categories
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">Total Benefits</div>
                                                    <div className="text-lg font-semibold text-green-600">
                                                        ${totalBenefits.toLocaleString()}
                                                    </div>
                                                </div>
                                                <div className="text-center p-3 bg-gray-50 rounded">
                                                    <div className="text-sm text-gray-600">Net Gain</div>
                                                    <div className="text-lg font-semibold text-blue-600">
                                                        ${netGain.toLocaleString()}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                </div>
                                
                                {/* Financial Charts */}
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">📈 Cash Flow & Break-Even Analysis</h3>
                                        <div className="chart-container">
                                            <canvas ref={chartRefs.cashFlow}></canvas>
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h3 className="text-lg font-semibold mb-4">💰 Cumulative Net Cash Flow</h3>
                                        <div className="chart-container">
                                            <canvas ref={chartRefs.breakeven}></canvas>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Category-specific charts when using category billing */}
                                {financialSettings.useCategoryBilling && (
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-4">🏷️ Category Implementation Costs</h3>
                                            <div className="chart-container">
                                                <canvas ref={chartRefs.categoryImplementation}></canvas>
                                            </div>
                                        </div>
                                        <div className="bg-white rounded-lg shadow-lg p-6">
                                            <h3 className="text-lg font-semibold mb-4">📊 Category Cost Timeline</h3>
                                            <div className="chart-container">
                                                <canvas ref={chartRefs.categoryCostTimeline}></canvas>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Financial Formulas Reference */}
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="text-lg font-semibold mb-4">📐 Financial Formulas Reference</h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                        <div>
                                            <div className="font-medium mb-2">NPV (Net Present Value):</div>
                                            <code className="block p-2 bg-white rounded text-xs">
                                                NPV = Σ(CashFlow_t / (1 + r)^t) - Initial Investment
                                            </code>
                                            <div className="text-gray-600 mt-1">Where r = discount rate, t = time period</div>
                                        </div>
                                        <div>
                                            <div className="font-medium mb-2">IRR (Internal Rate of Return):</div>
                                            <code className="block p-2 bg-white rounded text-xs">
                                                0 = Σ(CashFlow_t / (1 + IRR)^t)
                                            </code>
                                            <div className="text-gray-600 mt-1">Rate where NPV equals zero</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Guidance Tab */}
                        {activeTab === 'guidance' && (
                            <div className="space-y-6">
                                <div className="bg-white rounded-lg shadow-lg p-6">
                                    <h2 className="text-2xl font-bold mb-4">Input Guidance</h2>
                                    <div className="grid grid-cols-1 gap-4">
                                        {Object.keys(InputGuidance).map((metric) => (
                                            <div
                                                key={metric}
                                                className="guidance-card cursor-pointer hover:shadow-lg transition-shadow"
                                                onClick={() => {
                                                    setSelectedMetricGuide(metric);
                                                    setShowGuidanceModal(true);
                                                }}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <div className="guidance-title">{metric}</div>
                                                        <div className="guidance-content">
                                                            <p className="mb-2">{InputGuidance[metric].baseline.description}</p>
                                                        </div>
                                                    </div>
                                                    <Icons.Info />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Guidance Modal */}
                        <GuidanceModal />
                        
                        {/* Mobile Floating Sponsor Button - Top right */}
                        {isMobile && (
                            <div
                                onClick={() => setShowSponsorOverlay(true)}
                                style={{
                                    position: 'fixed',
                                    top: '10px',
                                    right: '10px',
                                    width: '40px',
                                    height: '40px',
                                    borderRadius: '50%',
                                    background: 'linear-gradient(135deg, #ec4899, #8b5cf6)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
                                    zIndex: 9999,
                                    cursor: 'pointer',
                                    WebkitTapHighlightColor: 'transparent'
                                }}
                                role="button"
                                aria-label="Support"
                            >
                                <div style={{ color: 'white', fontSize: '18px', lineHeight: '1' }}>♥</div>
                            </div>
                        )}
                        
                        {/* Edit Use Case Modal */}
                        {showEditModal && editingUseCase && (
                            <div className="modal-overlay" onClick={() => setShowEditModal(false)}>
                                <div className="modal-content" style={{maxWidth: '600px'}} onClick={(e) => e.stopPropagation()}>
                                    <div className="modal-close" onClick={() => setShowEditModal(false)}>
                                        <Icons.Close />
                                    </div>
                                    <h3 className="text-xl font-bold mb-4">Edit Use Case: {editingUseCase.name}</h3>
                                    
                                    <div className="space-y-4">
                                        {/* Edit Name */}
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Use Case Name</label>
                                            <input
                                                type="text"
                                                value={editingUseCase.name}
                                                onChange={(e) => setEditingUseCase({...editingUseCase, name: e.target.value})}
                                                className="w-full px-3 py-2 border rounded-md"
                                            />
                                        </div>
                                        
                                        {/* Edit Category and Channel */}
                                        <div className="grid grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium mb-1">Category</label>
                                                <select
                                                    value={editingUseCase.category}
                                                    onChange={(e) => setEditingUseCase({...editingUseCase, category: e.target.value})}
                                                    className="w-full px-3 py-2 border rounded-md"
                                                >
                                                    {categories.map(category => (
                                                        <option key={category} value={category}>{category}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium mb-1">Channel</label>
                                                <select
                                                    value={editingUseCase.channel}
                                                    onChange={(e) => setEditingUseCase({...editingUseCase, channel: e.target.value})}
                                                    className="w-full px-3 py-2 border rounded-md"
                                                >
                                                    <option value="phone">Phone</option>
                                                    <option value="chat">Chat</option>
                                                    <option value="email">Email</option>
                                                    <option value="sms">SMS</option>
                                                    <option value="social">Social</option>
                                                    <option value="bot">Bot</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        {/* Edit Benefits */}
                                        <div>
                                            <h4 className="font-medium mb-2">Benefits (Value Drivers)</h4>
                                            {editingUseCase.benefits && editingUseCase.benefits.map((benefit, index) => (
                                                <div key={index} className="mb-3">
                                                    <div className="grid grid-cols-6 gap-2 mb-1 items-center">
                                                        <select
                                                            value={benefit.metric}
                                                            onChange={(e) => {
                                                                const newBenefits = [...editingUseCase.benefits];
                                                                newBenefits[index] = {...benefit, metric: e.target.value};
                                                                setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                            }}
                                                            className="col-span-3 px-3 py-2 border rounded"
                                                        >
                                                            {getAvailableMetrics().map(metric => (
                                                                <option key={metric} value={metric} disabled={editingUseCase?.benefits?.some((b, idx) => idx !== index && b.metric === metric)}>{metric}</option>
                                                            ))}
                                                        </select>
                                                        <div className="col-span-2">
                                                            <label className="text-xs text-gray-600 block mb-1">
                                                                Baseline {benefit.metric.includes('min') ? '(minutes)' : benefit.metric.includes('points') ? '(points)' : '(%)'}
                                                            </label>
                                                            <input
                                                                type="number"
                                                                placeholder={
                                                                    benefit.metric.includes('min') ? 'Minutes' : 
                                                                    benefit.metric.includes('points') ? 'Points' : 
                                                                    'Percent'
                                                                }
                                                                value={benefit.baselineValue || ''}
                                                                onChange={(e) => {
                                                                    const newBenefits = [...editingUseCase.benefits];
                                                                    newBenefits[index] = {...benefit, baselineValue: parseFloat(e.target.value) || 0};
                                                                    setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                                }}
                                                                className="col-span-2 px-3 py-2 border rounded w-full"
                                                            />
                                                        </div>
                                                        <button
                                                        onClick={() => {
                                                            const newBenefits = editingUseCase.benefits.filter((_, i) => i !== index);
                                                            setEditingUseCase({...editingUseCase, benefits: newBenefits});
                                                        }}
                                                        className="text-red-600 hover:text-red-800"
                                                    >
                                                            <Icons.Trash />
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                            
                                            {/* Add New Benefit Button */}
                                            <button
                                                onClick={() => {
                                                    // Find a metric that isn't already used
                                                    const availableMetrics = getAvailableMetrics().filter(m => 
                                                        !editingUseCase.benefits.some(b => b.metric === m)
                                                    );
                                                    if (availableMetrics.length > 0) {
                                                        setEditingUseCase({
                                                            ...editingUseCase, 
                                                            benefits: [...(editingUseCase.benefits || []), {metric: availableMetrics[0], baselineValue: 0}]
                                                        });
                                                    } else {
                                                        alert('All available metrics have been added.');
                                                    }
                                                }}
                                                className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 mt-2"
                                                disabled={editingUseCase?.benefits?.length >= getAvailableMetrics().length}
                                            >
                                                Add Benefit
                                            </button>
                                        </div>
                                        
                                        {/* Save/Cancel Buttons */}
                                        <div className="flex justify-end gap-2 pt-4">
                                            <button
                                                onClick={() => {
                                                    setShowEditModal(false);
                                                    setEditingUseCase(null);
                                                }}
                                                className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
                                            >
                                                Cancel
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (editingUseCase.name) {
                                                        // Save to undo stack before making changes
                                                        setUndoStack(prev => [...prev.slice(-49), deepCopyUseCases(useCases)]);
                                                        setRedoStack([]);
                                                        
                                                        const original = useCases.find(uc => uc.id === editingUseCase.id);
                                                        const migrated = original ? migrateUseCaseBenefitKeys(original, editingUseCase) : editingUseCase;
                                                        setUseCases(useCases.map(uc => 
                                                            uc.id === editingUseCase.id ? migrated : uc
                                                        ));
                                                        setShowEditModal(false);
                                                        setEditingUseCase(null);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
                                            >
                                                Save Changes
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Render the application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AIValueCalculator />);
    </script>
</body>
</html>
